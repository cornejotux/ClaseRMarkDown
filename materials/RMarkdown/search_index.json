[
["index.html", "Introducción a la Investigación Reproducible con RStudio y RMarkdown 1 Introducción 1.1 La crisis de reproducibilidad 1.2 Reconocimientos", " Introducción a la Investigación Reproducible con RStudio y RMarkdown Julio 11-15, 2019 1 Introducción La reproducibilidad es fundamental en la ciencia, ya que la ciencia está basada en observaciones empíricas acopladas a modelos explicativos. Si bien la reproducibilidad incluye el ciclo de vida completo de la ciencia y además incluye aspectos como la consistencia metodológica y tratamiento del sesgo, en este curso nos enfocaremos a la reproducibilidad computacional, esto es la habilidad para documentar datos, análisis y modelos en forma suficiente para que otros investigadores sean capaces de entender, reproducir y re-ejecutar los pasos computacionales que nos permitieron llegar a los resultados y sus conclusiones. 1.1 La crisis de reproducibilidad Ioannidis (2005) destacó la crisis en reproducilidad de la ciencia cuando escribió que “La mayoría de los descubrimientos son falsos para la mayoría de los diseños de investigación, en la mayoría de las áreas de investigación” (“Most Research Findings Are False for Most Research Designs and for Most Fields”). Ioannidis indica la formas en que el proceso de investigación ha inflado los efectos de los tamaños muestrales y los tests de hipótesis que codifican los sesgos existentes. Investigaciones posteriores han confirmado que la reproducibilidad es baja para muchos campos de la ciencia, incluyendo genética (Ioannidis et al. 2009), ecología (Fraser et al. 2018), y psicología (Open Science Collaboration 2015), entre muchas otras. Por ejemplo, el efecto del tamaño de muestra en la psicología se ha mostrado que decrece significativamente cuando se repiten los experimentos (fig. 1.1). Figure 1.1: Efecto del tamaño de muestra descrese en experimentos repetidos (Open Sieze Collaboration 2015). 1.2 Reconocimientos Este curso está basado en el desarrollado por el Arctic Data Center en NCEAS y ha sido modificado y traducido con el apoyo del Instituto de Fomento Pesquero por Jorge Cornejo-Donoso. Antes de comenzar con el material para la investigación reproducible, es necesario que aprendamos sobre algunas herramientas fundamentales, como son RStudio, Git/Github y con posterioridad comenzaremos a trabajar con RMarkDown. Referencias "],
["investigación-reproducible-de-qué-estamos-hablando.html", "2 Investigación reproducible: ¿De qué estamos hablando? 2.1 Objetivos 2.2 Investigación reproducible", " 2 Investigación reproducible: ¿De qué estamos hablando? 2.1 Objetivos En este capítulo veremos: En qué consiste la reproducibilidad computacional y por que es útil e importante. La importancia del control de versiones para la reproducibilidad computacional. Cómo verificar que el ambiente de RStudio está configurado adecuadamente para el análisis. Cómo configurar git. 2.2 Investigación reproducible Las reproducibilidad es fundamental en la ciencia, que a su vez se basa en observaciones empíricas con las que se construyen o define modelos explicativos. La reproducibilidad por su parte, envuelve todo el ciclo de vida de la ciencia, incluyendo aspectos como la consistencia metodológica y el tratamiento del sesgo. En este curso nos vamos a enfocar en la reproducibilidad computacional, entendiendo esto como la habilidad de documentar datos, análisis y modelos con la suficiente información para que otros investigadores sean capaces de entender e idealmente reproducir, paso a paso, el proceso que no a los resultados y conclusiones de nuestra investigación. 2.2.1 ¿Qué es necesario para la reproducibilidad computacional? El primer paso para abordar este problema es ser capaz de evaluar los datos, análisis y modelos con los que se sacan las conclusiones. Considerando cuales son las prácticas más comunes, esto resulta bastante difícil ya que la generalidad de los datos no se encuentran disponibles, la sección sobre la metodología de los informes y papers no describe en detalle las aproximaciones computacionales utilizadas o los análisis y además los modelos son generalmente realizados en programas gráficos o, cuando se usan ambientes tipo script, el código no se hace disponible. Sin embargo todos estos inconvenientes pueden ser fácilmente solucionados. Los investigadores pueden lograr la reproducibilidad computacional con aproximaciones basada en las aproximaciones de ciencia libre (open science), siguiendo pasos simples para archivar y publicar (libremente) los datos y códigos fuentes utilizados, describiendo el flujo de trabajo y permitiendo de esta forma trazabilidad de los resultados (ej.:, Hampton et al. (2015), Munafò et al. (2017)). 2.2.2 Conceptualizando los flujos de trabajo (workflows) El flujo del trabajo científico encapsula todos los pasos desde la adquisición de los datos, limpieza, transformación, integración, análisis y visualización. Figure 2.1: Captura de un flujo de trabajo científico y procedencia de múltiples pasos necesarios para reproducir un resultado científico desde los datos crudos. Una representación del flujo de trabajo puede variar desde simples diagramas de flujo (fig. 2.1) a códigos totalmente ejecutables. Códigos de R y python son una forma literal de plasmár el flujo de trabajo lo que cuando son publicados por investifacores, como versiones específicas del código y los datos asociados, permite la repetibilidad de sus cómputos en forma simple y de esta forma entender la procedencia de las conclusiones. Referencias "],
["herramientas-rstudio-gitgithub-configuración-y-motivación.html", "3 Herramientas: RStudio - Git/GitHub Configuración y Motivación 3.1 Por que usar git? 3.2 Revisando el ambiente de RStudio 3.3 Configurando git", " 3 Herramientas: RStudio - Git/GitHub Configuración y Motivación 3.1 Por que usar git? 3.1.1 El problema con los nombres de archivos Figure 3.1: El dilema de usar nombres como descriptor de versiones. Cada archivo en un proceso científico sufre de cambios. Los manuscritos son editados. Las figuras son revisadas. Los códigos se corrigen cuando se encuentran problemas. Los archivos de datos se combinan, se corrigen errores, dividen y combinan nuevamente. En el curso de un análisis simple, uno puede esperar miles de cambios en los archivos. Y aún así, todo lo que usamos (al menos la mayoría) para identificar este sinnúmero de cambios son simples nombres de archivos (fig. 3.1). Teniendo esto en consideración, es lógico pensar que debe existir una forma mejor de hacer eso… Y si, la hay, se conoce como Control de Versiones. Un sistema de control de versiones ayuda a seguir los cambios que se realizan a nuestros archivos, sin el desastre que resulta de utilizar sólo los nombres de archivos. En los sistemas de control de versiones como git, se registra no sólo el nombre del archivo, si no que además su contenido, de esta forma, cuando el contenido cambia se puede identificar que partes cambiaron y donde. El sistema registra además que versión de un archivo viene de una versión previa, teniendo un historial de todos los cambios realizados, así se hace fácil dibujar un gráfico que represente los cambios que ha sufrido un archivo, con todas sus versiones, algo como lo que se muestra en la figura 3.2: Figure 3.2: Evolución de las versiones de un archivo. Los sistemas de control de versiones asignan un identificador a cada versión de cada archivo y mantiene un registro de como estos están relacionados entre si. Además, estos sistemas permiten ramificaciones en estas versiones y fusiones de regreso a la tronco principal de trabajo. Se puede ademas tener múltiples copias en múltiples computadores como respaldos y para trabajo colaborativo. Es posible además incluir etiquetas (tags) a versiones en particular y así poder retornar a una versión en particular de los archivos cuando fueron etiquetados. Por ejemplo, la versión exacta de los datos, código y texto de un manuscrito que fue enviado y que tiene la etiqueta R2 en la figura 3.2. 3.2 Revisando el ambiente de RStudio 3.2.1 Versión de R Vamos a usar R version 3.6.1 (2017-01-27), que puede ser descargada e instalada desde CRAN. Para ver que versión tiene instalada, ejecute el siguiente comando en la consola de RStudio: R.version$version.string 3.2.2 Versión de RStudio Vamos a usar la versión de RStudio 1.2.1335 o posterior, la que se puede descargar e instalar desde aquí. Para verificar que versión de RStudio tiene instalada, ejecute el siguiente comando en la consola de RStudio: RStudio.Version()$version Si el resultado no dice 1.2.1335 (o es una versión anterior), por favor actualice su RStudio haciendo clic en “Help -&gt; Check for Updates” y siguiendo las instrucciones. 3.2.3 Instalación de Paquetes de R Ejecute las siguientes líneas de código para verificar que todos los paquetes necesarios para este curso están instalados en su computador. packages &lt;- c(&quot;devtools&quot;, &quot;dplyr&quot;, &quot;DT&quot;, &quot;ggplot2&quot;, &quot;leaflet&quot;, &quot;roxygen2&quot;, &quot;tidyr&quot;) for (package in packages) { if (!(package %in% installed.packages())) { install.packages(package) } } rm(packages) #Elimina los paquetes desde el entorno de trabajo Si hay algún paquete que no esté instalado, esto va a instalarlo automáticamente. Si ya estuvieran instalados, no verá ninguna salida en o mensaje. A continuación, cree un nuevo archivo de R Markdown (File -&gt; New File -&gt; R Markdown). Si nunca ha creado archivo R Markdown previamente, aparecerá un diálogo preguntando si desea instalar los paquetes requeridos. Haga clic en Yes. 3.3 Configurando git Si aun no lo ha hecho, vaya a github.com y cree una cuenta. Si aun no ha bajado e instalado el software de git, descárgelo aquí y proceda a su instalación. Antes de usar git, tiene que decirle quien es usted, para eso se debe establecer las opciones de configuración globales (setting the global options). Lamentablemente, la única forma de hacer esto es por medio de la línea de comando. La versión RStudio que tiene instalada (si es que siguió las instrucciones que le dimos) permite abrir una ventana de terminal en su sesión de RStudio. Para hacer esto seleccione Tools -&gt; Terminal -&gt; New Terminal. Una pestaña de terminal debería abrirse donde se encuentra normalmente la consola de R. Para establecer las opciones de configuración globales, escriba los siguientes comandos en la pestaña del terminal, reemplazando “Su Nombre” por su nombre real y luego presione enter: git config --global user.name &quot;Su Nombre&quot; Luego escriba la siguiente línea de comandos, con la dirección de correo electrónico que usó en la creación de su cuenta en github.com: git config --global user.email &quot;SuEmail@DominioEmail.cl&quot; Por favor note que estas lineas DEBEN ser ejecutada una a la vez. Finalmente, para asegurarse que todo está correcto, escriba este comando que le mostrará las opciones que acaba de definir. git config --global --list 3.3.1 Nota para Usuarios de Windows Si obtienen el mensaje que dice “comando no encontrado” o en inglés “command not found” (o similar) cuando ejecute estos pasos en la pestaña del terminal de RStudio, puede ser que necesite definir el tipo de terminal que abre RStudio. Bajo algunas instalaciones de git, puede darse que el ejecutable de git no funcione en el terminal que se abre por defecto. "],
["introducción-a-r.html", "4 Introducción a R 4.1 Objetivos 4.2 Introducción y Motivación 4.3 R en la consola", " 4 Introducción a R 4.1 Objetivos En este capítulo veremos: Como Orientarse dentro de la interfase de RStudio. Como trabajar en la consola de R. 4.2 Introducción y Motivación Existe una comunidad muy activa que colectivamente desarrolla herramientas de programación potentes, de código abierto y cada vez más fáciles de usar. El progreso actual en relación a las herramientas de programación permiten que aprender a escribir códigos computacionales sea cada vez más fácil. Esto hace posible que se incorpore la programación a los procesos de análisis, haciendo a la ciencia más eficiente y computacionalmente reproducible. En este curso vamos a usar el lenguaje de programación R y con el Ambiente de Programación Integrada o IDE por sus siglas en inglés (Integrated Development Environment) RStudio. R es un lenguaje ideal para aprender programación orientada a los datos ya que ampliamente utilizada por la comunidad científica, es amigable con el usuario (user-friendly) y lo más importante, es de código abierto (open source). Entonces, ¿cuáles son las diferencias entre R y RStudio? Aquí les presento una analogía como punto de partida. Si usted fuera un chef, R es un cuchillo. Usted tiene comida para preparar y el cuchillo es una de las herramientas que va a usar para realizar esta tarea. Y si R es un cuchillo, entonces RStudio es la cocina. ¡RStudio le entrega el lugar donde puede realizar todo su trabajo! Como pueden ser otras herramientas, comunicaciones, acceso a la comunidad y así hace de su vida como chef más fácil. Ahora, como científico, RStudio hace su vida más fácil poniendo todas las herramienta que usted necesita en un mismo lugar, de esta forma puede trabajar en forma más eficiente. Algunas de las herramientas que puede encontrar son un navegador de archivos, visor de datos, páginas de ayuda, terminal, comunidad de usuairos, soporte y la lista suma y sigue. De esta forma, es fácil ver que RStudio es mucho más que sólo una infraestructura (la interfase del usuario o IDE). Entonces, si bien es posible preparar comida sin una cocina, es totalmente posible aprender y trabajar en R sin usar RStudio, sin embargo eso no es lo que vamos hacer. Nosotros vamos a aprovechar los beneficios de usar RStudio y aprenderemos R y RStudio al mismo tiempo. Figure 4.1: Usar R sin RStudio es como tener una rueda cuadrada. No tiene sentido. Para tener en cuenta: Vamos a aprender un nuevo lenguaje (de programación). Este es un proceso que toma tiempo, se cometerán errores, puede resultar frustrante, pero a largo plazo va a ser genial. Todos hablamos a lo menos un lenguaje; aprender un leguaje de programación es un proceso similar, de verdad. No importa cuán fluido sea en su lengua materna, siempre se puede aprender algo nuevo, se tratan cosas en un nuevo contexto, se aprenden sinónimos o el significado nuevo que se le da a una palabra en otro país, etc. Y como cualquier otra forma de comunicación, se producirán malos entendidos que pueden ser frustrantes, pero a la larga, todos terminaremos siendo mejores si aprendemos de ellos. Así como un lenguaje es un concepto familiar, lenguajes de programación existen en un contexto diferente de los lenguajes hablados, pero vamos a llegar a conocer este contexto con el tiempo. Por ejemplo: tenemos un concepto que es la primera comida del día y tenemos un nombre para describirla: en español esa palabra es “desayuno”. Si usted aprende inglés, puede esperar que exista una palabra para expresar este concepto de la primera comida del día (esa palabra es “breakfast”). Vamos a llegar al punto en que usted va a esperar la existencia de ciertas palabras en un lenguaje de programación (llamados funciones en R) que representen conceptos. Pronto, usted va a esperar que exista una forma de ordenar valores en forma numérica o alfabética, para buscar patrones en un texto, calcular la media o mediana, reorganizar columnas en una fila, extraer un subset de datos, etc. Paso a paso, vamos a ir incrementando sus expectativas y aprenderán como preguntarle a R y RStudio ára encontrar las palabras que están buscando. 4.2.1 Recursos Este curso es una traducción libre, modificada y adaptada de una grupo de excelentes clases y materiales desarrollados por otros autores. Muchas gracias al Data Task Force de NCEAS, en especial a Jeannette Clark, Jared Kibele, Matt Jones, del cual también fui parte, quienes desarrollaron la versión original de este curso en Inglés. A Julie Lowndes por escribir la mayoría del contenido y compartilo para ser usado de base al contenido desarrollado por el Data task Force. El material de Julie esta a su vez está basado en el de Jenny Bryan. Todo el material original sobre el cual está basado este curso está en inglés, sin embargo les recomiendo darle una mirada y usarlos como referencias: Julie Lowndes’ Data Science Training for the Ocean Health Index R, RStudio, RMarkdown Programming in R Jenny Bryan’s lectures from STAT545 at UBC R basics, workspace and working directory, RStudio projects Basic care and feeding of data in R RStudio (también en inglés): webinars cheatsheets Finalmente, el libro R for Data Science por Hadley Wickham es un recurso genial para profundizar en estos temas. R for Data Science Otros recursos relacionados: Formate de ecuaciones en LaTeX Base R Cheatsheet RMarkdown Reference Guide MATLAB/R Translation Cheat Sheet 4.3 R en la consola Y ahora manos a la obra. Inicie RStudio/R. Figure 4.2: Captura de pantalla de la interfase de desarrollo de RStudio. Identifique los paneles que se abren por defecto: Consola (Todo el espacio a la izquierda) Ambiente/Historial (Pestañas al lado superior derecho) Archivos/Gráficos/Paquetes/Ayuda (Pestañas al lado inferior derecho) Es posible cambiar la ubicación por defecto de los paneles, entre otra muchas cosas: Configurando RStudio (En inglés). Una primera pregunta importante: ¿Dónde estamos? Si usted abre RStudio por primera vez, se va a encontrar en el directorio Home. Esto se denota por como ~/ en la barra superior de la consola (destacado en rojo en la figura 4.3). Es esta figura es posible ver también el panel de archivos en el lado inferior derecho, donde se muestra que está en el directorio Home. Usted puede navegar con el explorador de archivos, pero note que no es posible cambiar donde está trabajando: incluso cuando haga clic el otros directorios, la consola seguirá estando en el directorio Home: ~/. Figure 4.3: Consola de R en la interfase de usuario de RStudio. OK vamos ahora a la consola, aquí se puede interactuar con el proceso de R en forma interactiva. Vamos a usar R para calcular hacer algunos cálculos matemáticos simples. 3*4 ## [1] 12 Usted puede asignar un valor de una operación matemática a una variable u objeto en R. Para esto se utiliza el operador de asignación &lt;-. Haga una asignación y luego inspeccione el objeto que acaba de crear. x &lt;- 3 * 4 x ## [1] 12 Esas operaciones yo las leo como ’asigne el valor resultante de la operación 3*4 a x’. Todas las declaraciones en R donde usted crea objetos – “asignaciones” – tienen esta forma: nombreObjeto &lt;- valor. Ahora voy a incluir en la consola el símbolo gato o hash # seguido de un texto, esta es la forma en que R reconoce que esa línea corresponde a un comentario y no lo evalúa. ## nombreObjecto &lt;- valor ## Esta es la forma en que se escriben textos en el código para explicar que es lo que ## se está haciendo. Los nombres de objetos en R no pueden comenzar con números o contener algunos caracteres reservados como son la coma “,” o espacios en blanco. Es útil adoptar la [estándares de nomenclatura] (http://programacion.jias.es/2017/09/estandares-de-nomenclatura-snake-case-kebab-case-camel-case/) en los nombres de variables. # yo_uso_snake_case # otra.gente.usa.puntos # yOtrosUsanCamelCase Asignando un valor a una variable este_es_un_nombre_muy_largo &lt;- 2.5 Para inspeccionar esta variable, en vez que escribirla completa, podemos apretar la flecha hacia arriba y llamar al historial de comandos, apareciendo los comandos más recientes primero. Ahora intente hacer eso y luego borre la asignación (&lt;- 2.5): este_es_un_nombre_muy_largo ## [1] 2.5 Otra forma de inspeccionar esta variable es escribiendo el inicio este_… y luego presionando la techa Tab, de esta forma RStudio le va a ofrecer los objetos cuyor nombre comienzan de esa forma, entre las que puede seleccionar apretando return. Y una más la_ciencia_es_genial &lt;- &quot;Si lo es!!!&quot; Aquí se puede ver que es posible hacer asignaciones de palabras y no únicamente números. En R, un objeto compuesto por palabras se conoce como “string” y R los reconoce como una palabra y no un número porque están en comillas &quot; &quot;. En R se puede trabajar con datos basados en texto (strings) en forma muy simple gracias a los paquetes stringr y tidytext. No vamos a hablar mucho de este tipo de datos, por ahora sólo recuerde que R puede manejar texto y con números en forma combinada. El hablar de strings y números nos lleva a abordar un concepto muy importante en programación: las diferentes clases o tipos de objetos. Un objeto puede ser muchas cosas, por ejemplo una variable, una función, una estructura de datos, un método que haya escrito en un ambiente de desarrollo. Usted puede ver que objetos están cargados en el panel Environment (ambiente) en RStudio. Las operaciones que se pueden hacer con un objeto van a depender del tipo de objeto que es. ¡¡Esto tiene mucho sentido!! Por ejemplo, no es posible hacer operaciones matemáticas con un objeto de caracteres (string). Trate de ejecutar lo siguiente en la línea de comandos de su consola: &quot;Hola mundo!&quot; * 3 ¿Qué pasó? ¿Por qué? Usted debería haber notado que cuando se asigna un valor a un objeto, R no imprime el valor por pantalla. Se puede forzar a R a imprimir por pantalla poniendo un paréntesis en la asignación del valor o escribiendo el nombre del objeto: peso_kg &lt;- 55 # Esto no imprime nada (peso_kg &lt;- 55) # pero al poner parentesis alrededore se imprime el valor de `peso_kg` ## [1] 55 peso_kg # y tambien esto lo hace al escribir el nombre del objeto ## [1] 55 Ahora que R tiene peso_kg en la memoria, podemos utilizar esta variable para hacer operaciones aritméticas. Por ejemplo, podemos querer convertir este peso a libras (libras es 2.2 veces el peso en kilogramos): 2.2 * peso_kg ## [1] 121 También es posible cambiar el valor de la variable asignando una nueva: peso_kg &lt;- 57.5 2.2 * peso_kg ## [1] 126.5 Esto significa que al asignar el valor a una variable, no cambia el valor de la otras variables. Por ejemplo, asignemos el valor del peso del animal en libras a peso_lb: peso_lb &lt;- 2.2 * peso_kg y ahora cambiemos peso_kg a 100. peso_kg &lt;- 100 ¿Cuál cree que es el valor ahora del objeto peso_lb? ¿126.5 o 220? ¿Por qué? También es posible almacenar más de un valor en un único objeto. Almacenar una series de pesos en un sólo objeto es una forma muy conveniente de desarrollar un misma operación en múltiples valores al mismo tiempo. Para hacer esto se puede usar la función c(), que se refiere a la acción de combinar o concatenar. Aquí vamos a crear un vector de pesos en kilogramos y vamos a convertirlos todos a libras, asignando el peso en libras a un nuevo objeto. peso_kg &lt;- c(55, 25, 12) peso_kg ## [1] 55 25 12 peso_lb &lt;- peso_kg * 2.2 peso_lb ## [1] 121.0 55.0 26.4 4.3.1 Los mensajes de error son sus amigos Contrato implícito con el lenguaje de computador/codificación: Un computador hará todas las computaciones tediosas por usted. Usted tiene que ser completamente explícito y preciso son sus instrucciones. Errores ortográficos importan. Mayúsculas importan. ¡Tiene que poner atención a como escribe! Recuerde que este es un lenguaje ¡No demasiado distinto al español!. Hay tiempos en los que la gente no entiende lo que usted dice – Eso pasa y va a pasar nuevamente y hay diferentes formas en que esto puede pasar. Algunas veces se obtendrá un error. Esto es similar a cuando alguien le dice ¿Qué? o ¿Puede repetir por favor? No logro entenderlo. Los mensajes de error son muy útiles en este sentido, porque le indican cuales son las partes específicas en las que no le lograron entender. Este es el mejor tipo de errores que se pueden obtener. Los mensajes de error son sus amigos. Búsquelos en Google (¡Copiar y Pegar!) para descubrir que es lo que significan y como los puede corregir. Figure 4.4: . Pero también hay que tener en cuenta que hay errores que pueden aparecen en forma mucho mas sutil, sin un mensaje de error que lo indique. Esto sucede cuando se le da información que el computador entiende, pero que no es exactamente lo que se quiso decir. Es como si yo contara un historia sobre tablas y usted se imagina una con la que va a construir una repisa, sin embargo yo estoy hablando de tablas de datos. Esto puede llevarme a pensar que logré transmitir la información que me interesaba a mi audiencia (o a R) sin embargo, lo que dije fue interpretado en una forma completamente distinta a lo que estaba tratando de decir. Y en la medida que yo sigo hablando se genera más y más confusión… Entonces, es muy importante que se escriban los códigos de una forma lo más limpia y clara, verificando que el código hace lo que quiere que haga, minimizando las confusiones y malos entendidos. 4.3.2 Operadores y expresiones lógicas Vamos a tomarnos un momento para hablar sobre operadores y expresiones lógicas ya que nos permiten hacer preguntas sobre los objetos que hemos creado. == significa ‘es igual a’ != significa ‘no es igual a’ &lt; significa ‘es menor a’ &gt; significa ‘es mayor a’ &lt;= significa ‘es menor o igual a’ &gt;= significa ‘es mayor o igual a’ peso_kg == 2 ## [1] FALSE FALSE FALSE peso_kg &gt;= 30 ## [1] TRUE FALSE FALSE peso_kg != 5 ## [1] TRUE TRUE TRUE Atajos del teclado: En su vida como programador de R se van a realizar muchas asignaciones y el operador &lt;- es un dolor de cabeza para escribir. Sin embargo no sea flojo y NO se acostumbre a usar =, aunque esto funciona, porque sólo le va a generar confusión más tarde. Es mucho mejor utilizar los atajos con combinaciones de teclas para este fin, en RStudio se obtiene combinando Alt + - (signo menos). Note que en RStudio los espacios alrededor de &lt;- ¡aparecen en forma automágica!, lo que demuestra una buena práctica para formatear el código. Los códigos (especialmente los ajenos) son miserables de leer en un buen día. Dele un descanso a sus ojos y SIEMPRE use los espacios. RStudio tiene muchos atajos de teclado shortcuts muy útiles. Uno importante de mencionar es Alt+Shift+K que muestra la tabla de referencias de las combinaciones de teclado. 4.3.3 Limpiando el ambiente de trabajo Ahora vamos a mirar los objetos que están en nuestro ambiente de trabajo (Environment) – en el costado superior derecho. El ambiente de trabajo es donde se acumulan los objetos definidos por el usuario. Figure 4.5: Captura de pantalla de la interfase de desarrollo de RStudio con comando ejecutados. También se puede obtener una lista de los objetos creado usando los siguiente comandos en R: objects() ## [1] &quot;este_es_un_nombre_muy_largo&quot; &quot;la_ciencia_es_genial&quot; ## [3] &quot;peso_kg&quot; &quot;peso_lb&quot; ## [5] &quot;x&quot; ls() ## [1] &quot;este_es_un_nombre_muy_largo&quot; &quot;la_ciencia_es_genial&quot; ## [3] &quot;peso_kg&quot; &quot;peso_lb&quot; ## [5] &quot;x&quot; Si quiere eliminar el objeto llamado peso_kg puede hacer lo siguiente: rm(peso_kg) Para eliminar todo: rm(list = ls()) o hacer clic en el icono de la la escoba en el panel Environment en RStudio. "],
["rmarkdown.html", "5 RMarkdown 5.1 Objetivos 5.2 Introducción 5.3 Funciones de R 5.4 Páginas de ayuda 5.5 Leyendo un archivo de datos a R 5.6 Usando data.frames 5.7 Solución de problemas 5.8 Análisis literal", " 5 RMarkdown 5.1 Objetivos En este capítulo veremos: RMarkdown. Introducción a las funciones básicas incluidas en RStudio Como usar las páginas de ayuda. 5.2 Introducción Ahora que ya conoce un poco de la sintaxis básica de R, podemos comenzar a aprender sobre RMarkdown. La experiencia nos dice que te vas a volver loco haciendo los análsis o modelos en los cuales trabajes y vas a fallar en generar un flujo de trabajo reproducible. Peor aún, si tratas de desarrollar código directamente en la consola de R. RMarkdown es realmente clave para la investigación colaborativa, es por esto que vamos a comenzar rapidamente a aprender como usarlo y lo seguiremos uasndo durante el resto del curso. Un archivo de RMarkdown nos va a ayudar a tejer un texto markdown con fragmentos de código de R que es evaluado y cuyas salidas, como tablas y gráficos, son incluidas en el documento final. Para abrir un nuevo documento de RMarkdown siga los siguiente pasos: File -&gt; New File -&gt; RMarkdown… -&gt; Document of output format HTML, OK. Figure 5.1: Captura de pantalla de la interfase para la creación de un proyecto nuevo de RStudio. Le puede dar un título como “Mi Proyecto”. Luego clic en OK. OK, primero que todo: Al abrir el archivo, vamos a ver un 4° panel de la consola de RStudio, este panel es un editor de texto que nos permite abrir varios archivos en un único panel. Ahora démosle una mirada a este archivo que acabamos de crear - a primera vista se puede ver que no está en blanco; hay un texto inicial que se entrega por defecto. Hay algunas cosas que podemos identificar en el texto: Está en inglés (no se preocupe, ¡lo vamos a reescribir!) Hay secciones en con texto con el fondo blando y el código R está en secciones plomas (por defecto, estos colores del fondo se pueden cambiar). Figure 5.2: Imagen con el código fuente de un archivo RMarkdown. Lo primero que vamos a hacer es generar el código HTML (Knit HTML) haciendo clic en la pelota de lana azul en la parte superior del panel con el archivo RMarkdown. Cuando haga clic por primera vez en este botón, RStudio pedirá que guarde el archivo. Cree un nuevo directorio en algún lugar que le sea fácil encontrarlo posteriormente (por ejemplo Escritorio o Mis Documentos), dele un nombre que tenga sentido y le permita recordarlo después (ej: clase_rmarkdown). Figure 5.3: Imagen con el código fuente y pagina resultante de un archivo RMarkdown. ¿Que cosas puede notar entre al comparar los dos archivos? Las secciones de código R plomas están rodeadas de 3 tics y {r LABEL}. Estas secciones son evaluadas por R, generando una salida de texto en el caso de summary(cars) y de un gráfico en el caso de plot(pressure). Note como el código plot(pressure) no se muestra en la salida HTML porque la sección de código R tiene la opción echo=FALSE. Algunos otros detalles… Este archivo de RMarkdown tiene 2 lenguajes incluidos: R y Markdown. Aun no sabemos mucho de R, pero ya puede ver que estamos tomando el resumen de los datos llamados ‘cars’ y luego los graficamos. Hay mucho más para aprender sobre R y vamos a trabajar eso en las próximas clases. El segundo lenguaje que incluye el archivo es Markdown. Este es un lenguaje que para dar formato a texto plano y tiene aproximadamente 15 reglas para conocer. Vea la siguiente sintaxis: Títulos: son procesados en múltiples niveles con: #, ## Negrita: **palabra** Hay muchas tablas de consejos cheatsheets que te puede utilizar para obtener ayuda, una de esas está incluida en RStudio: para abrirla vaya a Help &gt; Markdown Quick Reference Importante: El símbolo de gato, número o para los milenials hashtag # tiene un significado diferente al que reconoce R cuando es usado en Markdown: en R, un gato indica que es un comentario y no será evaluado. Se pueden usar tantos como se quiera: # es equivalente a ######. Es sólo una cuestión de estilos. en Markdown, un gato indica el nivel del título. Y cuantos use tienen un efecto: # es un “título nivel 1”, lo que significa que es la fuente de mayor tamaño y que está al tope de la jerarquía. ### es un título nivel 3 y se muestra anidado bajo el título # y ##. Más sobre esto en: http://rmarkdown.rstudio.com/ 5.2.1 Actividad En Markdown, escriba un texto en cursiva (Itálica) y haga una lista numerada. Luego agregue algunos subtítulos. Use la Referencia de Uso Rápido de Markdown (en barra del menú: Help &gt; Markdown Quick Reference). Haga clic en Knit para general el archivo html. 5.2.2 Secciones del código OK. Ahora practiquemos con algunos comandos de R. Cree una nueva sección en en su RMarkdown siguiendo alguno de estos pasos: Clic “Insert &gt; R” en la parte superior del panel de edición. Escriba a mano ```{r} ``` Si no ha borrado las secciones por defecto que venían con el archivo, editelas! Ahora escribamos un poco de código R. x &lt;- 4*3 x Note que al apretar la tecla Enter el comando no se ejecuta; recuerde que esto es sólo un archivo de texto. Para ejecutar las secciones de código R (secciones en plomo) se deben enviar a la consola. ¿Cómo se hace eso? Hay varias formas de hacerlo: Copiar y pegar los comandos en la consola. Seleccionar la línea (o poner el curso en ella) y hacer clic en ‘Run’. Esto está disponible desde: la barra arriba del archivo (flecha verde). la barra menú: Code &gt; Run Selected Line(s). combinación de teclas: control-enter en Windows o command-enter en macOS. Clic en la flecha verde en el lado superior derecho de su sección de código. 5.2.3 Actividad Agregue otros comandos a su archivo. Ejecútelos de las tres formas indicadas más arriba. Finalmente, guarde su archivo RMarkdown. 5.3 Funciones de R Hasta ahora hemos aprendido la sintaxis básica y conceptos de programación en R, como navegar en RStudio y RMarkdown, pero no hemos hecho nada complicado o interesante aún. Aquí es donde las funciones de R son útiles. Una función es una forma de agrupar una serie de comandos para desarrollar una tarea en una forma reusable. Cuando una función es ejecutada, se produce un valor de salida. Nosotros generalmente decimos que “llamamos” una función cuando la ejecutamos. Lo interesante sobre las funciones es que pueden ser creadas por los usuarios y guardadas como un objeto usando el operador de asignación (‘&lt;-’), de esta forma es posible escribir una función para lo que sea que necesitemos. Tenga en cuenta que R tiene una colección gigantesca de funciones pre-existentes, las que además son expandibles con paquetes o librerías. Para comenzar, vamos a usar algunas funciones de R básicas ya incluidas. Todas las funciones se llaman usando la misma sintaxis: nombre de la función seguido de un paréntesis donde se entrega lo que necesite la función para funcionar. Las piezas de información que la función necesita para hacer su trabajo se conocen como argumentos. De esta forma, la sintaxis para usar una función se ve así: valor_resultante &lt;- nombre_de_función(argumento1 = valor1, argumento2 = valor2, ...). 5.3.1 Ejemplo simple Para tomar un ejemplo muy simple, vamos a utilizar una función que calcula el promedio, mean(). Como se puede imaginar, esta función calcula el promedio de los números entregados como argumentos. Creemos un vector con pesos: peso_kg &lt;- c(55, 25, 12) y ahora usemos la función mean para calcular el peso promedio. mean(peso_kg) ## [1] 30.66667 5.4 Páginas de ayuda 5.4.1 Obteniendo ayuda ¿Qué pasa ahora si sabe cuál es la función que necesita pero no cómo funciona? Afortunadamente RStudio entrega una forma muy fácil para acceder a las páginas de documentación y ayuda. Para acceder a la ayuda para la función mean, entre el siguiente comando en la consola: ?mean Esto abrirá el panel de ayuda en la sección inferior derecha de RStudio. Las páginas de ayuda están dividas en secciones, la documentación está en inglés: Description: Se entrega una descripción extendida de lo que hace la función. Usage: Los argumentos de la función y sus valores por defecto. Arguments: Una explicación de los datos que cada argumento espera. Details: Detalle que sean relevantes de conocer. Value: Los resultados devuelve la función. See Also: Otras funciones que podrían resultar útiles en este contexto. Examples: Algunos ejemplos de como usar la función. 5.4.2 Actividad Ejercicio: Hable con su(s) compañero(s) y dele una mirada a las ayudas de algunas funciones que usted espera que existan. Aquí les dejo algunas ideas: ?getwd(), ?plot(), min(), max(), ?log(). También existe ayuda para cuando usted no está seguro del nombre de la función, en esos casos solo es necesaroio usar doble símbolo de pregunta: ??install No todas las funciones tienen (o requieren) argumentos: date() ## [1] &quot;Tue Nov 5 15:55:09 2019&quot; 5.5 Leyendo un archivo de datos a R Hasta ahora hemos aprendido como asignar valores a objetos de R y lo que es una función, pero no hemos hecho nada aún con datos reales. Ahora vamos a introducir la función read.csv, que nos permite cargar a R datos reales desde un archivo CSV. Esta función se usa generalmente en las primeras líneas del código que escribamos. Ya que esta será nuestra primera vez usando esta función, primero leeremos la página de ayuda de read.csv. La ayuda tiene mucha información, mostrando que la función acepta muchos argumentos, sin embargo el primero de ellos es el más importante - tenemos que decirle que archivo es el que va a leer. 5.5.1 Descargue un archivo desde el Arctic Data Center Navegue al set de datos de Craig Tweedie Tweedie (2009) que está publicado en el Arctic Data Center y descargue el primer archivo csv llamado “BGchem2008data.csv”. Mueva este archivo desde su carpeta de Descargas a un directorio de fácil acceso. Yo recomiendo crear un directorio llamado datos en el directorio que creó anteriormente para las otras actividades de esta clase. Ahora tenemos que indicrle a la función read.csv como encontrar el archivo que queremos leer. Para esto se usa el argumento file (archivo) que se puede ver en la sección usage (uso) de la página de ayuda. En RMarkdown, se pueden usar path absolutos (que comienzan con su directorio ~/) o path relativos, que son relativos a la ubicación del archivo RMarkdown. RStudio y RMarkdown tiene la capacidad de autocompletar cuando se usan paths relativos, por lo que usaremos ese sistema. Asumiendo que ya movió el archivo a el directorio dentro de la carpeta archivos_clase_R llamada datos, su función read.csv puede ser llamada de la siguiente forma: bg_chem &lt;- read.csv(&quot;datos/5.1_BGchem2008data.csv&quot;) ## El nombre fue cambiado para hacer referencia que el archivo csv se usa en el capítulo 5. Ahora debería tener un objeto en R llamado bg_chem de la clase data.frame en su ambiente de trabajo. Verifique data.frame existe y contiene los datos. Note que en las páginas de ayuda hay una gran cantidad de argumentos que no fueron necesarios de utilizar. Algunos argumento en las llamadas a funciones son opcionales y algunos otros son requeridos. Los argumentos opcionales son mostrados en la sección de uso como un par nombre = valor, donde se muestra el valor que usa esa opción por defecto. Si usted no especifica el valor para la oción en particular, la función asume el valor por defecto (ejemplo: header = TRUE para read.csv). Los argumentos requeridos sólo muestran el nombre del argumento, sin un valor asociado. Fíjese que el único argumento requerido para read.csv es file. Siempre se puede especificar un argumento de la forma nombre = valor. Pero si no lo hace, R intentará identificarlos basado en el orden en que fueron entregados. De esta forma, en el comando de más arriba, se asume que queremos file = &quot;data/5.1_BGchem2008data.csv&quot;, ya que file es el primer argumento. Si queremos agregar algún otro argumento, por ejemplo stringsAsFactors, vamos a necesitar especificarlos usando nombre = valor, ya que el segundo argumento es header. Para las funciones que llamo comúnmente, uso esto sólo para los primeros 2 argumentos, para los que están en la 3a posición o más alla siempre uso el par nombre = valor. Muchos usuarios de R (incluyéndome) sobrescriben el argumento por defecto de stringsAsFactors usando la siguiente llamada: bg_chem &lt;- read.csv(&quot;data/5.1_BGchem2008data.csv&quot;, stringsAsFactors = FALSE) Esto muy útil, ya que de otra forma las columnas que contiene datos tipo strings son transformados a factores, pudiendo generar esto problemas y confusiones. 5.6 Usando data.frames Un data.frame en R es una estructura de datos de dos dimensiones, es similar a como se comporta una hoja de cálculos. Un data.frame es una colección de filas y columnas de datos, donde cada columna tiene un nombre y representa una variable, siendo cada fila a una medición de esa variable. De esta forma, cuando ejecutamos read.csv, el objeto bg_chem fue creado como un objeto tipo data.frame. Hay muchas formas para explorar un data.frame en R y RStudio. A continuación mostramos algunos: Clic en la palabra bg_chem en el panel Environment. Clic en la flecha junto a bg_chem en el panel de Environment Ejecute head(bg_chem) en la consola. Ejecute View(bg_chem) en la consola. Usualmente las funciones se ejecutan en columnas individuales de un data.frame. Para llamar a una columna específica se usa el operador $. Por ejemplo, digamos que se quiere mirar las primeras filas sólo de la columna Date. Para esto se debe ejecutar en la consola: head(bg_chem$Date) ## [1] &quot;2008-03-21&quot; &quot;2008-03-21&quot; &quot;2008-03-21&quot; &quot;2008-03-21&quot; &quot;2008-03-21&quot; ## [6] &quot;2008-03-22&quot; ¿Cómo se puede calcular la temperatura promedio de las muestras tomadas por el CTD? mean(bg_chem$CTD_Temperature) ## [1] -0.9646915 O si quisiéramos guardar este promedio como una variable para ser utilizada después: temp_promedio &lt;- mean(bg_chem$CTD_Temperature) También es posible crear algunos gráficos simples utilizando este operador ($). plot(bg_chem$CTD_Depth, bg_chem$CTD_Temperature) En R existen muchas herramientas y funciones más avanzadas para crear mejores gráficos (incluso con una sintaxis más simple). Veremos algunas de ellas en capitulos posteriores. 5.6.1 Actividad Ejercicio: Tome algunos minutos en explorar este set de datos. Pruebe algunas funciones en las columnas utilizando el operador $ para seleccionar una columna única. Experimente haciendo gráficos y generando resúmenes de los datos. 5.7 Solución de problemas 5.7.1 Mi RMarkdown no genera (knit) el PDF Si se obtiene un error cuando se trata de generrl el PDF, donde dice que su computador no tiene la instalación de LaTeX, existen dos posibles problemas: Su computador no tiene LaTeX instalado. Su computador si tiene LaTeX instalado, pero RStudio no lo puede encontrar (no está definida la ruta o path). Si usted ya usa LaTeX (para escribir papers por ejemplo), seguro que su problema esté en la segunda categoría. Arreglar esto sólo requiere redireccionar RStudio a donde este instalado LaTeX, pero esto no lo explicaremos acá. Si su problema es que no tiene instalado LaTeX y está seguro que no lo tiene! puede usar el paquete de R tinytex, este se instala muy fácilmente y es reconocido automáticamente por RStudio. Para hacer esto sólo necesita tener derechos de administrador del computador. Para instalar tinytex ejecute en la consola: install.packages(&quot;tinytex&quot;) tinytex::install_tinytex() 5.7.2 Acabo de ejecutar un comando pera no pasa nada Esto puede ocurrir porque no completó el comando: ¿Se muestra un pequeño signo + en su consola? R le esta diciendo que está esperando a que termine de entregar los comandos. En el ejemplo de más abajo falta cerrar el paréntesis. &gt; x &lt;- seq(1, 10 + Se puede simplemente cerrar el paréntesis y apretar enter, o esc dos veces, lo que va a cancelar cancelar la ejecución del comando. 5.7.3 R dice que mi objeto no puede ser encontrado Este error es muy común en usuarios nuevos: Error in mean(myobject) : object 'myobject' not found Esto significa que el objeto llamado myobject no existe en el ambiente de trabajo. Las razones más comunes para este error son: Error de tipeo: asegúrese que el nombre de su objeto esta bien escrito, R hace diferencias entre mayúsculas y minúsculas. Debe estar escrito exactamente como fue creado. No fue asignado a una variable: note que los objetos sólo son guardados en el ambiente de trabajo si fueron asignado con el operador de asignación, ej: myobject &lt;- read.csv(...). No ejecute la linea en RMarkdown: recuerde que escribir una línea de código en RMarkdown no es lo mismo que escribirla en la consola, usted tiene que ejecutar la línea de código usando control + enter, ejecutando la sección de código o por alguna de las otras formas que fueron descritas en la sección 5.2.2 de este mismo capítulo. 5.8 Análisis literal RMarkdown es una excelente forma de generar análisis literales y flujos de trabajo reproducibles. Aquí hay un ejemplo en inglés de un flujo de trabajo real escrito utilizando RMarkdown. Referencias "],
["control-de-versiones-con-git-y-github.html", "6 Control de versiones con git y GitHub 6.1 Objetivos 6.2 El problema con los nombres de archivo 6.3 Control de versiones y colaboración usando Git and GitHub 6.4 Veamos un repositorio de GitHub 6.5 El ciclo de vida de Git 6.6 Cree un repositorio remoto en GitHub 6.7 Trabajando localmente con Git en RStudio 6.8 Sobre (buenos) mensajes de confirmación (commit) 6.9 Flujos de trabajo colaborativos y libres de conflictos (relacionados con Git) 6.10 Actividad 6.11 Tópicos avanzados", " 6 Control de versiones con git y GitHub 6.1 Objetivos En este capítulo veremos: ¿Por qué git es útil para análisis reproducibles? ¿Cómo usar git para registrar los cambios que se hacen en el tiempo? ¿Cómo usar GitHub para colaborar? ¿Cómo estructurar los “commits” para que los cambios sean claros para otros? ¿Cómo escribir mensajes de “commits” que sean efectivos? 6.2 El problema con los nombres de archivo Figure 6.1: El dilema de usar nombres como descriptor de versiones. Cada archivo en un proceso científico sufre de cambios. Los manuscritos son editados. Las figuras son revisadas. Los códigos se corrigen cuando se encuentran problemas. Los archivos de datos se combinan, los errores son corregidos, se dividen y combinan nuevamente. En el curso de un análisis simple, uno puede esperar miles de cambios en los archivos. Y aún así, todo lo que usamos para identificas este sinnúmero de cambios son los simples nombres de archivos (fig. 6.1). Teniendo esto en consideración, es lógico pensar que debe existir una forma mejor… Y si la hay, se conoce como Control de Versiones. Un sistema de control de versiones ayuda a seguir lso cambios que se realizan a nuestros archivos, sin el desastre que resulta de utilizar sólo el nombre de los archivos. En los sistemas de control de versiones como git, se registra no sólo el nombre del archivo, si no que además su contenido, de esta forma, cuando el contenido cambia, se puede identificar que partes estaban y donde. El registro además contiene la relaciones entre las versiones, de esta forma se tiene un historial de todos los cambios deribados de las cada una de las versiones y es fácil dibujar un gráfico que muestre los cambios que ha sufrido un archivo, con sus versiones previas y aquellas derivadas (Fig. 6.2) Figure 6.2: Evolución de las versiones de un archivo. Los sistemas de control de versiones asignan un identificador a cada versión de cada archivo, manteniendo un registro de como están relacionados entre ellos. Además, estos sistemas permiten generar ramas laterales a una versión, la que puede ser fusionada de regreso a la tronco principal. Es posible además tener múltiples copias en múltiples computadores como respaldos y para trabajar colaborativamente. Finalmente, se pueden incluir etiquetas (tags) a versiones particulares, de esta forma es fácil retornar la versión que tenían los archivos cuando fueron etiquetados. Esto es particulamente útil para identificar una versión exacta de los datos, código y texto, por ejemplo, de un manuscrito que fue enviado para ser publicado, este puede ser el caso de la etiqueda R2 en la figura 6.2. 6.3 Control de versiones y colaboración usando Git and GitHub Es importante hacer la distinción entre git y GitHub. git: Software para el control de versiones que monitorea los archivos de un directorio (repositorio). git crea el historial de versiones del repositorio. GitHub: Sitio web que permite a los usuarios almacenar sus repositorios git y compartirlos con otros usuarios. Figure 6.3: Diferencia entre git y GitHub. 6.4 Veamos un repositorio de GitHub La captura de pantalla en la figura 6.4 muestra una copia de un repositorio almacenado en GitHub, con el listado de archivos y directorios, indicando cuando fueron modificados, incluyendo información acerca de quien hizo los cambios y una pequeña descripción de los cambios realizados. Figure 6.4: Captura de pantalla de un repositorio en GitHub. Si nos metemos en los “commits” del repositorio (fig. 6.5), podemos ver la historia de los cambios que se le han realizado. Por ejemplo, se ve que kellijohnson y seananderson hicieron algunos cambios durante junio y julio: Figure 6.5: Captura de pantalla de los Commits de un repositorio en GitHub. Si entramos ahora a ver los cambios realizados el 13 de julio (fig. 6.6), podemos saber exactamente cuales fueron los cambios realizados a cada archivo: Figure 6.6: Captura de pantalla donde se presentan las diferencias entre dos versiones alojadas en un repositorio de GitHub. Monitorear estas modificaciones, como se relacionan a cada una de las versiones de un software en particular y a los archivos es exactamente para lo que fueron diseñados git y GitHub. Vamos a mostrar como estos sistemas pueden ser realmente efectivos para monitorear las versiones de códigos científicos, figuras y manuscritos y de esta forma tener flujos de trabajo reproducibles. 6.5 El ciclo de vida de Git Como usuario de git usted tiene que entender algunos conceptos básicos asociados a los sets de cambios con versiones y como estos son almacenados y se mueven a través del repositorio. Cualquier repositorio de git puede ser clonado, de esta forma existe en forma local y remota. Pero cada uno de estos repositorios clonados son una copia simple de todos los archivos y del historial de los cambios que se han realizado, lo que son almacenados en un forma repositio git particular. Para nuestros propósitos, tenemos que considerar un repositorio de git simplemente como un directorio que contiene adicionalmente un set de metadatos relacionado las versiones. En un directorio local donde git fue habilitado, el directorio contiene la versión actual de todos los archivos del repositorio. Estos archivos de trabajo están unidos a un directorio escondido que contiene el ‘Repositorio local’, el que a su vez contiene todos los otros cambios que se han realizado a los archivos y los metadatos sobre las versiones. De esta forma, cuando se está usando git para trabajar con archivos, se pueden usar los comandos de git para indicar específicamente que cambios a los archivos de trabajo deben ser definidos para las versiones (usando el comando git add) y cuando grabar estos cambios como una versión en el repositorio local (usando el comando git commit). Los demás conceptos se relacionan a la sincronización de los cambios en el repositorio local a un repositorio remoto. El comando git push se usar para enviar los cambios realizados en forma local a un repositorio remoto (posiblemente en GitHub) y el comando git pull es usado para traer los cambios del repositorio remoto y unirlos al repositorio local. Figure 6.7: Diagrama de flujo del ciclo de vida de git. git clone: Copia todo el repositorio remoto a uno local. git add (stage): Notifica a git de monitorear un set particular de cambios. git commit: Almacena los cambios realizados como una versión. git pull: Combina los cambios de un repositorio remoto a nuestro repositorio local. git push: Copia los cambios de nuestro repositorio local al repositorio remoto. git status: Determina el estado de los archivos en el repositorio local. git log: Imprime el historial de cambios en el repositorio. Estos siete comandos son la mayoría de los comando que va a necesitar para utilizar git en forma exitosa. Pero todo esto es demasiado abstracto, mejor exploremos estos conceptos utilizando ejemplos reales. 6.6 Cree un repositorio remoto en GitHub Empecemos creando un repositorio en GitHub, luego editaremos algunos archivos. Ingrese al sitio GitHub. Clic en el botón de repositorio nuevo (New repository). Nómbrelo como sasap-test. Cree un archivo README.md. Defina la licencia a Apache 2.0. Figure 6.8: Captura de pantalla de la creación de un repositorio nuevo en GitHub. ¡Usted acaba de crear su primer repositorio! Este repositorio fue creado con un par de archivos que GitHub hace por usted, son los archivos README.md, LICENSE y .gitignore. Figure 6.9: Captura de pantalla con el repositorio recién creado llamado sasap-test. Para hacer cambios menores a archivos de texto se puede utilizar la interfase web de GitHub. Navegue al archivo README.md en el listado de archivos y habilite la edición haciendo clic en el icono del lápiz. Este es un archivo normal con el formado Markdown, ahora se puede editar, agregando o removiendo texto. Cuando haya terminado, incluya un mensaje de commit y luego haga clic en el botón Commit changes. Figure 6.10: Captura de pantalla con la interfase web de GitHub para la edición de documentos de texto. Figure 6.11: Captura de pantalla con la interfase web de GitHub para la confirmar de los cambios realizados al documento de texto (commit changes). Felicitaciones, ahora usted acaba de confirmar (commit) los cambios, ahora es el autor de la primera versión de este archivo. Si navega de regreso a la página del repositorio GitHub, puede ver la lista de los cambios confirmados (commits) ahí, así como la visualización del documento generado a partir del archivo README.md. Figure 6.12: Captura de pantalla con la interfase web los cambios corfimados (commits) y de la visualización de la página README.md. Expliquemos algunas cosas sobre esta ventana. Representa una vista del repositorio que acaba de crear, hasta ahora mostrando todos sus archivos. Para cada archivo, muestra la fecha de la última modificación y el mensaje asociado al commit que se utilizó para describir los cambios realizados. Esta es la razón por qué es tan importante escribir buenos mensajes, que contengan información relevante cuando se hace el commit. Además, el título azul sobre el listado de archivos muestra el commit más reciente, con su mensaje asociado y su identificados SHA. Ese identificador SHA es la clave para el set de versiones. Si hace clic en el identificador SHA (810f314), va a mostrar los cambios que se hicieron en ese commit en particular. En la siguiente sección vamos a usar el URL de GitHub del repositorio que acaba de crear y lo usaremos plara clonarlo (clone) a un repositorio en nuestra máquina local y así editar los archivos con RStudio. Para eso, primero tenemos que copiar el URL de GitHub, que representa la dirección del repositorio: Figure 6.13: Captura de pantalla para clonar un repositorio GitHub. 6.7 Trabajando localmente con Git en RStudio RStudio incluye soporte para Git como sistema de control de versiones, pero esto sólo ocurre si estamos trabajando en un Proyecto de RStudio (RStudio project folder). En esta sección vamos a clonar el repositorio que se creó en GitHub y lo vamos a dejar un repositorio local de un proyecto de RStudio. Esto es lo que vamos a hacer: Crear un proyecto nuevo. Inspeccionar el panel Git y el historial de versiones. Confirmar una modificación (commit) al archivo README.md. Commit las modificaciones que hicieron en RStudio. Inspeccionar el historial de versiones. Crear y commit un archivo Rmd. Enviar (Push) estos cambios a GitHub. Ver el historial de cambios en GitHub. 6.7.1 Crear nuevo Proyecto (Create a New Project) Comience creando un New Project… en RStudio, seleccione la opción Version Control y pegue el URL de GitHub que copió en el espacio para repositorio remoto (Repository URL). Si bien usted puede darle el nombre que quiera al repositorio local, se usa típicamente el mismo nombre que el que se tiene en GitHub, de esta forma se mantiene un grado de correspondencia. Usted puede elegir cualquier directorio para su copia local, en mi caso use el directorio development (fig. 6.14). Figure 6.14: Captura de pantalla para la creasción de un proyecto de RStudio clonando un repositorio remoto. Un vez que haga clic en Create Project (crear proyecto), una nueva página de RStudio se abrirá con todos los archivos copiados localmente desde el repositorio remoto. Dependiendo de como esté configurada la versión de RStudio, la posición y tamaño de los paneles puede cambiar, pero generalmente todos van a estar presentes, incluyendo los paneles Git y el listado de archivos (Files) que fueron creados en el repositorio remoto. Figure 6.15: Captura de pantalla de la interfase del projecto de RStudio con el clon local de repositorio. En la figura 6.15 puede ver que apareció un archivo llamado sasap-test.Rproj y que están los otros 3 archivos que se crearon con el repositorio remoto de GitHub (.gitignore, LICENSE y README.md). En el panel Git en RStudio se pueden ver 2 archivos. Este es el panel de estatus donde se se muestran todos los archivos del repositorio en los cuales se han realizado modificaciones. En este caso, el archivo .gitignore se muestra con una M que significa Modificado y sasap-test.Rproj con un ? ? para indicar que este archivo no está siendo monitoreado. Esto significa que git no tiene registro de ninguna version para este archivo y que no sabe nada acerca de el. A medida que usted vaya tomando decisiones sobre el control de versiones en RStudio, estos iconos van a ir cambiando para reflejar el estatus de la versión actual de cada uno de los archivos. 6.7.2 Inspeccionar el historial (history) A continuación vamos a hacer clic en el botón History (historial, es el reloj que aparece en la primera fila al interior del panel ed Git), esto despliega una ventana con el registro de los cambios que se han realizado y, en este caso, deben ser idénticos a lo que usted vio en GitHub. Al hacer clic en cada fila del historial, podrá ir viendo exactamente que fue agregado y cambiado en cada uno de los commits en este repositorio. Figure 6.16: Historial de los cambios realizados en el repositorio local. 6.7.3 Confirme cambios haciendo clic en commit al archivo README.md (Commit a README.md change) Ahora hagamos algunos cambios al archivo README.md en RStudio. Agregue una sección nueva con un block de markdown como este: ## Git desde RStudio Desde la interfase de RStudio, es posible hacer las mismas acciones con el sistema de versiones que se hicieron en GitHub y mucho más. Además en RStudio se tienen las ventajas propias de programar en un IDE con completación de comandos y otras características que hacen nuestro trabajo más fácil. - Agregar archivos al control de versiones - Ccommit cambios - Push commits a GitHub Una vez que los haya guardado, podrá ver en forma inmediata el archivo README.md en el panel Git (fig. 6.17), marcado con una M de modificación. Ahora usted puede seleccionar este archivo en el panel de Git y hacer clic en Diff para ver los cambios (comparando las diferencias) que guardó (note que estos cambios no se han confirmado (commit) aun a su repositorio local). Figure 6.17: Panel de estado de los cambios en los archivos. En la figura 6.18 se muestra como se ven los cambios comparados con el archivo original. La líneas nuevas se destacan en color verde y en rojo las que fueron eliminadas. Figure 6.18: Ventana que presenta las diferencias entre la versión almacenada en el repositorio y los últimos cambios realizados. 6.7.4 Commit los cambios hechos en Rstudio Para confirmar los cambios que se acaban de hacer en el archivo README.md, selecciones la caja de selección Staged a lado del nombre del archivo, este le dice a Git cuales son los cambios que quiere sean incluidos en el commit, escriba un mensaje describiendo que cambios se hicieron y por qué y finalmente haga clic en boton Commit (fig. 6.19). Figure 6.19: Captura de pantalla con un mensaje describiendo la confirmación (commit) que se realizará. Note que algunos de los cambios en el repositorio, .gitignore y sasap-test.Rproj, aun no se han confirmado y no serán parte del commit. En otras palabras, aun existen cambios pendientes para ser registrados en el repositorio. Usted vará una notificación que indica (en inglés): Your branch is ahead of ‘origin/master’ by 1 commit. Lo que se traduce a: _Su rama esta más avanzadada que el ‘maestro/origen’ por una confirmación Esto significa que hemos commit 1 cambio en el repositorio local, pero que este no se está en el repositorio de origen (origin), no se ha hecho push, donde origen es el nombre que se usa típicamente para el repositorio en GitHub. Entonces, confirmemos los cambios pendientes, para esto seleccione la caja staged y luego escriba el mensaje describiendo el commit (fig. 6.20). Figure 6.20: Captura de pantalla con los archivos a confirmar sus cambios y el texto descriptivo de la confirmación. Cuando haya terminado no habrán mas cambios pendientes en el panel Git y el repositorio estará completamente limpio. 6.7.5 Inspeccionando el historial Fíjese que ahora el mensaje dice: Your branch is ahead of ‘origin/master’ by 2 commits. _Su rama esta más avanzadada que el ‘maestro/origen’ por 2 confirmación Estas 2 confirmaciones son las dos que acabamos de hacer y no se han empujado (push) aun a GitHub. Haciendo clic en el botón History (historial), podemos ver que hay un total de 4 commit en el repositorio local, mientras hay sólo 2 en GitHub (fig. 6.21). Figure 6.21: Captura de pantalla con 4 commits. 6.7.6 Enviar (Push) cambios a GitHub Ahora que se han hecho todos los cambios deseados en el repositorio local, usted puede empujar (push) los cambios a GitHub usando el botón Push. Se abrirá una ventana donde se pregunta por su usuario y password de GitHub, luego los cambios serán enviados. Esto dejará su repositorio local en un estado totalmente limpio y sincronizado con el repositorio remoto. Terminado esto, en el historial (en GitHub) se muestran todos los commits, incluyendo los 2 que fueron hechos en GitHub y los 2 que se hicieron en forma local con RStudio. Figure 6.22: Captura de pantalla con los 4 modificaciones confirmadas. Ahora puede ver que las etiquetas del repositorio local (HEAD) y del remoto (origin/HEAD) están apuntando a la misma versión en el historial. De esta forma, si miramos el historial de los commits en GitHub serán iguales a los que tenemos en forma local. Figure 6.23: Captura de pantalla con el historial de cambios en github. 6.8 Sobre (buenos) mensajes de confirmación (commit) Es claro que una buena documentación es crítica para hacer del historial de versiones significativo y útil. Es tentador saltarse la escritura del mensaje asociado al commit o escribir algo por defecto como ‘Actualización!’. Sin embargo es importante escribir mensajes que sean para entender en el futuro que se hizo y por qué. Ademas, los mensajes que se usan en commits son en general más fáciles de entender si usan una convención de verbos activos. Por ejemplo, se puede ver que los mensajes de commit en las capturas de pantallas comienzan siempre con un verbo en pasado (en inglés!) y que explican que fue lo que se cambió. Si bien muchos de los cambios que aquí se hicieron son simples y se explican por si mismos, para cambios más complejos, es mejor entregar un mensaje completo y auto-contenido. La convención, sin embargo, es tratar de usar mensajes cortos, con una sentencia breve, seguido de una explicación más detallada y racional para el cambio. Esto permite que el nivel de detalles sea legible en el registro de las versiones (version log). No puedo contar el número de veces que he visto los registro d e commits de hace 2, 3 o 10 años y agradecido el nivel de diligencia de los colaboradores que se tomaron el tiempo de describir el trabajo que se realizó. 6.9 Flujos de trabajo colaborativos y libres de conflictos (relacionados con Git) Hasta ahora nos hemos enfocado al uso de Git y GitHub para el uso personal, como ya se demostró esto es extremadamente útil. Sin embargo donde git y GitHua brilla es cuando se comparte un repositorio GitHub con colaboradores, de esta forma se pede trabajar en un código, análisis y modelos en forma colaborativa. Cuando se trabaja de esta manera con otros investigadores, es muy importante poner atención al estado del repositorio remoto para evitar potenciales conflictos al combinar el trabajo. Un merge conflict ocurre cuando dos colaboradores hacen 2 commits en forma separada donde se ha(n) cambiado(s) la(s) misma(s) línea(s) de código de un archivo. Cuando esto ocurre, git no puede combinar los cambios en forma automática y arroja un error preguntando como resolver el conflicto. Esto no es grave, no es necesario tenerle miedo a los merge conflicts ya que son muy fáciles resolver y aquí hay algunas guías geniales. de como hacerlo (por ahora sólo en inglés). Dicho esto, es siempre mejor evadir este tipo de conflictos, lo que se pueden minimizar siguiendo las siguientes sugerencias: Asegúrese de traer (pull down) todos los cambios antes de confirmarlos (commit). Asegurese que tiene los cambios más recientes. Pero puede ser que necesite arreglar su código si ocurren conflictos. Coordínese con con sus colaboradores con quien va a trabajar. Usted tiene que comunicarse para colaborar. 6.10 Actividad Use RStudio para agregar un nuevo archivo al repositorio sasap-test, desarrolle una estructura básica y guárdela. A continuación stage y commit el archivo en forma local y luego push it a GitHub. 6.11 Tópicos avanzados Hay mucho que no hemos visto en este tutorial. Existen tutoriales muy completos que cubren tópicos mas avanzados. Algunos de estos temas son: Usando git en la linea de comándos. Resolviendo conflictos. Branching y merging. Pull requests versus contribuciones directas por colaboradores. Usando .gitignore para proteger datos sensitivos. GitHub Issues y por que son útiles. y más, mucho más. Try Git es un tutorial interactivo muy bueno y completo. Software Carpentry Version Control with Git Codecademy Learn Git (some paid) "],
["cap7.html", "7 Modelamiento de datos y datos ordenados 7.1 Objetivos 7.2 Beneficios de los sistemas de datos relacionales 7.3 Organización de datos 7.4 Modelamiento de datos adecuado 7.5 Claves primarias y foráneas 7.6 Combinando datos 7.7 Guía simple para datos efectivos 7.8 Ejercicio de modelamiento de datos 7.9 Recursos relacionados", " 7 Modelamiento de datos y datos ordenados 7.1 Objetivos En este capítulo veremos: Conceptos básicos del modelamiento de datos relacionales y datos ordenados (tidy data). Como diseñar y crear tablas de datos efectivas. 7.2 Beneficios de los sistemas de datos relacionales Poderoso sistema de filtrado y búsqueda. Manejo de sets de datos grandes y complejos. Obliga a la integridad de los datos. Disminuye los errores producto de las actualizaciones redundantes. 7.3 Organización de datos Figure 7.1: Planilla excel infernal. ##3 Tablas múltiples Figure 7.2: Múltiples tablas en una misma planilla. Otro caso de un excel infernal. ##3 Observaciones inconsistentes Figure 7.3: Observaciones diferentes en una misma fila de la tabla. Otro caso de un excel infernal. 7.3.1 Inconsistencia en las variables Figure 7.4: Variables diferentes en la misma columna. 7.3.2 Estadísticas y sumas al margen Figure 7.5: Valores que pueden ser calculados partir de los datos de la tabla. Otra mala práctica. 7.4 Modelamiento de datos adecuado 7.4.1 Datos De-normalizados En la figura 7.6 se presenta una tabla donde existen diferentes entidades medidas o muestreadas que se combinaron en una misma fila. Figure 7.6: Valores obtenidos en diferentes entidades en la misma fila. En el ejemplo presentado en la figura 7.6, se puede ver como cada columna tiene información tanto de los sitios (site) donde se registraron las observaciones, así como de 2 individuos, aparentemente de diferentes especies, que fueron encontrados en el sitio. Estos son datos no estan normalizados. La gente se refiere comúnmente a esto como formato ancho o de mantel de cocina, porque las observaciones están repartidas a lo ancho de las columnas. Nótese que si encuentra una nueva especie en un muestreo, tendríamos que agregar una nueva columna en la tabla. Esto es muy difícil de analizar, entender y mantener. 7.4.2 Datos tabulares Observaciones. Una forma mucho más efectiva de modelado de datos es organizando las observaciones acerca de cada tipo de entidad en su propia tabla. Esto resulta en: tablas separadas para cada entidad medida. Cada fila representa una única observación de la entidad. Las observaciones (filas) son únicas. Esto es lo que se conoce como datos normalizados (tidy data). Variables. Además, en el caso de datos normalizados, podemos esperar que las variables estén organizada de tal forma que: Todos los valores en una columna representan lo mismo. Todas las columnas pertenecen a la misma entidad observada (ej. fila). Cada columna representa o una variable identificadora o una variable medida. En la figura 7.7 hay un ejemplo de datos normalizados, la primera tabla se refiere a la colección de datos sobre los individuos de varias especies y la segunda tabla son las observaciones que contienen las propiedades de los sitios donde las especies estaban presentes. Figure 7.7: Ejemplo de tablas con datos normalizados. 7.5 Claves primarias y foráneas Cuando se usan datos normalizados, es común usar identificadores únicos para hacer referencia a observaciones particulares, esto nos permite hacer uniones entre dos o más tablas. Los dos tipos de identificadores que se usan comúnmente con datos relacionales son: Clave primaria: Identificador único para cada una de las observaciones de la entidad, es uno por fila. Clave foránea: Hace referencia una clave primaria que está en otra tabla (referencia para unir). Por ejemplo, en la segunda tabla de la figura 7.8, la columna site es la clave primaria (primary key) de esa tabla. La puede identificar como tal porque es un identificador único para una observación realizada en un sitio y que corresponde a una fila de la tabla. En la primera tabla, sin embargo, la columna sitio (site) es una clave foránea (foreign key) que hace referencia a la clave primaria presente en la segunda tabla. Esta relación nos permite identificar que la primera medición de la altura (height) para la especie DAPU se realizó en el sitio con el nombre Taku. Figure 7.8: Explicación de la relación entre clave primaria y foranea entre dos tablas con datos normalizados. 7.5.1 Modelo de Relación-Entidad Un modelo de Relación-Entidad nos permite representar en forma compacta la estructura de las tablas en una base de datos relacional, incluyendo las claves primarias y foráneas de cada una de las tablas. Figure 7.9: Representación gráfica de una relación-entidad de dos tablas, incluyendo las claves con que se unen.. En el modelo presentado en la figura 7.9, se puede ver que cada sitio en la tabla SITES debe tener uno o más observaciones en la tabla PLOTOBS, donde cada PLOTOBS tiene un y solo un SITE. 7.6 Combinando datos Frecuentemente, los análisis de datos requieren que se combinen estas tablas que se manejan en forma separada. Esto se puede hacer de múltiples formas y estas uniones van a depender de como las tablas estén relacionadas (fig. 7.10). Cuando se conceptualizan las uniones, uno puede pensar en dos tablas, una a la izquierda (left) y otra a la derecha (right). La unión más común (generalmente usada) es cuando se combina un subgrupo de filas que tienen parejas en ambas tablas (a la izquierda y derecha): esto se conoce como INNER JOIN (unión interna). Existen otros tipos de uniones posibles. Un LEFT JOIN (unión a la izquierda), toma todas las filas de la tabla a la izquierda y las combina con los datos que se emparejan en la tabla a la derecha. Un RIGHT JOIN (unión a la derecha) es lo mismo, sólo que en este caso se mantienen todas las filas presentes en la tabla de la derecha y se agregan aquellas que tienen parejas en la izquierda. Finalmente, un FULL OUTER JOIN (unión total) incluye todas las filas en ambas tablas, esta unión es raramente de uso práctico. Figure 7.10: Las regiones en azul representan las filas que son incluidas en el resultado. Para un INNER join, las filas resultantes son todas las filas en A que tienen una pareja en B. 7.7 Guía simple para datos efectivos Diseñe la tabla para agrear filas, no columnas! Cada columna corresponde a un tipo de variable. Elimine la redundancia. Archive los datos sin corregir. Use encabezados. Use formatos que no sean privativos. Use nombres descriptivos. No incluya espacios. Borer et al. 2009. Some Simple Guidelines for Effective Data Management. Bulletin of the Ecological Society of America. White et al. 2013. Nine simple ways to make it easier to (re)use your data. Ideas in Ecology and Evolution 6. 7.8 Ejercicio de modelamiento de datos Forme grupos. Trabajaremos con datos correspondientes a una versión normalizada de datos con capturas comerciales de salmón entre 1878 y 1997 reportadas por Byerly (1999), de ADF&amp;G (Alaska Department of Fish and Game o Departamento de Pesca y Caza de Alaska). El set de datos y las referencias a la fuente original puede ser vista en el archivo de acceso público en: https://knb.ecoinformatics.org/#view/df35b.304.2. Este sitio incluye los metadatos que describen todo el set de datos, incluyendo la descripción de las columnas. Aquí esta la primera tabla de capturas (catch): Y aquí la tabla que define las regiones (region_defs): Dibuje un modelo RE para las tablas. Indique cuales son las claves primarias y foráneas. ¿Está la tabla catch en una forma normalizada? Si es así ¿Cuál es la entidad (única) que fue observada? Si no ¿Como reestructuraría los datos para que queden normalizados? Dibuje un nuevo diagrama RE mostrando esta estructura de datos re-diseñada Figure 7.11: Guí de nomenclatura para el direño de un modelo de Relación-Entidad (RE). 7.9 Recursos relacionados Borer et al. 2009. Some Simple Guidelines for Effective Data Management. Bulletin of the Ecological Society of America. White et al. 2013. Nine simple ways to make it easier to (re)use your data. Ideas in Ecology and Evolution 6. Software Carpentry SQL tutorial Tidy Data Referencias "],
["limpieza-y-manipulación-de-datos.html", "8 Limpieza y manipulación de datos 8.1 Objetivos 8.2 Introducción 8.3 Configuración (Setup) 8.4 Acerca del operador de pipe (tubo; %&gt;%) 8.5 Funciones 8.6 Resumen", " 8 Limpieza y manipulación de datos 8.1 Objetivos En este capítulo veremos: Que es la estrategia Divida-Aplique-Combine y como se utiliza La diferencia entre los formatos de tablas anchas vs. largas y como convertir de un formato al otro Como usar dplyr y tidyr para limpiar y manipular datos para análisis Como unir múltiples data.frame usando dplyr 8.2 Introducción Es muy raro que recibamos datos en un formato que nos permita trabajar o hacer los análisis, además es común que algunos paquetes de R requieran los datos en un formato, mientras otros paquetes los requieren en otro. Es por esto, que para hacer nuestro trabajo en forma eficiente, es necesario que podamos re-formatear los datos de acuerdo a las necesidades del trabajo a realizar. Los paquetes de R dplyr y tidyr entregan funciones muy completas, útiles y potentes para realizar estos cambios de formato. Los análisis toman muchas formas, pero generalmente se pueden clasificar en lo que se conoce como la estrategia Divida-Aplique-Combine (Split-Apply-Combine). Esta estrategia sigue un set de pasos típicos: Divida: Dividir los datos en grupos lógicos (ej. área, stock, año). Aplique: Cálcular las estadísticas resúmenes para cada grupo (ej. promedio del largo total por año). Combine: Combinar los grupos en una tabla única. Figure 8.1: Diagrama de la estragegia divida, aplique y combine. Como se muestra en la figura 8.1, la tabla original se dividió en grupos anuales (year) para calcular el largo promedio de cada grupo y posteriormente combinar en una tabla única que incluye los promedios anuales. dplyr permite hacer eso en forma muy simple. Asumiendo que nuestros datos de largo están cargados en un data.frame llamado length_data, esto se puede hacer de la siguiente forma: year length_cm 1991 5.673318 1991 3.081224 1991 4.592696 1992 4.381523 1992 5.597777 1992 4.900052 1992 4.139282 1992 5.422823 1992 5.905247 1992 5.098922 length_data %&gt;% group_by(year) %&gt;% summarise(mean_length_cm = mean(length_cm)) Es muy común también que se deba cambiar el formato de las tablas de datos (“reshape”). Veamos un ejemplo de una tabla en el formato, que de ahora en adelante llamaremos, “ancho”: site 1990 1991 … 1993 gold 100 118 … 112 lake 100 118 … 112 … … … … … dredge 100 118 … 112 Es muy probable que usted esté familiarizado con datos en este formato, donde los valores de las variables observadas están repartidos en más de una columna (en este caso, columnas para cada año). Otra forma de describir esto es que existe más de una medición por cada fila. Este formato funciona muy bien para la entrada de datos (en excel) y a veces para algunos análisis, pero se hace rápidamente inútil para usarlos en R. Por ejemplo, ¿cómo puede ajustar un modelo con el año como una variable predictora? en un mundo ideal deberíamos poder ejecutar la siguiente línea de código: lm(length ~ year) Esto no va a funcionar en una tabla con formado ancho ya que la función lm necesita length y year como columnas de la tabla para funcionar. Otra situación son los gráficos, por ejmeplo ¿Cómo podemos hacer un gráfico para cada año? Para esto es posible llamar la función plot una vez para cada año, sin embargo esto esto resulta tedioso, especialmente si hay muchos años en los datos, es difícil mantener el código y agregar más años al set de datos. El paquete tidyr tiene funciones que nos permiten cambiar entre el formato ancho y largo utilizando la función gather: site_data %&gt;% gather(year, length, -site) site year length gold 1990 101 lake 1990 104 dredge 1990 144 … … … dredge 1993 145 En esta clase vamos a aprender a usar las funciones más comunes de los paquetes dplyr y tidyr: dplyr mutate() group_by() summarise() select() filter() arrange() left_join() rename() tidyr gather() spread() extract() separate() 8.3 Configuración (Setup) Vamos a comenzar con las funciones más comunes del paquete dplyr. Para demostrar como se usan, vamos a trabajar con una versión de un set de datos ya pre-ordenado del Departamento de Pesca y Caza de Alaska (ADF&amp;G) que contiene los datos de capturas comerciales de 1878 a 1997 (Byerly (1999)). El set de datos y su referencia a la fuente original se puede encontrar en el siguiente archivo público: https://knb.ecoinformatics.org/#view/df35b.304.2. Primero, vamos a cargar los paquetes dplyr y tidyr: library(dplyr) library(tidyr) Ahora se leen los datos y les daremos una mirada: catch_original &lt;- read.csv(url(&quot;https://knb.ecoinformatics.org/knb/d1/mn/v2/object/df35b.302.1&quot;, method = &quot;libcurl&quot;), stringsAsFactors = FALSE) head(catch_original) ## Region Year Chinook Sockeye Coho Pink Chum All notesRegCode ## 1 SSE 1886 0 5 0 0 0 5 ## 2 SSE 1887 0 155 0 0 0 155 ## 3 SSE 1888 0 224 16 0 0 240 ## 4 SSE 1889 0 182 11 92 0 285 ## 5 SSE 1890 0 251 42 0 0 292 ## 6 SSE 1891 0 274 24 0 0 298 Nota: para descargar los datos, copié el URL desde el botón de descarga (Download) en https://knb.ecoinformatics.org/#view/df35b.304.2 Este dataset está relativamente limpio y es de fácil interpretación. Si bien estos datos están limpios, el formato de la tabla hace que sea difícil usarlos para alguno de los análisis que debemos realizar. Como primer paso tenemos que arreglar eso. 8.4 Acerca del operador de pipe (tubo; %&gt;%) Antes de comenzar a aprender sobre tidyr y dplyr es necesarios que se explique de que se trata el %&gt;%. Tanto el paquete tidyr como dplyr usa el operador %&gt;%. Este operador es una forma muy eficiente para encadenar operaciones. Esta “tubería” (como se le conoce en inglés) toma la salida de una operación anterior y la entrega como una entrada a la siguiente. Digamos que quiere filtrar usando la función filter unas filas y seleccionar usando select una columna de la misma tabla de datos. Para esto se puede usar df_filtered &lt;- filter(df, ...) df_selected &lt;- select(df_filtered, ...) Sin embargo, su código será más simple y eficiente (más rápido con set de datos grandes!) df_cleaned &lt;- df %&gt;% filter(...) %&gt;% select(...) Si usted piensa en el operador de asignación (&lt;-) como “recibe”, entonces el operador pipe se puede leer como “entonces”. De esta forma, el fragmento de código anterior se puede traducir como: El data.frame limpio recibe los datos originales, entonces realiza un filtro (de los datos originales) y entonces selecciona (sobre los datos filtrados). El beneficio de usar pipes es que no es necesario seguir el rastro (o de sobre-escribir) de sets de datos intermedios. El costo es que se hace un poco mas difícil de explicar el razonamiento de cada paso, especialmente cuando existen muchas operaciones encadenadas. Lo ideal es tener un balance entre escribir códigos eficientes (operaciones encadenadas) y que sean legibles e interpretables, para entender la lógica de que y por qué se hizo lo que se hizo. RStudio tiene una combinación de teclas para %&gt;% : Ctrl + Shift + M (Windows), Cmd + Shift + M (Mac). 8.5 Funciones 8.5.1 Seleccionar/remover columnas: select() El primer problema con los datos con los que vamos a trabajar son las columnas All y notesRegCode. Vamos a seleccionar sólo las columnas que necesitamos y las asignaremos a la variable llamada catch_data. catch_data &lt;- catch_original %&gt;% select(Region, Year, Chinook, Sockeye, Coho, Pink, Chum) head(catch_data) ## Region Year Chinook Sockeye Coho Pink Chum ## 1 SSE 1886 0 5 0 0 0 ## 2 SSE 1887 0 155 0 0 0 ## 3 SSE 1888 0 224 16 0 0 ## 4 SSE 1889 0 182 11 92 0 ## 5 SSE 1890 0 251 42 0 0 ## 6 SSE 1891 0 274 24 0 0 Esto está mucho mejor. select nos permite indicar las columnas que no queremos, para esto sólo tenemos que pasar los nombres de las columnas (sin comillas) con un signo menos (-): catch_data &lt;- catch_original %&gt;% select(-All, -notesRegCode) head(catch_data) ## Region Year Chinook Sockeye Coho Pink Chum ## 1 SSE 1886 0 5 0 0 0 ## 2 SSE 1887 0 155 0 0 0 ## 3 SSE 1888 0 224 16 0 0 ## 4 SSE 1889 0 182 11 92 0 ## 5 SSE 1890 0 251 42 0 0 ## 6 SSE 1891 0 274 24 0 0 8.5.2 Cambiar el formato: gather() y spread() El siguiente problema con los datos es que están en un formato ancho y que para trabajar los necesitamos en uno largo. gather() del paquete tidyr nos ayuda a hacer este cambio en el formato: catch_long &lt;- catch_data %&gt;% gather(species, catch, -Region, -Year) head(catch_long) ## Region Year species catch ## 1 SSE 1886 Chinook 0 ## 2 SSE 1887 Chinook 0 ## 3 SSE 1888 Chinook 0 ## 4 SSE 1889 Chinook 0 ## 5 SSE 1890 Chinook 0 ## 6 SSE 1891 Chinook 0 La sintaxis que usamos para gather() puede ser un poco confusa, así que la explicaremos con el diagrama rotulado que se presenta en la figura 8.2: Figure 8.2: Diagrama rotulado donde se explica cada uno de los inputs a la función gather. Los primeros dos argumentos de la función gather() son los nombres de las columnas nuevas que serán creadas y los otros argumentos con el símbolo - son las columnas que se deben mantener en el proceso. La función opuesta a gather() es spread(), funciona la misma forma declarativa: catch_wide &lt;- catch_long %&gt;% spread(species, catch) head(catch_wide) ## Region Year Chinook Chum Coho Pink Sockeye ## 1 ALU 1911 0 0 0 0 9 ## 2 ALU 1912 0 0 0 0 0 ## 3 ALU 1913 0 0 0 0 0 ## 4 ALU 1914 0 0 0 0 0 ## 5 ALU 1915 0 0 0 0 0 ## 6 ALU 1916 0 0 1 180 76 8.5.3 Renombrando columnas con rename() Si le da una mirada a los datos, va a notar que existen valores en la columna catch que son muy pequeños (se supone que son valores de capturas anuales). Si analizamos los metadata veremos que la columna catch está en miles de pescados, así que la vamos a convertir antes de seguir con los análisis. Primero cambiemos el nombre de catch a catch_thousands: catch_clean &lt;- catch_long %&gt;% rename(catch_thousands = catch) head(catch_clean) ## Region Year species catch_thousands ## 1 SSE 1886 Chinook 0 ## 2 SSE 1887 Chinook 0 ## 3 SSE 1888 Chinook 0 ## 4 SSE 1889 Chinook 0 ## 5 SSE 1890 Chinook 0 ## 6 SSE 1891 Chinook 0 8.5.4 Agregando columnas: mutate() Ahora vamos a crear una columna llamada catch con individuos como unidad (en vez de miles de pescados). Note que hemos agregado, a la expresión que creamos mas arriba, la llamada a la función mutate. Esto aprovecha el operador pipe agrupando un set de comandos, todos relacionados con el objetivo de limpiar el data.frame catch_long. catch_clean &lt;- catch_long %&gt;% rename(catch_thousands = catch) %&gt;% mutate(catch = catch_thousands * 1000) head(catch_clean) Aquí va a ver el siguiente mensaje: Error in mutate_impl(.data, dots) : Evaluation error: non-numeric argument to binary operator. Este mensaje de error es críptico – ¿Qué es lo que está diciendo? Este tipo de errores pueden ser difíciles de diagnosticar, lo que está sugiriendo es que la columna catch no es exactamente lo que estábamos esperando. ¿Cómo podemos ver esto? R le entrega una variedad de funciones que le permiten hacer resúmenes rápidos de una tabla de datos relativamente grande: summary(catch_clean) ## Region Year species catch_thousands ## Length:8540 Min. :1878 Length:8540 Length:8540 ## Class :character 1st Qu.:1922 Class :character Class :character ## Mode :character Median :1947 Mode :character Mode :character ## Mean :1946 ## 3rd Qu.:1972 ## Max. :1997 Actividad: ¿Qué otras formas (funciones) se podrían haber usado para identificar el problema? Vea que en la salida de más arriba la columna catch_thousands se ve como Class :character. Esto quiere decir que contiene caracteres de texto y no números, esto parece incorrecto ya que las capturas deberían ser números enteros (R muestra esto como enteros o integers en inglés). Vamos a convertir esta columna a enteros y veremos que sucede: catch_integers &lt;- as.integer(catch_clean$catch_thousands) ## Warning: NAs introduced by coercion Aquí se muestra el mensaje de error “NAs introduced by coercion” donde R dice que no fue posible convertir cada uno de los valores a enteros (integers) y que, para esos valores que no pudo convertir, pusa NA en su lugar. Este es común y lo podemos esperar cuando realicemos limpieza de datos, sin embargo es importante que tengamos las capacidades para manejar estas situaciones. Podemos encontrar cuales son los valores con NAs combinando las funciones is.na() y which(), y guardando el resultado en una variable, por ejemplo i. i &lt;- which(is.na(catch_integers)) i ## [1] 401 Se ve que existe sólo una fila con problemas, veamosla: catch_clean[i,] ## Region Year species catch_thousands ## 401 GSE 1955 Chinook I Bueno, esto es raro: El valor en catch_thousands es I lo que claramente no es un número. Resulta que este set de datos viene de un archivo PDF que fue convertido automáticamente a CSV (formato de texto separado por comas) y este valor I corresponde a un 1. Ahora procedemos a arreglarlo: catch_clean &lt;- catch_long %&gt;% rename(catch_thousands = catch) %&gt;% mutate(catch_thousands = ifelse(catch_thousands == &quot;I&quot;, 1, catch_thousands)) %&gt;% mutate(catch_thousands = as.integer(catch_thousands)) head(catch_clean) ## Region Year species catch_thousands ## 1 SSE 1886 Chinook 0 ## 2 SSE 1887 Chinook 0 ## 3 SSE 1888 Chinook 0 ## 4 SSE 1889 Chinook 0 ## 5 SSE 1890 Chinook 0 ## 6 SSE 1891 Chinook 0 Vea que en esta serie de comandos se hace una doble llamada a la función mutate(). Esto ocurre porque el proceso de mutate() es secuencial, los resultados de un mutate() estarán disponibles para el siguiente. Ahora realicemos la conversión nuevamente, agregando un nuevo llamado a la misma función. catch_clean &lt;- catch_long %&gt;% rename(catch_thousands = catch) %&gt;% mutate(catch_thousands = ifelse(catch_thousands == &quot;I&quot;, 1, catch_thousands)) %&gt;% mutate(catch_thousands = as.integer(catch_thousands)) %&gt;% mutate(catch = catch_thousands * 1000) head(catch_clean) ## Region Year species catch_thousands catch ## 1 SSE 1886 Chinook 0 0 ## 2 SSE 1887 Chinook 0 0 ## 3 SSE 1888 Chinook 0 0 ## 4 SSE 1889 Chinook 0 0 ## 5 SSE 1890 Chinook 0 0 ## 6 SSE 1891 Chinook 0 0 Ahora no se ve ningún mensaje de error y podemos eliminar la columna catch_thousands que ya no necesitamos: catch_clean &lt;- catch_long %&gt;% rename(catch_thousands = catch) %&gt;% mutate(catch_thousands = ifelse(catch_thousands == &quot;I&quot;, 1, catch_thousands)) %&gt;% mutate(catch_thousands = as.integer(catch_thousands)) %&gt;% mutate(catch = catch_thousands * 1000) %&gt;% select(-catch_thousands) head(catch_clean) ## Region Year species catch ## 1 SSE 1886 Chinook 0 ## 2 SSE 1887 Chinook 0 ## 3 SSE 1888 Chinook 0 ## 4 SSE 1889 Chinook 0 ## 5 SSE 1890 Chinook 0 ## 6 SSE 1891 Chinook 0 En este punto los datos estan limpios y ordenados para inicial el análisis. 8.5.5 group_by y summarise Como se dijo en la introducción del presente capítulo, dplyr nos deja utilizar la estrategia Divida-Aplique-Combine, que se ejemplifica con el uso de las funciones group_by() y summarise(): mean_region &lt;- catch_clean %&gt;% group_by(Region) %&gt;% summarise(mean(catch)) head(mean_region) ## # A tibble: 6 x 2 ## Region `mean(catch)` ## &lt;chr&gt; &lt;dbl&gt; ## 1 ALU 40384. ## 2 BER 16373. ## 3 BRB 2709796. ## 4 CHG 315487. ## 5 CKI 683571. ## 6 COP 179223. Actividad: Encuentre otra función para agrupar y calcular estadísticas para cada grupo. Ejercicio: Encuentre si es posible agrupar múltiples variables. Otro uso común de la función group_by() seguida de summarize() es para contar el número de filas en cada grupo. Para esto usamos la función n() del paquete dplyr. n_region &lt;- catch_clean %&gt;% group_by(Region) %&gt;% summarize(n = n()) head(n_region) ## # A tibble: 6 x 2 ## Region n ## &lt;chr&gt; &lt;int&gt; ## 1 ALU 435 ## 2 BER 510 ## 3 BRB 570 ## 4 CHG 550 ## 5 CKI 525 ## 6 COP 470 8.5.6 Filtrando columnas: filter() filter() es una función que se usa para filtrar las filas de un data.frame que cumplen con alguna condición. Es similar a la función subset() de R base. Vamos a nuestro data.frame original y filtremos con la función filter() algunos datos: SSE_catch &lt;- catch_clean %&gt;% filter(Region == &quot;SSE&quot;) head(SSE_catch) ## Region Year species catch ## 1 SSE 1886 Chinook 0 ## 2 SSE 1887 Chinook 0 ## 3 SSE 1888 Chinook 0 ## 4 SSE 1889 Chinook 0 ## 5 SSE 1890 Chinook 0 ## 6 SSE 1891 Chinook 0 Actividad: Filtre las capturas que sean mayores a 1 millón de salmones. Actividad: Filtre sólo los salmones Chinook en la Región SSE. 8.5.7 Ordenando sus datos: arrange() arrange() es la función que se usar para ordenar filas de un data.frame. En mi experiencia, arrange() se usa comúnmente en dos casos: Cuando se necesita calcular una suma acumulada (con cumsum()). Cuando se necesita mostrar una tabla (por ejemplo en un documento .Rmd) ordenada. Re-calculemos el promedio de captura por región y luego ordenemos la salida, usando arrange(), por captura promedio: mean_region &lt;- catch_clean %&gt;% group_by(Region) %&gt;% summarise(mean_catch = mean(catch)) %&gt;% arrange(mean_catch) head(mean_region) ## # A tibble: 6 x 2 ## Region mean_catch ## &lt;chr&gt; &lt;dbl&gt; ## 1 BER 16373. ## 2 KTZ 18836. ## 3 ALU 40384. ## 4 NRS 51503. ## 5 KSK 67642. ## 6 YUK 68646. La función arrange() ordena por defecto en orden creciente. Para invertir este orden se usa la función desc() en la columna que se quiera ordenar: mean_region &lt;- catch_clean %&gt;% group_by(Region) %&gt;% summarise(mean_catch = mean(catch)) %&gt;% arrange(desc(mean_catch)) head(mean_region) ## # A tibble: 6 x 2 ## Region mean_catch ## &lt;chr&gt; &lt;dbl&gt; ## 1 SSE 3184661. ## 2 BRB 2709796. ## 3 NSE 1825021. ## 4 KOD 1528350 ## 5 PWS 1419237. ## 6 SOP 1110942. 8.5.8 Joins en dplyr Ahora que ya somos expertos en manipular un data.frame único ¿Qué podemos hacer? La respuesta es obvia, manipular más de un data.frame. Si usted a utilizado bases de datos anteriormente, es probable que sea familiar con las funciones “join”. Estas funciones nos permiten unir, en forma inteligente, dos tablas para formar una sola, esto se hace utilizando alguna columna que tengan en común. Ya hemos hablado sobre joins en la sección sobre uniones de tablas [7.6] del capítulo [7]. Aquí vamos a ver como se hace dentro del entorno dplyr. El set de datos con el que hemos estado trabajando, https://knb.ecoinformatics.org/#view/df35b.304.2, contiene un segundo documento con datos en formato CSV que contiene las definiciones de los códigos para cada Region de Alaska. Esto es una forma muy común de almacenar información auxiliar sobre nuestro set de datos de interés (capturas) pero que, para fines analíticos, a menudo las queremos en el mismo data.frame. Join (unión), nos permite hacer esto fácilmente. Veamos que es lo que hará nuestra unión utilizando una versión simplificada de los datos: Figure 8.3: Uso de leftjoin para combinar dos tablas utilizando la columna Region como clave. Primero, leamos la tabla con la definición de los nombres de la regiones y seleccionemos sólo las columnas de interés. Note que he usado el operador %&gt;% para pasar los resultados de la función read.csv, creando de esta forma un fragmento de código que lee y selecciona los datos de interés. region_defs &lt;- read.csv(url(&quot;https://knb.ecoinformatics.org/knb/d1/mn/v2/object/df35b.303.1&quot;, method = &quot;libcurl&quot;), stringsAsFactors = FALSE) %&gt;% select(code, mgmtArea) head(region_defs) ## code mgmtArea ## 1 GSE Unallocated Southeast Alaska ## 2 NSE Northern Southeast Alaska ## 3 SSE Southern Southeast Alaska ## 4 YAK Yakutat ## 5 PWSmgmt Prince William Sound Management Area ## 6 BER Bering River Subarea Copper River Subarea Si examina la columna region_defs del data.frame, puede ver que los nombres de columnas no son iguales a las presentadas en la figura 8.3. Si los nombres de las columnas clave no son iguales, es posible definir implícitamente cuales son las columnas de la tabla a la derecha y a la izquierda que se deben usar, tal como se muestra en el código siguiente: catch_joined &lt;- left_join(catch_clean, region_defs, by = c(&quot;Region&quot; = &quot;code&quot;)) head(catch_joined) ## Region Year species catch mgmtArea ## 1 SSE 1886 Chinook 0 Southern Southeast Alaska ## 2 SSE 1887 Chinook 0 Southern Southeast Alaska ## 3 SSE 1888 Chinook 0 Southern Southeast Alaska ## 4 SSE 1889 Chinook 0 Southern Southeast Alaska ## 5 SSE 1890 Chinook 0 Southern Southeast Alaska ## 6 SSE 1891 Chinook 0 Southern Southeast Alaska Note que me he desviado de la sintaxis que usa los pipes (a pesar de que igualmente funciona aquí) porque prefiero ver los data.frames que estoy uniendo uno al lado del otro. Otra forma de hacer esta unión es cambiando los nombres de las columnas usando la función rename, de esta forma se puede cambiar el nombre de la columna code a Region el data.frame region_defs, y ejecutar el left_join de la siguiente forma: region_defs &lt;- region_defs %&gt;% rename(Region = code, Region_Name = mgmtArea) catch_joined &lt;- left_join(catch_clean, region_defs, by = c(&quot;Region&quot;)) head(catch_joined) Ahora las capturas tienen la información auxiliar con la definición de las regiones a su lado. Nota: dplyr entrega un set completo de uniones: inner, left, right, full, semi, anti y no solo left_join. 8.5.9 separate() y unite() separate() y su complemento unite(), nos permiten separar fácilmente una columna en varias (o varias en una sola). Esto puede ser realmente útil cuando tenemos una columna con fechas y necesitamos agrupar los datos por año o mes. Creemos un nuevo data.frame con datos ficticios para ilustrar esto: dates_df &lt;- data.frame(date = c(&quot;5/24/1930&quot;, &quot;5/25/1930&quot;, &quot;5/26/1930&quot;, &quot;5/27/1930&quot;, &quot;5/28/1930&quot;), stringsAsFactors = FALSE) dates_df %&gt;% separate(date, c(&quot;month&quot;, &quot;day&quot;, &quot;year&quot;), &quot;/&quot;) ## month day year ## 1 5 24 1930 ## 2 5 25 1930 ## 3 5 26 1930 ## 4 5 27 1930 ## 5 5 28 1930 Actividad: Separe la columna city del siguiente data.frame en las columnas city y state_code: cities_df &lt;- data.frame(city = c(&quot;Juneau AK&quot;, &quot;Sitka AK&quot;, &quot;Anchorage AK&quot;), stringsAsFactors = FALSE) # Escriba su solucipón aquí: # unite() hace exactamente lo inverso a la función separate(): dates_df %&gt;% separate(date, c(&quot;month&quot;, &quot;day&quot;, &quot;year&quot;), &quot;/&quot;) %&gt;% unite(date, month, day, year, sep = &quot;/&quot;) ## date ## 1 5/24/1930 ## 2 5/25/1930 ## 3 5/26/1930 ## 4 5/27/1930 ## 5 5/28/1930 Actividad: Use unite() en su solución a la actividad anterior para combinar las columnas que acaba de separar y déjelas en una única columna que incluya la cuidad y el estado, city: # Escriba su solución aquí. 8.6 Resumen Acabamos de aprender varias cosas que se pueden hacer con los paquetes dplyr y tidyr, pero si se pregunta como se vería esto en un análisis real… Veamos eso a continuación: catch_original &lt;- read.csv(url(&quot;https://knb.ecoinformatics.org/knb/d1/mn/v2/object/df35b.302.1&quot;, method = &quot;libcurl&quot;), stringsAsFactors = FALSE) region_defs &lt;- read.csv(url(&quot;https://knb.ecoinformatics.org/knb/d1/mn/v2/object/df35b.303.1&quot;, method = &quot;libcurl&quot;), stringsAsFactors = FALSE) %&gt;% select(code, mgmtArea) mean_region &lt;- catch_original %&gt;% select(-All, -notesRegCode) %&gt;% gather(species, catch, -Region, -Year) %&gt;% mutate(catch = ifelse(catch == &quot;I&quot;, 1, catch)) %&gt;% mutate(catch = as.integer(catch)*1000) %&gt;% group_by(Region) %&gt;% summarize(mean_catch = mean(catch)) %&gt;% left_join(region_defs, by = c(&quot;Region&quot; = &quot;code&quot;)) head(mean_region) ## # A tibble: 6 x 3 ## Region mean_catch mgmtArea ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 ALU 40384. Aleutian Islands Subarea ## 2 BER 16373. Bering River Subarea Copper River Subarea ## 3 BRB 2709796. Bristol Bay Management Area ## 4 CHG 315487. Chignik Management Area ## 5 CKI 683571. Cook Inlet Management Area ## 6 COP 179223. Copper River Subarea Referencias "],
["creando-funciones-de-r.html", "9 Creando funciones de R 9.1 Objetivos 9.2 ¿Por qué usar funciones? 9.3 Ejemplo: Conversión de temperatura 9.4 Creando una función 9.5 Actividad 9.6 Documentando funciones de R 9.7 Resumen", " 9 Creando funciones de R Mucha gente escribe los código de R como un flujo simple y continuo de comandos, incluso algunas veces sacado directamente desde la consola de R y copiado a un script. Si bien cualquier script tiene tremendos beneficios por sobre soluciones basadas en el uso del mouse, existen ventajas de usar códigos autocontenidos o modulares. Este es el rol de las funciones (function) en R. En este capítulo vamos a revisar las ventajas de escribir funciones de R, practicaremos creando algunas y demostraremos como usarlas. 9.1 Objetivos En este capítulo veremos: Por qué debemos escribir códigos utilizando funciones. Como escribir código para una o más funciones. Como documentar las funciones y explicanr su funcionamiento. 9.2 ¿Por qué usar funciones? En inglés se usa el acronismo DRY que se traduce a No Se Repita a Si Mismo (Don’t Repeat Yourself). Al crear funciones pequeñas y autocontenidas, que desarrollan una única acción y lo hacen bien, podemos ganar: Mejoras en el entendimiento del código. Re-uso del código a través de la descomposición de tareas en fragmentos pequeños. Mejorar la revisión y corrección de errores. 9.3 Ejemplo: Conversión de temperatura Imagine que tiene datos de temperatura medidos en grados Fahrenheit y los quiere convertir a Celsius para ser analizados. Puede ser que para este fin usted escriba un código de R que lo siguiente. airtemps &lt;- c(212, 30.3, 78, 32) celsius1 &lt;- (airtemps[1]-32)*5/9 celsius2 &lt;- (airtemps[2]-32)*5/9 celsius3 &lt;- (airtemps[3]-32)*5/9 En este código existen 3 lineas de código que hacen lo mismo y repite la fórmula para convertir la temperatura. Este código se puede acortar y hacer más confiable aliminando las repeticiones. 9.4 Creando una función Las funciones de R son un mecanismo donde se procesa una entrada y se devuelve un valor de salida. En forma similar a otras variables en R, las funciones se asignan a una variable y pueden ser utilizadas en diferentes partes del código. Para crear una función en R, se usa la función function y se asigna su resultado a una variable. A continuación escribiremos una función que transforma la desde grados fahrenheit a grados celsius. fahr_to_celsius &lt;- function(fahr) { celsius &lt;- (fahr-32)*5/9 return(celsius) } Al ejecutar este código, hemos creado una función y almacenado en el ambiente global de R. El argumento fahr de la función function indica que toma un único parámetro (la temperatura en fahrenheit) y la declaración return indica que la función devolve el valor almacenado en la variable celsius, que es calculada internamente. Usemos ahora la función y veamos si obtenemos los mismos valores: celsius4 &lt;- fahr_to_celsius(airtemps[1]) celsius4 ## [1] 100 celsius1 == celsius4 ## [1] TRUE ¡Excelente! Ahora tenemos una función que para convertir gradpos que podemos usar. Ya que la mayoría de las operaciones en R pueden tomar múltiples tipos de entradas, es posible pasar el vector original de airtemps y calcular todos los resultados al mismo tiempo: celsius &lt;- fahr_to_celsius(airtemps) celsius ## [1] 100.0000000 -0.9444444 25.5555556 0.0000000 Ahora nuestra función tomó el vector de temperaturas en grados fahrenheit y fue devuelto como un en grados celsius. 9.5 Actividad Cree una función que transforme los datos de grados celsius a fahrenheit (celsius_to_fahr). Luego use esta formula para convertir el vector celsius a un vector de temperaturas fahrenheit y compare los resultados al vector original airtemps para verificar si están correctos. # Escriba aquí su código ¿Encontró problemas con el redondeo de valores o precisión? 9.6 Documentando funciones de R Las funciones necesitan ser documentadas para que se pueda comunicar que es lo que hacen y por qué. El paquete roxygen2 provee una forma simple de documentar sus funciones, explicando que hacen, cuales son los supuestos, descripciones sobre los valores de entrada, de los que se devuelven y sobre la racionalidad para las decisiones utilizadas en la implementación de la función. La documentación en ROxygen se incluye inmediatamente antes de la definición de la función. Para hacer esto, se debe indicar que es parte de la documentación iniciando la línea con los caracteres #'. Aquí hay una versión documentada la función que transforma las temperaturas de fahrenheit a grados celcius: #&#39; Convierte los datos de temperatura de Fahrenheit a Celsius #&#39; #&#39; @parametros fahr Datos de temperatura en grados Fahrenheit que serán convertidos #&#39; @return Valores de temperatura en grados Celsius #&#39; @keywords conversion #&#39; @export #&#39; @ejemplos #&#39; fahr_to_celsius(32) #&#39; fahr_to_celsius(c(32, 212, 72)) fahr_to_celsius &lt;- function(fahr) { celsius &lt;- (fahr-32)*5/9 return(celsius) } El uso de las palabras claves @param define los datos de entrada esperados y @return los valores que serán devueltos por la función. @examples es útil como un recordatorio de como se debe usar la función. Finalmente, la palabra clave @export indica que, si esta función fuera agregada a un paquete, la función estará disponible para ser usado por otros códigos o paquetes. 9.7 Resumen Las funciones son útiles para reducir la redundancia, reusar el código y reducir los errores. Las funciones que contruyen con la función function (valga la redundancia). Es funamental una buena documentación de las funciones, el paquere roxygen2 es una gran ayuda para esto. "],
["visualización-de-mapas-basados-en-la-web.html", "10 Visualización de mapas basados en la web 10.1 Objetivos 10.2 Introducción 10.3 Un ejemplo básico 10.4 Un ejemplo ya no tan básico 10.5 Mapas estáticos con ggplot y geom_sf 10.6 Recursos", " 10 Visualización de mapas basados en la web 10.1 Objetivos En este capítulo veremos: Como usar RMarkdown para crear un sitio web. Una revisión rápida de como producir visualizaciones con R y el paquete ggplot. Como crear mapas interactivos usando el paquete leaflet. Como publicar mapas interactivos usando RMarkdown para hacer un sitio web en GitHub. 10.2 Introducción Compartir el trabajo científico de una manera interactiva y entretenida es fundamental para el avance de la ciencia. Hasta este punto del libro hemos hablado sobre las herramientas que nos ayudan a hacer ciencia abierta (open science): R y muchos de sus paquetes RStudio git GitHub RMarkdown RMarkdown es tremendamente potente para crear reportes científicos, sin embargo hasta ahora no hemos llegado ni a rozar en su verdadero potencial. En esta lección, vamos a tomar un repositorio ya existente en GitHub y lo transformaremos en un sitio web elegante y simple de leer usando algunas de las herramientas que hemos aprendido hasta este punto. 10.3 Un ejemplo básico En RStudio, cree un archivo nuevo al nivel tope se su repositorio git llamado index.Rmd. La forma más simple de hacer esto usando el menú de RStudio. Elija File -&gt; New File -&gt; RMarkdown… Esto abrirá una ventana de diálogo. Usted debe crear un “Document” en formato “HTML”. Esas son las opciones por defecto. Abra index.Rmd (si es que no está y abierto). Haga clic en Knit. Vea la salida que se genera. Note que se ha creado un nuevo archivo index.html en el mismo directorio. Este es el resultado transformado a código HTML (página web) a partir del documento RMarkdown. Commit y push sus cambios (ambos archivos, index.Rmd e index.html). Abra su navegador web en la página www.GitHub.com de su repositorio. Vaya a Settings &gt; GitHub Pages y active GitHub Pages para la rama (branch) master. Ahora la versión del sitio web de su repositorio se va a mostrar en un URL especial. GitHub Pages sigue la convensión: https://{username}.github.io/{repository}/ https://cornejotux.github.io/claseRMarkdown/ Ponga atención que ahora el sitio no está en github.com si no que en github.io. Vaya a https://{username}.github.io/{repo_name}/ (Hay que poner el / al final!). Y vea la versión generada de su sitio web. 10.4 Un ejemplo ya no tan básico Ahora que ha hemos visto como crear una página web desde RMarkdown, vamos a crear un sitio web que usa algunas de geniales funcionalidades que están disponibles en R. Vamos a seguir usando el mismo repositorio git y RStudio Project de arriba, pero vamos a agregar algunos archivos al repositorio y a modificar el documento index.Rmd. Primero tenemos que obtener datos. Vamos a re-usar los datos sobre el retorno para desove de salmones de Alaska disponible desde la base de datos OceanAK del Departamento de Pesca y Casa de Alaska (ADF&amp;G): Navegue a Escapement Counts (o visite el sitio KNB y busque por ‘oceanak’) y copie el Download URL para el archivo ADFG_firstAttempt_reformatted.csv. Descargue el archivo en R usando read.csv para hacer portable el código. Calcule el escape anual (se refiere al número de peces que no son capturados por la pesquería) por especie y región usando el paquete dplyr. Haga un gráfico de barras para el escape anual por especie usando el paquete ggplot2. Muestre los datos en una tabla interactiva usando la función datatable disponible en el paquete DT. Haga un mapa interactivo, tipo Google Maps, de los lugares donde se muestreó el escape de salmones. Para hacer esto, vamos a usar el paquete leaflet que nos permite crear un mapa interactivo con marcadores en cada lugar de muestro: Primero, cargamos todos los paquetes que vamos a usar: library(leaflet) library(dplyr) library(tidyr) library(ggplot2) library(DT) library(sf) library(ggmap) # devtools::install_github(&quot;dkahle/ggmap&quot;) 10.4.1 Carga de datos: escape de salmones Puede leer los datos en forma directa desde el repositorio de en KNB, si es que no lo tiene en su computador: data_url &lt;- &quot;https://knb.ecoinformatics.org/knb/d1/mn/v2/object/urn%3Auuid%3Af119a05b-bbe7-4aea-93c6-85434dcb1c5e&quot; esc &lt;- tryCatch( read.csv(&quot;data/10.1_escapement.csv&quot;, stringsAsFactors = FALSE), error=function(cond) { message(paste(&quot;Archivo de escape de salmos no existe, descarguelo desde KNB.&quot;)) esc &lt;- read.csv(url(data_url, method = &quot;libcurl&quot;), stringsAsFactors = FALSE) return(esc) } ) head(esc) ## Location SASAP.Region sampleDate Species DailyCount Method ## 1 Akalura Creek Kodiak 1930-05-24 Sockeye 4 Unknown ## 2 Akalura Creek Kodiak 1930-05-25 Sockeye 10 Unknown ## 3 Akalura Creek Kodiak 1930-05-26 Sockeye 0 Unknown ## 4 Akalura Creek Kodiak 1930-05-27 Sockeye 0 Unknown ## 5 Akalura Creek Kodiak 1930-05-28 Sockeye 0 Unknown ## 6 Akalura Creek Kodiak 1930-05-29 Sockeye 0 Unknown ## Latitude Longitude Source ## 1 57.1641 -154.2287 ADFG ## 2 57.1641 -154.2287 ADFG ## 3 57.1641 -154.2287 ADFG ## 4 57.1641 -154.2287 ADFG ## 5 57.1641 -154.2287 ADFG ## 6 57.1641 -154.2287 ADFG 10.4.2 Gráficos estáticos Ahora que ya tenemos los datos, calculemos el escape anual por especie y región: annual_esc &lt;- esc %&gt;% separate(sampleDate, c(&quot;Year&quot;, &quot;Month&quot;, &quot;Day&quot;), sep = &quot;-&quot;) %&gt;% mutate(Year = as.numeric(Year)) %&gt;% group_by(Species, SASAP.Region, Year) %&gt;% summarize(escapement = sum(DailyCount)) %&gt;% filter(Species %in% c(&quot;Chinook&quot;, &quot;Sockeye&quot;, &quot;Chum&quot;, &quot;Coho&quot;, &quot;Pink&quot;)) head(annual_esc) ## # A tibble: 6 x 4 ## # Groups: Species, SASAP.Region [1] ## Species SASAP.Region Year escapement ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Chinook Alaska Peninsula and Aleutian Islands 1974 1092 ## 2 Chinook Alaska Peninsula and Aleutian Islands 1975 1917 ## 3 Chinook Alaska Peninsula and Aleutian Islands 1976 3045 ## 4 Chinook Alaska Peninsula and Aleutian Islands 1977 4844 ## 5 Chinook Alaska Peninsula and Aleutian Islands 1978 3901 ## 6 Chinook Alaska Peninsula and Aleutian Islands 1979 10463 Este fragmento de código usa varios de los comandos de dplyr que ya hemos visto y algunos otros nuevos. La función separate es usada para dividir la columna sampleDate en las columnas Year, Month y Day, las que luego usamos en group_by para indicar que queremos calcular nuestros resultados para las combinaciones únicas de species, region y year. A continuación usamos summarize para calcular los valores de escape para cada uno de estos grupos. Finalmente, usamos un filtro y el operador %in% para seleccionar sólo las especies de salmones. Ahora vamos a hacer un gráficos con los resultados usando ggplot. ggplot usa estéticas de mapas (definidas usando aes()) y geometrías para crear el gráfico. Adicionalmente a geometrías/estéticas se pueden agregar a ggplot elementos de como temas para el formato gráfico y otros usando el operador +. ggplot(annual_esc, aes(x = Species, y = escapement)) + geom_col() ¿Qué pasa si queremos que las barras sean azules en vez de grises? Podríamos intentar hacer lo siguiente: ggplot(annual_esc, aes(x = Species, y = escapement, fill = &quot;blue&quot;)) + geom_col() ¿Qué pasó en este gráfico? Vemos que al definir el color del gráfico dentro del llamado a la estética del mapa el color cambia, pero no es lo que queríamos hacer. Lo que ocurre, detrás de escena, es que se creó una columna llena con la palabra “blue” en el data.frame que usa ggplot y posteriormente fue mapeado a la estética fill, que finalmente seleccionó el color por defecto (rojo) para llenar las columnas. Lo que queríamos hacer era cambiar el color de las barras. Para hacer esto debemos llamar la opción del color dentro de la función geom_bar fuera de la llamada a la función estética del mapa. ggplot(annual_esc, aes(x = Species, y = escapement)) + geom_col(fill = &quot;blue&quot;) ¿Y si ahora queremos mapear el color de la barras basado en una variable? por ejemplo región., ggplot es muy poderoso porque permite hacer fácilmente un gráfico que muestre estos aspectos de los datos. ggplot(annual_esc, aes(x = Species, y = escapement, fill = SASAP.Region)) + geom_col() Aquí hay un ejemplo con una estética y geometría de mapas diferente que podemos usar con estos datos. Se puede además agregar título, ajustar etiquetas e incluir un tema. ggplot(filter(annual_esc, SASAP.Region == &quot;Kodiak&quot;), aes(x = Year, y = escapement, color = Species)) + geom_line() + geom_point() + ylab(&quot;Escapement&quot;) + ggtitle(&quot;Kodiak Salmon Escapement&quot;) + theme_bw() Fíjese que en el código anterior se agregó un filtro a la función ggplot, esto se hizo para graficar sólo los salmones en registrados para la isla Kodiak. ggplot tiene la funcion facet_wrap que permite crear fácilmente gráficos como este para cada región usando, todos en una solo gráfica, con el mismo formato y características. ggplot(annual_esc, aes(x = Year, y = escapement, color = Species)) + geom_line() + geom_point() + facet_wrap(~SASAP.Region, scales = &quot;free_y&quot;) + ylab(&quot;Escapement&quot;) + theme_bw() 10.4.3 Mapas interactivos Ahora vamos a convertir los datos de escape de salmones a una tabla donde exista una fila única para cada lugar de muestro: locations &lt;- esc %&gt;% distinct(Location, Latitude, Longitude) %&gt;% drop_na() Y la desplegamos en una tabla interactiva: datatable(locations) Con los datos en esta tabla hacermos un mapa usando leaflet que requiere (generalmente) sólo un par de lineas de código: leaflet(locations) %&gt;% addTiles() %&gt;% addMarkers(~ Longitude, ~ Latitude, popup = ~ Location) La función addTiles() obtiene la capa base desde OpenStreetMap que es una alternativa de código abierto a Google Maps. addMarkers usa una sintaxis un poco rara en comparación a la que acabamos de ver con ggplot2, usa ~ antes de los nombres de columnas. Esto es similar a como trabaja la función lm (y algunas otras) y es necesario que usted se asegure que incluye ~ para que su mapa funcione. En leaflet también es posible usar capas desde Servicio de Mapas Web (Web Map Services o WMS). Aquí hay un ejemplo que utiliza una capa del mapa batimétrico general de los océanos (GEBCO) WMS. En este ejemplo además demostramos como usar marcadores más simples. leaflet(locations) %&gt;% addWMSTiles(&quot;https://www.gebco.net/data_and_products/gebco_web_services/web_map_service/mapserv?&quot;, layers = &#39;GEBCO_LATEST&#39;, attribution = &quot;Imagen producida desde la grilla GEBCO_2014, versión 20150318, www.gebco.net&quot;) %&gt;% addCircleMarkers(lng = ~Longitude, lat = ~Latitude, popup = ~ Location, radius = 5, # set fill properties fillColor = &quot;salmon&quot;, fillOpacity = 1, # set stroke properties stroke = T, weight = 0.5, color = &quot;white&quot;, opacity = 1) Leaflet tiene muchas funcionalidades que permiten crear mapas elegantes y funcionales con facilidad. Aquí hay ejemplos de mapas que fueron creados como parte del proyecto SASAP (Estado del Salmon de Alaska y Su Gente) usando las mismas herramientas que acabamos de aprender. Estos mapas le pueden dar una idea de cuan poderosa puede ser la combinación de RMarkdown y las páginas de GitHub. 10.5 Mapas estáticos con ggplot y geom_sf También es posible crear mapas similares usando ggplot y la geometría geom_sf. Para hacer esto, lo primero que se debe hacer es transformar el data.frame con los datos de los lugares a un objeto sf entregando el sistema de coordenadas de referencia (EPSG:4326 es el sistema para geocoordenada en WGS84). También es necesario transformar los puntos a EPSG:3857 que es el sistema de coordenadas de referencia usado para hacer los mapas en Google Maps, Stamen y OpenStreetMap, entre otros. locations_sf &lt;- locations %&gt;% st_as_sf(coords = c(&quot;Longitude&quot;, &quot;Latitude&quot;), crs = 4326) locations_sf_3857 &lt;- st_transform(locations_sf, 3857) Después, tomamos un mapa base desde una capa en Stamen map server que cubra la región de interés. Esto incluye una transformación del polígono del área en EPSSG:326 para dejarla en el mismo sistema de coordenadas EPSG:3857, que es la proyección que el mapa raster entregará desde Stamen. # Define una función para correrir el poligono a EPSG:3857 # See https://github.com/dkahle/ggmap/issues/160#issuecomment-397055208 ggmap_bbox_to_3857 &lt;- function(map) { if (!inherits(map, &quot;ggmap&quot;)) stop(&quot;map must be a ggmap object&quot;) # Extraer el polígono de contorno (en lat/lon) desde ggmap a un vector numérico, # y define los nombre que esperar sf::st_bbox: map_bbox &lt;- setNames(unlist(attr(map, &quot;bb&quot;)), c(&quot;ymin&quot;, &quot;xmin&quot;, &quot;ymax&quot;, &quot;xmax&quot;)) # Converte el polígino de contorno (bbox) a un poligono tipo sf, tranformandolo a 3857 y # lo convierte de regreso a un bbox (complicado, pero funciona!!) bbox_3857 &lt;- st_bbox(st_transform(st_as_sfc(st_bbox(map_bbox, crs = 4326)), 3857)) # Sobre-escribe el bbox del objeto ggmap con las coordenadas transformadas attr(map, &quot;bb&quot;)$ll.lat &lt;- bbox_3857[&quot;ymin&quot;] attr(map, &quot;bb&quot;)$ll.lon &lt;- bbox_3857[&quot;xmin&quot;] attr(map, &quot;bb&quot;)$ur.lat &lt;- bbox_3857[&quot;ymax&quot;] attr(map, &quot;bb&quot;)$ur.lon &lt;- bbox_3857[&quot;xmax&quot;] map } bbox &lt;- c(-170, 52, -130, 64) # Esto es bascamenete el sur de Alaska ak_map &lt;- get_stamenmap(bbox, zoom = 4) ak_map_3857 &lt;- ggmap_bbox_to_3857(ak_map) Finalmente se grafica el mapa base raster con los puntos sobrepuestos, esto es fácil de hacer ahora que todo esta en la misma proyección (3857): ggmap(ak_map_3857) + geom_sf(data = locations_sf_3857, inherit.aes = FALSE) 10.6 Recursos Lisa Charlotte Rost. (2018) Why not to use two axes, and what to use instead: The case against dual axis charts "],
["creando-paquetes-de-r.html", "11 Creando Paquetes de R 11.1 Objetivos 11.2 ¿Por qué usar paquetes? 11.3 Instalación y carga de los paquetes 11.4 Creación de un paquete básico 11.5 Agregando su código 11.6 Agregando la documentación 11.7 Verifique su paquete 11.8 Verificando e instalando el paquete R creado 11.9 Compartiendo y publicando su paquete de R 11.10 Más lecturas", " 11 Creando Paquetes de R 11.1 Objetivos En este capítulo veremos: Las ventajas de usar paquetes de R para organizar el código Técnicas simples para crear paquetes de R Aproximaciones para documentar el código en los paquetes creados 11.2 ¿Por qué usar paquetes? La mayoría de los usuarios de R están acostumbrados a cargar y utilizar paquetes en su trabajo. Además, sabe cuan rico es CRAN para proveer soluciones para muchas de sus necesidades. Sin embargo, la mayoría de la gente nunca ha creado sus propios paquetes y piensa que el proceso es muy complicado. Realmente es bastante simple, directo y extremadamente útil para el trabajo personal. La creación de paquetes sirve principalmente en dos casos: Como mecanismo para compartir/distribuir códigos reusables (incluso si sólo es para uso personal). Como mecanismo para reproducir documentos de análisis, modelos y resultados. A lo menos se puede crear un paquete para nuestras propias funciones de código más útiles, haciéndolas más fáciles de mantener y usar, estas herramientas pueden servir para más de un proyecto en el que trabaje. Los paquetes usethis, devtools y roxygen2 hacen que la creación y mantención de paquetes de R se experiencia sencilla. 11.3 Instalación y carga de los paquetes library(devtools) library(usethis) # install.packages(&quot;roxygen2&quot;) library(roxygen2) 11.4 Creación de un paquete básico Gracias al excelente paquete usethis, solo toma llamar la función create_package() para crear el esqueleto necesario de un paquete de R. Esto elimina la mayor parte de las razones de procastinación. Entonces, para crear el paquete llamado mytools se hace: setwd(&#39;..&#39;) create_package(&quot;mytools&quot;) ✔ Setting active project to &#39;/Users/jones/development/mytools&#39; ✔ Creating &#39;R/&#39; ✔ Creating &#39;man/&#39; ✔ Writing &#39;DESCRIPTION&#39; ✔ Writing &#39;NAMESPACE&#39; ✔ Writing &#39;mytools.Rproj&#39; ✔ Adding &#39;.Rproj.user&#39; to &#39;.gitignore&#39; ✔ Adding &#39;^mytools\\\\.Rproj$&#39;, &#39;^\\\\.Rproj\\\\.user$&#39; to &#39;.Rbuildignore&#39; ✔ Opening new project &#39;mytools&#39; in RStudio Esto va a crear la estructura de directorios, incluyendo los archivos críticos bajo la Estructura Estandard de Paquetes de R. De los cuales el más importante es el archivo DESCRIPTION. Este documento provee los metadatos sobre el su paquete. Edite este archivo DESCRIPTION para entregar los valores que sean razonables para cada campo, incluyendo su información de contacto. La información necesaria para elegir una licencia (LICENSE) se puede encontrar en los documentos (en inglés) Extending R. El archivo DESCRIPTION espera que elija una licencia desde una lista predefinida, puede usar varias métodos para definir el archivo de licencia, como es por ejemplo la licencia Apache 2: use_apl2_license(name=&quot;Jorge Cornejo&quot;) ✔ Setting License field in DESCRIPTION to &#39;Apache License (&gt;= 2.0)&#39; ✔ Writing &#39;LICENSE.md&#39; ✔ Adding &#39;^LICENSE\\\\.md$&#39; to &#39;.Rbuildignore&#39; Una vez que la licencia ya fue elegida y ha editado el archivo DESCRIPTION con su información de contacto, un título y una descripción, se verá algo como esto: Package: mytools Title: Funciones de utilidad creadas por Jorge Cornejo Version: 0.1 Authors@R: &quot;Jorge Cornejo &lt;jorge.cornejo@ifop.cl&gt; [aut, cre]&quot; Description: El paquete mytools containe funciones utilitarias para cuando necesito hacer cosas. Depends: R (&gt;= 3.6.0) License: Apache License (&gt;= 2.0) LazyData: true 11.5 Agregando su código El paquete esqueleto creado contiene un directorio R que es donde se deben dejar los archivos fuentes. Agregue sus funciones y clases en los archivos de este directorio. Trate de elegir nombres que no existan en otros paquetes para que no entren en conflictos. Por ejemplo, se puede agregar un archivo environemnt_info.R que contiene la función environment_info() que podría querer re-usar. Esto puede dejar mucho que desear…, pero se entiende. La función usethis::use_r() le va a ayudar a dejar los archivos en los directorios adecuados, para eso use por ejemplo: use_r(&quot;environment_info&quot;) ● Modify &#39;R/environment_info.R&#39; esto crea el archivo R/environment_info.R, que ahora puede modificar para agregar la implementación de la siguiente función: environment_info &lt;- function(msg) { print(devtools::session_info()) print(paste(&quot;También imprime el mensaje entrante: &quot;, msg)) } Si su código R depende de funciones de otro paquete, entonces tiene que declararlo en la lista Imports del archivo DESCRIPTION de su paquete de R. El ejemplo de arriba depende del paquete devtools, por consiguiente debemos ponerlo en el listado de dependencias. Nuevamente, usethis entrega un método de ayuda muy útil: usethis::use_package(&quot;devtools&quot;) ✔ Adding &#39;devtools&#39; to Imports field in DESCRIPTION ● Refer to functions with `devtools::fun()` 11.6 Agregando la documentación Es necesario incluir documentación para cada una de las funciones y clases que se incluyan en el paquete. Esto se puede hacer usando la aproximación de roxygen2 que provee comentarios incorporados en los archivos con el código fuente, que a su vez son convertidos a páginas de manuales y otros para documentación de R. Es importante que siempre se asegure de definir el propósito general de la función y cada uno de sus parámetros. #&#39; Una función para imprimir información sobre el ambiente de trabajo de R. #&#39; #&#39; Esta función imprime el ambiente de trabajo actual y un mensaje. #&#39; @param msg El mensaje que quiere imprimir #&#39; @keywords debugging #&#39; @import devtools #&#39; @export #&#39; @examples #&#39; environment_info(&quot;Este es un mensaje importante de su auspiciador.&quot;) environment_info &lt;- function(msg) { print(devtools::session_info()) print(paste(&quot;Además imprime el mensaje entrante: &quot;, msg)) } Una vez que sus archivos están documentados se puede proceder a generar la documentación usando usando la función document() para generar los archivos .Rd que el paquete necesita. document() Updating mytools documentation Updating roxygen version in /Users/jones/development/mytools/DESCRIPTION Writing NAMESPACE Loading mytools Writing NAMESPACE Writing environment_info.Rd Y eso es realmente. Ahora tiene un paquete que puede check() (verificar), install() (instalar) y release() (publicación). 11.7 Verifique su paquete Ahora que ya tiene todo listo, puede verificar su código usando el marco de referencia de verificaciones tetsthat. La función ussethis::use_testthat() va a preparar su paquete de R para verificar su funcionamiento y luego puede usar la función use_test() para configurar archivos individuales de verificación. Por ejemplo, si quiere crear un test de las funciones en environment_info, puede hacer: usethis::use_testthat() ✔ Adding &#39;testthat&#39; to Suggests field in DESCRIPTION ✔ Creating &#39;tests/testthat/&#39; ✔ Writing &#39;tests/testthat.R&#39; usethis::use_test(&quot;environment_info&quot;) ✔ Writing &#39;tests/testthat/test-environment_info.R&#39; ● Modify &#39;tests/testthat/test-environment_info.R&#39; Ahora puede agregar los test a test-environment_info.R y ejecutarlos usando devtools::test(). Por ejemplo, si quiere agregar un test al archivo test-environment_info.R: test_that(&quot;Un mensaje está presente&quot;, { capture.output(result &lt;- environment_info(&quot;Un mensaje único&quot;)) expect_match(result, &quot;Un mensaje único&quot;) }) Ejecutelos para estar seguro que todas sus funciones estan trabajando como se espera usando la función devtools::test(): devtools::test() Loading mytools Testing mytools ✔ | OK F W S | Context ✔ | 2 | test-environment_info [0.1 s] ══ Results ══════════════════════════════════════════════════════════════════════════════════════════════════════════════ Duration: 0.1 s OK: 2 Failed: 0 Warnings: 0 Skipped: 0 Si, todo funciona!! 11.8 Verificando e instalando el paquete R creado Ahora que ya tenemos el paquete listo, podemos verificar su consistencia y que este completo usando la función check(). Haciendo pasado esta verificación se puede instalar localmente usando install(). Recuerde que esta instalación debe ejecutarse desde el directorio padre del módulo. check() install() El paquete que usted creó está ahora disponible para ser usado en el ambiente local de R. 11.9 Compartiendo y publicando su paquete de R La forma más simple de compartir el paquete R con otros es subiéndolo a un repositorio GitHub, esto permite que sea instalado por otros usando la función install_github('mytools','github_username') incluida en el paquete devtools. Si su paquete puede ser útil para una mayor cantidad de gente, debería considerar publicardo en el sitio CRAN, para esto se puede usar el método release() presente en `devtools(). Publicar (releasing) un paquete al CRAN requiere un trabajo bastante arduo para asegurarse que sigue los estándares definidos por la comunidad R, pero es totalmente posible y una valiosa contribución a la comunidad científica. Si está considerando publicar un paquete en forma más amplia, puede encontrar que el apoyo de la comunidad en ROpenSci, ellos entregan una valiosa ayuda y retroalimentación a través de su proceso de inducción. 11.10 Más lecturas Hadley Wickham’s awesome book: R Packages Thomas Westlake’s blog Writing an R package from scratch "],
["referencias.html", "12 Referencias", " 12 Referencias "]
]

# Visualización de mapas basados en la web

## Objetivos

En este capítulo:

- Como usar RMarkdown para crear un sitio web
- Una revisión rápida de como producir visualizaciones con R y el paquete `ggplot`
- Como crear mapas interactivos usando el paquete `leaflet`
- Publicar mapas interactivos usando RMarkdown para hacer un sitio web en GitHub

## Introducción

Compartir el trabajo científico de una manera interactiva y entretenida es fundamental para el 
desarrollo del proceso científico. Hasta este punto hemos hablado en este curso sobre un set
}de herramientas que nos ayudan a hacer ciencia abierta (_open science_):

- R y muchos de sus paquetes
- RStudio
- git
- GitHub
- RMarkdown

RMarkdown, en particular, es increíblemente potente para crear reportes científicos, sin embargo
hasta ahora no hemos llegado ni a rozar en su verdadero potencial para compartir nuestro trabajo
con colaboradores.

En esta lección, vamos a tomar un repositorio ya existente en GitHub y lo transformaremos en un 
sitio web elegante y simple de leer usando algunas de las herramientas que hemos aprendido en este 
curso.

## Un ejemplo básico

- En RStudio, cree un archivo nuevo al nivel tope se su repositorio **git** llamado `index.Rmd`. 
La forma más simple de hacer esto es a través del menú de RStudio. Elija File -> New File -> RMarkdown...
Esto abrirá una caja de dialogo. Usted debe crear un "Document" en formato "HTML". Estas son las 
opciones por defecto.
- Abra `index.Rmd` (si es que no está y abierto)
- Haga clic en _Knit_
    - Vea la salida que se genera
    - Note que se ha creado un nuevo archivo `index.html` en el mismo directorio. Este es el resultado
    en HTML (página web) creado a partir del documento RMarkdown 
- Commit sus cambios (ambos archivos, index.Rmd e index.html)
- Abra su navegador web en la página www.GitHub.com de su repositorio
- Vaya a Settings > GitHub Pages y active _GitHub Pages_ para la rama (branch) `master`

    Ahora la versión del sitio web rendered de su repositorio se va a mostrar en un URL especial.
    
    GitHub Pages sigue una convensión como esta:
    
     ```
     https://{username}.github.io/{repository}/
     https://cornejotux.github.io/claseRMarkdown/
     ```
     
    Ponga atención que ahora sitio no está en github.com si no que en github.io. 
     
- Vaya a https://{username}.github.io/{repo_name}/ (Hay que poner el `/` al final!)
    Y vea la versión generada de su sitio web.
    

## Un ejemplo ya no tan básico

Ahora que ha hemos visto como crear una página web desde RMarkdown, vamos a crear un sitio web que usa
algunas funcionalidad geniales que están disponibles en R. Vamos a seguir usando el mismo repositorio 
git y RStudio Project de arriba, pero vamos a agregar algunos archivos al repositorio y a modificar el 
documento `index.Rmd`.

Primero tenemos que obtener datos. Vamos a re-usar los datos sobre el retorno para desove de salmones 
de Alaska disponible desde la base de datos OceanAK del Departamento de Pesca y Casa de Alaska (ADF&G):

- Navegue a [Escapement Counts](https://doi.org/10.5063/F1S46Q6M) (o visite el sitio KNB y busque por 
'oceanak') y copie el Download URL para el archivo `ADFG_firstAttempt_reformatted.csv`
- Descargue el archivo en R usando `read.csv` para hacer portable el código
- Calcule el escape anual (se refiere al numero de peces que no son capturados por la pesquería) por
especie y región usando el paquete `dplyr`
- Haga un gráfico de barrar para el escape anual por especie usando el paquete `ggplot2`
- Muestre los datos en una tabla interactiva usando la función `datatable` disponible en el paquete `DT`
- Haga un mapa interactivo, tipo Google Maps, de los lugares donde se muestreo el escape

Para hacer esto, vamos a usar el paquete [`leaflet`](https://rstudio.github.io/leaflet/) para crea un 
mapa interactivo con marcadores en cada lugar de muestro:

Primero, cargamos todos los paquetes que vamos a usar:

```{r load_packages, message = F, warning = F}
  library(leaflet)
  library(dplyr)
  library(tidyr)
  library(ggplot2)
  library(DT)
  library(sf)
  library(ggmap) # devtools::install_github("dkahle/ggmap")
```

### Carga de datos sobre escape de salmones

Puede leer los datos en forma directa desde el repositorio de datos de [KNB](https://knb.ecoinformatics.org/),
si es que no la tiene ya en su computador:

```{r read_data}
data_url <- "https://knb.ecoinformatics.org/knb/d1/mn/v2/object/urn%3Auuid%3Af119a05b-bbe7-4aea-93c6-85434dcb1c5e"

esc <- tryCatch(
    read.csv("data/escapement.csv", stringsAsFactors = FALSE),
    error=function(cond) {
        message(paste("Archivo de escape de salmos no existe, descarguelo desde KNB."))
        esc <- read.csv(url(data_url, method = "libcurl"), stringsAsFactors = FALSE)
        return(esc)
    }
)

head(esc)
```

### Gráficos estáticos

Ahora que ya tenemos los datos, calculemos el escape anual por especie y región:

```{r mean_esc}
annual_esc <- esc %>% 
  separate(sampleDate, c("Year", "Month", "Day"), sep = "-") %>% 
  mutate(Year = as.numeric(Year)) %>% 
  group_by(Species, SASAP.Region, Year) %>% 
  summarize(escapement = sum(DailyCount)) %>% 
  filter(Species %in% c("Chinook", "Sockeye", "Chum", "Coho", "Pink"))

head(annual_esc)
```

Este fragmento de código usa varios de los comandos de `dplyr` que ya hemos visto y algunos otros nuevos. 
La función `separate` es usada para dividir la columna _sampleDate_ en las columnas Year, Month y Day,
las que luego usamos en `group_by` para indicar que queremos calcular nuestros resultados para las
combinaciones únicas de _species_, _region_ y _year_.  A continuación usamos `summarize` para calcular 
los valores de escape para cada uno de estos grupos. Finalmente, usamos un filtro y el operador `%in%`
para seleccionar solo las especies de salmones.

Ahora vamos a hacer un gráficos con los resultados usando `ggplot`. `ggplot` usa _estéticas_ de mapas 
(definidas usando `aes()`) y _geometrías_ para crear el gráfico. Adicionalmente a geometrías/estéticas
se pueden agregar a `ggplot` elementos de temas usando el operador `+`.

```{r plot_esc}
ggplot(annual_esc, aes(x = Species, y = escapement)) +
  geom_col()
```

¿Qué pasa si queremos que las barras sean azules en vez de grises? Se podría pensar que se puede hacer 
lo siguiente:

```{r}
ggplot(annual_esc, aes(x = Species, y = escapement, fill = "blue")) +
  geom_col()
```

¿Qué pasó en este gráfico?

Se puede ver que tratamos de definir el color del gráfico dentro del llamado a la estética del mapa. 
Lo que hemos hecho, detrás de la escena, es crear una columna llena con la palabra "blue" en el `data.frame`
que usar `ggplot` y posteriormente fue mapeado a la estética `fill`, que finalmente seleccionó el color
por defecto rojo para llenar las columnas. 

Lo que realmente queríamos hacer era cambiar el color de las barras. Para hacer esto debemos llamar
la opción del color dentro de la función `geom_bar` **fuera** de la llamada a la función estética del 
mapa.

```{r}
ggplot(annual_esc, aes(x = Species, y = escapement)) +
  geom_col(fill = "blue")
```

¿Y si ahora queremos mapear el color de la barras basado en una variable, por ejemplo región?

`ggplot` es muy poderoso porque permite hacer fácilmente un gráfico que muestre estos aspectos de los datos.

```{r}
ggplot(annual_esc, aes(x = Species, y = escapement, fill = SASAP.Region)) +
  geom_col()
```

Aquí hay un ejemplo con una estética y geometría de mapas diferente que podemos usar con estos datos. Se
puede ademas agregar un título, ajustar las etiquetas e incluir un tema.

```{r}
ggplot(filter(annual_esc, SASAP.Region == "Kodiak"), aes(x = Year, y = escapement, color = Species)) + 
    geom_line() +
    geom_point() +
    ylab("Escapement") +
    ggtitle("Kodiak Salmon Escapement") +
    theme_bw()
```

Fíjese que agregué un filtro a la llamada de la función `ggplot` para dejar en el gráfico solo los 
datos de salmones en la isla Kodiak. Ademas, se puede crear fácilmente gráficos como este para cada 
región usando `facet_wrap`.

```{r}
ggplot(annual_esc, aes(x = Year, y = escapement, color = Species)) + 
    geom_line() +
    geom_point() +
    facet_wrap(~SASAP.Region, scales = "free_y") +
    ylab("Escapement") +
    theme_bw()

```

### Mapas interactivos

Ahora vamos a convertir los datos de escape en una tabla donde tengamos una única fila para
cada lugar de muestro:

```{r uniq_locations}
locations <- esc %>% 
  distinct(Location, Latitude, Longitude) %>% 
  drop_na()
```

Ahora lo desplegamos en una tabla interactiva:

```{r display_locations}
datatable(locations)
```

Y luego hacer una mapa _leaflet_ el que requiere (generalmente) sólo un par de lineas de código:

```{r simple_map}
leaflet(locations) %>% 
  addTiles() %>% 
  addMarkers(~ Longitude, ~ Latitude, popup = ~ Location)
```

La función `addTiles()` obtiene la capa base desde [OpenStreetMap](https://www.openstreetmap.org/) 
que es una alternativa de código abierto a Google Maps. 
`addMarkers` usa una sintaxis un poco rara en comparación a la que acabamos de ver con `ggplot2`, usar 
`~` antes de los nombres de columnas.
Esto es similar a como trabaja la función `lm` (y algunas otras), es necesario que usted se asegure 
de usar `~` para que su mapa funcione.

También es posible usar `leaflet` para importante capas desde Web Map Service (WMS). Aquí hay un ejemplo
que utiliza una capa del mapa batimétrico general de los océanos [(GEBCO)](https://www.gebco.net/data_and_products/gebco_web_services/web_map_service/#getcapabilities) WMS.
En este ejemplo ademas demostramos como crear un marcados circular más simple.

```{r}
leaflet(locations) %>% 
  addWMSTiles("https://www.gebco.net/data_and_products/gebco_web_services/web_map_service/mapserv?",
              layers = 'GEBCO_LATEST',
              attribution = "Imagen producida desde la grilla GEBCO_2014, versión 20150318, www.gebco.net") %>%
  addCircleMarkers(lng = ~Longitude,
                   lat = ~Latitude,
                   popup = ~ Location,
                   radius = 5,
                   # set fill properties
                   fillColor = "salmon",
                   fillOpacity = 1,
                   # set stroke properties
                   stroke = T,
                   weight = 0.5,
                   color = "white",
                   opacity = 1)
```

Leaflet tiene una tonelada de funcionalidades que permites crear mapas muy elegantes y funcionales con facilidad.
[Aquí](https://pages.github.nceas.ucsb.edu/NCEAS/sasap-data/language_vis.html) hay un ejemplo de algunos mapas
que fueron creados como parte del proyecto SASAP (Estado del Salmon de Alaska y Su Gente) usando las mismas
herramientas que acabamos de aprender. Este mapa idealmente le da una idea de cuan poderosa puede ser la 
combinación de RMarkdown y las páginas de GitHub. 

## Mapas estáticos con `ggplot` y `geom_sf`

También es posible crear mapas similares usando `ggplot` y la geometría `geom_sf`. Para hacer esto, lo 
primero que se debe hacer es transformar el `data.frame` con los datos de los lugares a un objeto `sf`
entregando el sistema de coordenadas de referencia (EPSG:4326 es el sistema para geocoordenada en WGS84).
También es necesario transformar los puntos a `EPSG:3857` que es el sistema de coordenadas de referencia
usado para hacer los mapas en Google Maps, Stamen y OpenStreetMap, entre otros.

```{r}
locations_sf <- locations %>%
  st_as_sf(coords = c("Longitud", "Latitud"), crs = 4326)
locations_sf_3857 <- st_transform(locations_sf, 3857)
```

Después, tomamos un mapa base desde una capa en _Stamen_ map server que cubra la región de interés. Esto 
incluye una transformación del polígono del área que están en `EPSSG:326` para dejarla en el mismo
sistema de coordenadas `EPSG:3857`, que es la proyección que el mapa raster entregará desde _Stamen_.


```{r message=FALSE}
# Define una función para correrir el poligono a EPSG:3857
# See https://github.com/dkahle/ggmap/issues/160#issuecomment-397055208
ggmap_bbox_to_3857 <- function(map) {
  if (!inherits(map, "ggmap")) stop("map must be a ggmap object")
  # Extraer el polígono de contorno (en lat/lon) desde ggmap a un vector numérico, 
  # y define los nombre que esperar sf::st_bbox:
  map_bbox <- setNames(unlist(attr(map, "bb")), 
                       c("ymin", "xmin", "ymax", "xmax"))
  
  # Converte el polígino de contorno (bbox) a un poligono tipo sf, tranformandolo a 3857 y 
  # lo convierte de regreso a un bbox (complicado, pero funciona!!)
  bbox_3857 <- st_bbox(st_transform(st_as_sfc(st_bbox(map_bbox, crs = 4326)), 3857))
  
  # Sobre-escribe el bbox del objeto ggmap con las coordenadas transformadas
  attr(map, "bb")$ll.lat <- bbox_3857["ymin"]
  attr(map, "bb")$ll.lon <- bbox_3857["xmin"]
  attr(map, "bb")$ur.lat <- bbox_3857["ymax"]
  attr(map, "bb")$ur.lon <- bbox_3857["xmax"]
  map
}

bbox <- c(-170, 52, -130, 64)   # Esto es bascamenete el sur de Alaska
ak_map <- get_stamenmap(bbox, zoom = 4)
ak_map_3857 <- ggmap_bbox_to_3857(ak_map)
```

 Finalmente se grafica el mapa raster base con los puntos sobrepuestos, esto es fácil de hacer ahora
 que todo esta en la misma proyección (3857):

```{r message=FALSE}
ggmap(ak_map_3857) + 
  geom_sf(data = locations_sf_3857, inherit.aes = FALSE)
```

## Recursos

- Lisa Charlotte Rost. (2018) [Why not to use two axes, and what to use instead: The case against dual axis charts](https://blog.datawrapper.de/dualaxis/)

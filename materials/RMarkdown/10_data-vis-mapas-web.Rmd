# Visualización de mapas basados en la web

## Objetivos

En esta clase:

- Como usar RMarkdown para crear un sitio web
- Una revisión rápida de como producir visualizaciones con R y el paquete `ggplot`
- Como creat mapas interactivos usando el paquete `leaflet`
- Piblicar mapas interactivos usando RMarkdown para hacer un sitio web en GitHub

## Introducción

Compartir el trabajo científico de una manera interativa y entertenida es fundamental para el 
desarrollo del proceso científico. Hasta este punto hemos hablado en este curso sobre un set
}de herramientas que nos ayudan a hacer ciencia abierta (_open science_):

- R y muchos de sus paquetes
- RStudio
- git
- GitHub
- RMarkdown

RMarkdown, en particular, es increiblemente potente para crear reportes científicos, sin embargo
hasta ahora no hemos llegado ni a rozar en su verdaro potencial para compartir nuetro trabajo
con colaboradores.

En esta leccion, vamos a tomar un repositorio ya existente en GitHub y lo transformaremos en un 
sitio web elegante y simple de leer usando algunas de las herramientas que hemos aprendido en este 
curso.

## Un ejemplo básico

- En RStudio, cree im archivo nuevo al nivel tope se su repositorio **git** llamado `index.Rmd`. 
La forma más simple de hacer esto es a través del menú de RStudio. Elija File -> New File -> RMarkdown...
Esto abrirá una caja de dialogo. Usted debe crear un "Document" en formato "HTML". Estas son las 
opciones por defecto.
- Abra `index.Rmd` (si es que no está y abierto)
- Haga clic en _Knit_
    - Vea la salida que se genera
    - Note que se ha creado un nuevo archivo `index.html` en el mismo directorio. Este es el resultado
    en HTML (página web) creado a partir del documento RMarkdown 
- Commit sus cambios (ambos archivos, index.Rmd e index.html)
- Abra su navegador web en la página www.GitHub.com de su repositorio
- Vaya a Settings > GitHub Pages y active _GitHub Pages_ para la rama (branch) `master`

    Ahora la versión del sitio web rendered de su repositorio se va a mostrar en un URL special.
    
    GitHub Pages sigue una convensión como esta:
    
     ```
     https://{username}.github.io/{repository}/
     https://cornejotux.github.io/claseRMarkdown/
     ```
     
    Ponga atención que ahora sitio no está en github.com si no que en github.io. 
     
- Vaya a https://{username}.github.io/{repo_name}/ (Hay que poner el `/` al final!)
    Y vea la versión generada de su sitio web.
    

## Un ejemplo ya no tan básico

Ahora que ha hemos visto como crear una página web desde RMarkdown, vamos a crear un sitio web que usa
algunas funcionalidad geniales que estan disponibles en R. Vamos a seguir usando el mismo repositorio 
git y RStudio Project de arriba, pero vamos a agregar algunos archivos al repositorio y a modificar el 
documento `index.Rmd`.

Primero tenemos que obtener datos. Vamos a re-usar los datos sobre el retorno para desove de salmones 
de Alaska disponible desde la base de datos OceanAK del Departamente de Pesca y Casa de Alaska (ADF&G):

- Navegue a [Escapement Counts](https://doi.org/10.5063/F1S46Q6M) (o visite el sitio KNB y busque por 
'oceanak') y copie el Download URL para el archivo `ADFG_firstAttempt_reformatted.csv`
- Descargue el archivo en R usando `read.csv` para hacer portable el código
- Calcule el escape anual (se refiere al numero de peces que no son capturados por la pesquería) por
especie y región usando el paquete `dplyr`
- Haga un gráfico de barrar para el escape anual por especie usando el paquete `ggplot2`
- Muestre los datos en una tabla interactica usando la función `datatable` diponible en el parquete `DT`
- Haga un mapa interactivo, tipo Google Maps, de los lugars donde se muestreó el escape

Para hacer esto, vamos a usar el paquete [`leaflet`](https://rstudio.github.io/leaflet/) para crea un 
mapa interactivo con marcadores en cada lugar de muestro:

Primero, cargams todos los paquetes que vamos a usar:

```{r load_packages, message = F, warning = F}
  library(leaflet)
  library(dplyr)
  library(tidyr)
  library(ggplot2)
  library(DT)
  library(sf)
  library(ggmap) # devtools::install_github("dkahle/ggmap")
```

### Carga de datos sobre escape de salmones

Puede leer los datos en forma directa desde el repositorio de datos de [KNB](https://knb.ecoinformatics.org/),
si es que no la tiene ya en su computador:

```{r read_data}
data_url <- "https://knb.ecoinformatics.org/knb/d1/mn/v2/object/urn%3Auuid%3Af119a05b-bbe7-4aea-93c6-85434dcb1c5e"

esc <- tryCatch(
    read.csv("data/escapement.csv", stringsAsFactors = FALSE),
    error=function(cond) {
        message(paste("Archivo de escape de salmos no existe, descarguelo desde KNB."))
        esc <- read.csv(url(data_url, method = "libcurl"), stringsAsFactors = FALSE)
        return(esc)
    }
)

head(esc)
```

### Gráficos estáticos

Ahora que ya tenemos los datos, calculemos el escape anual por especie y región:

```{r mean_esc}
annual_esc <- esc %>% 
  separate(sampleDate, c("Year", "Month", "Day"), sep = "-") %>% 
  mutate(Year = as.numeric(Year)) %>% 
  group_by(Species, SASAP.Region, Year) %>% 
  summarize(escapement = sum(DailyCount)) %>% 
  filter(Species %in% c("Chinook", "Sockeye", "Chum", "Coho", "Pink"))

head(annual_esc)
```

Este fragmento de código usa varios de los comandos de `dplyr` que ya hemos visto y algunos otrs nuevos. 
La función `separate` es usada para dividir la columna _sampleDate_ en las columnas Year, Month y Day,
las que luego usamos en `group_by` para indicar que queremos calcular nuestros resultados para las
combinaciones únicas de _species_, _region_ y _year_.  A continuación usamos `summarize` para calcular 
los valores de escape para cada uno de estos grupos. Finalmente, usamos un filtro y el operador `%in%`
para seleccionar solo las especies de salmones.

Ahora vamos a hacer un gráficos con los resultados usando `ggplot`. `ggplot` usa _estéticas_ de mapeo 
(definidas usando `aes()`) y _geometrías_ para crear el gráfico. Adicionalmente a geometrías/estéticas
se pueden agregar a `ggplot` elementos de temas usando el operador `+`.

```{r plot_esc}
ggplot(annual_esc, aes(x = Species, y = escapement)) +
  geom_col()
```

¿Qué pasa si queremos que las barras sean azules en vez de grises? Se podría pensan que se puede hacer 
lo siguiente:

```{r}
ggplot(annual_esc, aes(x = Species, y = escapement, fill = "blue")) +
  geom_col()
```

¿Qué pasó en este gráfico?

Se puede ver que tratamos de definir el color del gráfido dentro del llamado a la estética del mapeo. 
Lo que hemos hecho, detras de la escea, es crar una columna llena con la palana "blue" en el `data.frame`
que usar `ggplot` y posteriormente fue mapeado a la estetica `fill`, que finalmente seleccionó el color
por defecto rojo para llenar las columnas. 

Lo que realmente querimoas hacer era cambiar el color de las barras. Para hacer esto debemos llamar
la opción del color dentro de la función `geom_bar` **fuera** de la llamada a la función estética del 
mapeo.

```{r}
ggplot(annual_esc, aes(x = Species, y = escapement)) +
  geom_col(fill = "blue")
```

¿Y si ahora queremos mapear el color de la barras basado en una variable, por ejemplo región?

`ggplot` es muy poderoso porque permite hacer facilmente un gráfico que muestre estos aspectos de los datos.

```{r}
ggplot(annual_esc, aes(x = Species, y = escapement, fill = SASAP.Region)) +
  geom_col()
```

Aquí hay un ejemplo con una estética y geometría de mapeo diferente que podemos usar con estos datos. Se
puede ademas agregar un título, ajustar las etiquetas e incluis un tema.

```{r}
ggplot(filter(annual_esc, SASAP.Region == "Kodiak"), aes(x = Year, y = escapement, color = Species)) + 
    geom_line() +
    geom_point() +
    ylab("Escapement") +
    ggtitle("Kodiak Salmon Escapement") +
    theme_bw()
```

Fíjese que agregé un filto a la llamada de la función `ggplot` ára solo graficar los datos de la 
isla Kodiak. Se puede facilmente creat fráficos como este para cada región usando `facet_wrap`.

```{r}
ggplot(annual_esc, aes(x = Year, y = escapement, color = Species)) + 
    geom_line() +
    geom_point() +
    facet_wrap(~SASAP.Region, scales = "free_y") +
    ylab("Escapement") +
    theme_bw()

```

### Mapas interactivos

Ahora vamos a convertir los datos de espae en una tabla donde tengamos una única fila para
cada lugar de muestro:

```{r uniq_locations}
locations <- esc %>% 
  distinct(Location, Latitude, Longitude) %>% 
  drop_na()
```

Ahora lo desplegamos en una tabla interactiva:

```{r display_locations}
datatable(locations)
```

Y luego hacer una mapa _leaflet_ el que requiere (generalmente) sólo un par de lineas de código:

```{r simple_map}
leaflet(locations) %>% 
  addTiles() %>% 
  addMarkers(~ Longitude, ~ Latitude, popup = ~ Location)
```

La función `addTiles()` obtene la capa base desde [OpenStreetMap](https://www.openstreetmap.org/) 
que es una altenativa de código abiert a Google Maps. 
`addMarkers` usa una sintaxis un poco rara en comparción a la que acabamos de ver con `ggplot2`, usar 
`~` antes de los nombers de columnas.
Esto es similar a como tabaja la función `lm` (y agunas otras), es necesario que usted se asegure 
de usar `~` para que su mapa funcione.

También es posible usar `leaflet` para important capas desde Web Map Service (WMS). Aquí hay un ejemplo
que utiliza una capa del mapa batimétrico general de los oceanos [(GEBCO)](https://www.gebco.net/data_and_products/gebco_web_services/web_map_service/#getcapabilities) WMS.
En este ejemplo ademas demostramos como crear un marcados circular más simple.

```{r}
leaflet(locations) %>% 
  addWMSTiles("https://www.gebco.net/data_and_products/gebco_web_services/web_map_service/mapserv?",
              layers = 'GEBCO_LATEST',
              attribution = "Imagen producida desde la grilla GEBCO_2014, versión 20150318, www.gebco.net") %>%
  addCircleMarkers(lng = ~Longitude,
                   lat = ~Latitude,
                   popup = ~ Location,
                   radius = 5,
                   # set fill properties
                   fillColor = "salmon",
                   fillOpacity = 1,
                   # set stroke properties
                   stroke = T,
                   weight = 0.5,
                   color = "white",
                   opacity = 1)
```

Leaflet tiene una tonelada de funcionalidades que permites crear mapas muy elegantes y funcionales con facilidad.
[Aquí](https://pages.github.nceas.ucsb.edu/NCEAS/sasap-data/language_vis.html) hay un ejemplo de algunos mapas
que fueron creados como parte del proyecto SASAP (Estado del Salmon de Alaska y Su Gente) usando las mismas
herramientas que acabamos de aprender. Este mapa idealmente le da una idea de cuan poderosa puede ser la 
combinación de RMarkdown y las páginas de GitHub. 

## Mapas estáticos con `ggplot` y `geom_sf`

We can also create a similar static map using `ggplot` with the `geom_sf` geometry. To
do so, first we need to transform our locations data frame into an `sf` object by
providing the coordinate reference system (EPSG:4326 is the CRS for geocoordinates in WGS84).
We also transform the points to `EPSG:3857` which is the CRS used for rendering 
maps in Google Maps, Stamen, and OpenStreetMap, among others.

```{r}
locations_sf <- locations %>%
  st_as_sf(coords = c("Longitude", "Latitude"), crs = 4326)
locations_sf_3857 <- st_transform(locations_sf, 3857)
```

Next, let's grab a base map from the Stamen map tile server covering the region of interest.
This includes a fix to transform the bounding box (which starts in `EPSSG:326`) to also be in the `EPSG:3857` CRS,
which is the projection that the map raster is returned in from Stamen.


```{r message=FALSE}
# Define a function to fix the bbox to be in EPSG:3857
# See https://github.com/dkahle/ggmap/issues/160#issuecomment-397055208
ggmap_bbox_to_3857 <- function(map) {
  if (!inherits(map, "ggmap")) stop("map must be a ggmap object")
  # Extract the bounding box (in lat/lon) from the ggmap to a numeric vector, 
  # and set the names to what sf::st_bbox expects:
  map_bbox <- setNames(unlist(attr(map, "bb")), 
                       c("ymin", "xmin", "ymax", "xmax"))
  
  # Coonvert the bbox to an sf polygon, transform it to 3857, 
  # and convert back to a bbox (convoluted, but it works)
  bbox_3857 <- st_bbox(st_transform(st_as_sfc(st_bbox(map_bbox, crs = 4326)), 3857))
  
  # Overwrite the bbox of the ggmap object with the transformed coordinates 
  attr(map, "bb")$ll.lat <- bbox_3857["ymin"]
  attr(map, "bb")$ll.lon <- bbox_3857["xmin"]
  attr(map, "bb")$ur.lat <- bbox_3857["ymax"]
  attr(map, "bb")$ur.lon <- bbox_3857["xmax"]
  map
}

bbox <- c(-170, 52, -130, 64)   # This is roughly southern Alaska
ak_map <- get_stamenmap(bbox, zoom = 4)
ak_map_3857 <- ggmap_bbox_to_3857(ak_map)
```

 Finally, plot both the base raster map with the points overlayed, which is easy now
 that everything is in the same projection (3857):

```{r message=FALSE}
ggmap(ak_map_3857) + 
  geom_sf(data = locations_sf_3857, inherit.aes = FALSE)
```

## Resources

- Lisa Charlotte Rost. (2018) [Why not to use two axes, and what to use instead: The case against dual axis charts](https://blog.datawrapper.de/dualaxis/)

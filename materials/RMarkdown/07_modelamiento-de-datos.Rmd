# Modelamiento de datos y datos ordenados

## Objetivos

- Entender los conceptos básicos de modelos de datos relacionales, tambien conocidos como datos ordenados (tidy data)
- Aprender a diseñar y crear tablas de datos efectivas

## Beneficios de los sistemas de datos relacionales

- Poderoso sistema de filtrado y búsqueda
- Manejo de set de datos grandes y complejos
- Oblica a la integridad de datos
- Disminulle los errores producto de las actualizaciones redundantes

## Organización de datos

```{r excelOrg1, echo=FALSE, out.width = '100%', fig.align = 'center', fig.cap = 'Planilla excel infernal.'}
knitr::include_graphics("images/7.1_excel-org-01.png")
```

## Tablas múltiples

```{r excelOrg2, echo=FALSE, out.width = '100%', fig.align = 'center', fig.cap = 'Múltiples tablas en una misma planilla. Otro caso de un excel infernal.'}
knitr::include_graphics("images/7.2_excel-org-02.png")
```

## Observaciones inconsistentes

```{r excelOrg3, echo=FALSE, out.width = '100%', fig.align = 'center', fig.cap = 'Observaciones diferentes en una misma fila de la tabla. Otro caso de un excel infernal.'}
knitr::include_graphics("images/7.3_excel-org-03.png")
```

## Inconsistencia en las variables

```{r excelOrg4, echo=FALSE, out.width = '100%', fig.align = 'center', fig.cap = 'Variables diferentes en la misma columna.'}
knitr::include_graphics("images/7.4_excel-org-04.png")
```

## Estadísticas y sumas al margen

```{r excelOrg5, echo=FALSE, out.width = '100%', fig.align = 'center', fig.cap = 'Valores que pueden ser calculados partir de los datos de la tabla. Otra mala práctica.'}
knitr::include_graphics("images/7.5_excel-org-05.png")
```

## Modelamiento de datos adecuado

### Datos DeNormalizados

- Observaciones de diferentes entidadaes en forma combinada

```{r tableDenorm1, echo=FALSE, out.width = '100%', fig.align = 'center', fig.cap = 'Valores obtenidos en diferentes entidades en la misma fila.'}
knitr::include_graphics("images/7.6_table-denorm.png")
```

En el ejemplo presentado en la figura \@ref(fig:tableDenorm1), se puede ver 
como cada columna tiene información tanto de los sitios (`site`) donde se 
registraron las observaciones, asi como de 2 individuos, aparentemente de 
diferentes especies, que fueron encontrados en el sitio. Estos son datos _no_
*normalizados*.

La gente se refiere comunmente a esto como **formato ancho** o de 
**mantel de cocina**, porque las observaciones estan repartidas a lo ancho
de las columnas.  Notece que si encuentra una nueva especie en un 
muestreo, tendríamos que agregar una nueva columna en la tabla. Esto es
muy dificil de analizar, entender y mantener.

### Datos tabulares

__Observaciones__. Una forma mucho mas efectiva de modelas datos es organizando
las observaciones acerca de cada tipo de entidad en su propia tabla. Esto resulta
en:

- tablas separadas para cada entidad medida
- Cada fila representa una única observación de la entidad
- Las observaciones (filas) son únicas
- Estp es datos *normalizados* (*tidy data*)

__Variables__. Además, en el caso de datos normalizados, podemos esperar que 
las variables estén organizada de tal forma que:

- Todos los valores enu na columna representan lo mismo
- Todas las columnas pertecne a la misma entidad observada (ej. fila)
- Cada columna representa o una variable identificadora o una variable medida

En la figura \@ref(fig:tableNorm2) hay un ejemplo de datos normalizados. En la figura,
la primera tabla se refiere a la colección de datos sobre los individuos de varias 
especies y la segunda tabla son las observaciones que contiene las
propiedades de los sitios donde las especies estaban presentes.

```{r tableNorm2, echo=FALSE, out.width = '100%', fig.align = 'center', fig.cap = 'Ejemplo de tablas con datos normalizados.'}
knitr::include_graphics("images/7.7_tables-norm.png")
```

## Claves primarias y foraneas

Cuando se usan datos nornalizados, es común usar identificadores únicos para 
hacer referencia a observaciones particulares, esto nos permite hacer uniones 
entre dos o más tablas. Los dos tipos de identificadores que se usan 
comúnmente con datos relacionales son:

- Clave primaria: Identificados único para cada una de las observaciones de la entidad,
es uno por fila
- Clave foranea: Esto hace referencia una clave primaria que está en otra tabla
(referencia para unir)

Por ejemplo, en la segunda tabla de la figura \@ref(fig:tableNorm3), la columna
`site` es la **clave primaria** (primary key) de esa tabla. La puede identificar
como tal porque es un identificador único para una observación realizada en un 
sitio y que corresponde a una fila de la tabla. En la primera tabla, sin embargo, 
la columna sitio (`site`) es una **clave foranea** (foreign key) que hace refencia
a la clave primaria presente en la segunda tabla. Esta unión nos dice que 
la primera medición de la altura (height) para la especie `DAPU` se realizó en el 
sitio con el nombre `Taku`.

```{r tableNorm3, echo=FALSE, out.width = '100%', fig.align = 'center', fig.cap = 'Explicación de la relación entre clave primaria y foranea entre dos tablas con datos normalizados.'}
knitr::include_graphics("images/7.8_tables-keys.png")
```

## Modelo de Relación-Entidad

Un modelo de Relación-Entidad nos permite dibujar en forma compacta la estructura
de las tablas en una base de datos relacional, incluyendo las claves primaria y 
foraneas de las tablas.

```{r modeloRE, echo=FALSE, out.width = '70%', fig.align = 'center', fig.cap = 'Representación gráfica de una relación-entidad de dos tablas, incluyendo las claves con que se unen..'}
knitr::include_graphics("images/7.9_plotobs-diagram.png")
```

En el modelo presentado en la figura \@ref(fig:modeloRE), se puede ver que cada
sitio en la tabla `SITES` **debe** tener uno o más observaciones en la tabla 
`PLOTOBS`, doned cada `PLOTOBS` tiene un y **solo un** `SITE`.

## Combinando datos

Frecuentemente, lo análisis de datos van a requiere que se combinen estas
tablas que se manejan en forma separada. Esto se puede hacer de múltiples
formas y estas uniones van a depender de como estas tablas se relación 
(fig. \@ref(fig:sqlJoins)).

Cuando se conceptualizan las uniones, uno puede pensar en dos tablas, una 
en la **izquierda** (left) y otra en la **derecha** (right). La unión más 
común (generalmente usada) es cuando se combina un subgrupo de filas que 
tienen parejas en ambas tablas (a la izquierda y derecha): esto se conoce 
como **INNER JOIN** (unión interna). Existen otros tipos de uniones posibles
también. Un **LEFT JOIN** (unión a la izquierda), toma todas las filas de 
la tabla a la izquierda y las combina con los datos que se emparejan en la 
tabla a la derecha. Un **RIGHT JOIN** (unión a la derecha) es lo mismo, sólo
que en este caso se mantienen todas las filas presentes en la tabla de la 
derecha y se agregarn aquellas que tienen parejas en la izquierda. Finalmente,
un **FULL OUTER JOIN** (unión total) incluye todas las filas en ambas tablas,
esta union en muy pocas veces práctica.

```{r sqlJoins, echo=FALSE, out.width = '80%', fig.align = 'center', fig.cap = 'Las regiones en azul representan las filas que son incluidas en el resultado. Para un INNER join, las filas resultantes son todas las filas en A que tienen una pareja en B.'}
knitr::include_graphics("images/7.10_sql-joins.png")
```

## Simple Guidelines for Effective Data

- Design to add rows, not columns
- Each column one type
- Eliminate redundancy
- Uncorrected data file
- Header line
- Nonproprietary formats
- Descriptive names
- No spaces

- [Borer et al. 2009. **Some Simple Guidelines for Effective Data Management.** Bulletin of the Ecological Society of America.](http://matt.magisa.org/pubs/borer-esa-2009.pdf)
- [White et al. 2013. **Nine simple ways to make it easier to (re)use your data.** Ideas in Ecology and Evolution 6.](https://doi.org/10.4033/iee.2013.6b.6.f)

## Data modeling exercise

- Break into groups, 1 per table

To demonstrate, we'll be working with a tidied up version of a dataset from ADF&G containing commercial catch data from 1878-1997.
The dataset and reference to the original source can be viewed at its public archive: https://knb.ecoinformatics.org/#view/df35b.304.2.
That site includes metadata describing the full data set, including column definitions.  Here's the first `catch` table:

```{r catch, cache=TRUE, echo=FALSE}
library(DT)
catch <- read.csv(url("https://knb.ecoinformatics.org/knb/d1/mn/v2/object/df35b.302.1", method = "libcurl"),
                  stringsAsFactors = FALSE)
datatable(catch)
```

And here's the `region_defs` table:
```{r regions, cache=TRUE, echo=FALSE}
region_defs <- read.csv(url("https://knb.ecoinformatics.org/knb/d1/mn/v2/object/df35b.303.1", method = "libcurl"),
                        stringsAsFactors = FALSE)
datatable(region_defs)
```

- Draw an ER model for the tables
  - Indicate the primary and foreign keys
- Is the `catch` table in normal (aka tidy) form?
  - If so, what single type of entity was observed?
  - If not, how might you restructure the data table to make it tidy?
    - Draw a new ER diatram showing this re-designed data structure

![](images/ERD_Relationship_Symbols_Quick_Reference-1.png)

## Related resources

- [Borer et al. 2009. **Some Simple Guidelines for Effective Data Management.** Bulletin of the Ecological Society of America.](http://matt.magisa.org/pubs/borer-esa-2009.pdf)
- [White et al. 2013. **Nine simple ways to make it easier to (re)use your data.** Ideas in Ecology and Evolution 6.](https://doi.org/10.4033/iee.2013.6b.6.f)
- [Software Carpentry SQL tutorial](https://swcarpentry.github.io/sql-novice-survey/)
- [Tidy Data](http://vita.had.co.nz/papers/tidy-data.pdf)


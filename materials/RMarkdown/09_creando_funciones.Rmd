# Creando funciones de R

Mucha gente escribe los código de R como un flujo simple y continuo de comandos, 
incluso algunas veces sacado directamente de la consola de R y copiado a un 
script con el texto. Si bien cualquier script tiene tremendos beneficios en
por sobre soluciones basadas en el uso del mouse, existen ventajas de usar
códigos en fragmentos pequeños o bien en módulos reusables. Este es el rol
de las funciones (`function`) en R.  En esta clase, vamos a revisar las ventajas
de escribir códigos usando funciones, practicaremos creando algunas funciones
y mostraremos como llamarlas. Finalmente terminaremos con ejercicios donde 
construiremos algunas funciones simples.

## Objetivos

- Aprender por que debemos escribir códigos utilizando funciones pequeñas
- Escribir código para una o más funciones
- Documentar las funciones para explicar su funcionamiento y comunicación del código

## ¿Por qué funciones?

En inglés se usa el acronismo **DRY** que se traduce a _No Se Repita a Si Mismo_
(Don't Repeat Yourself).

Al crear funciones pequeñas y autocontenidas que desarrollan una sola función y 
lo hacen bien, podemos rápidamente ganar:

- Mejoras en el entendimiento del código
- Reuso del código a traves de la decomposición de tareas en fragmentos pequeños
- Mejorar la revisión de erroresImproved error testing

## Conversión de temperatura

Imagine que tiene unos datos de temperatura medidos en grados Fahrenheit y los quiere convertir
a Celsius para realizar los análisis. Puede ser que para este fin usted escriba un código de R
que haga precisamente esto.

```{r}
airtemps <- c(212, 30.3, 78, 32)
celsius1 <- (airtemps[1]-32)*5/9
celsius2 <- (airtemps[2]-32)*5/9
celsius3 <- (airtemps[3]-32)*5/9
```

Note que existe 3 lineas de código duplicado, donde se repime la formula. Este código se puede 
acortar y hacer más confiable sin las repeticiones.

## Creando una función

Las funciones de R son un mecanismo donde se procesa una entrada y se devuelve un valor de salida.
En forma similar a otras variables, las funciones pueden ser asignadaa una una variblae, de esta 
forma puede ser utilizada en diferentes partes del código. Para crear una función en R, se usa la 
función `function` y se asigna su resultado a una variable. Creemos de esta forma una funcón que 
calcule la temperatura en grados celcius cuando se le pasan valores en fahrenheit.

```{r}
fahr_to_celsius <- function(fahr) {
  celsius <- (fahr-32)*5/9
  return(celsius)
}
```

Al ejecutar este código, hemos creado una función y la hemos almacenado en el ambiente global de R.
El arugmento `fahr` de la función `function` indica que la función que hemos creado toma un único
parámetro (la temperatura en fahrenheit) y la declaración `return` indica que la función debe
devolver el valor almacenado en la variable `celsius` que fue calculado dentro de la función.
Usemoa ahora la función y veamos si obtenemos los mismos valores:

```{r}
celsius4 <- fahr_to_celsius(airtemps[1])
celsius4
celsius1 == celsius4
```

¡Excelente!.  Entonces ahora tenemos una función que convierte los grados que podemos usar. Note que, 
porque la mayoría de las operaciones en R pueden tomar múltiples tipos de entradas, podemos pasarle
el vector original de `airtemps` y calcular todos los resultados al mismo tiempo:

```{r}
celsius <- fahr_to_celsius(airtemps)
celsius
```

De esta forma, toma el vector de temperaturas en fahrenheit y devuelve el vector de temperaturas en grados 
celsius.

## Actividad

Now, create a function named `celsius_to_fahr` that does the reverse, it takes temperature data in celsius as input, and returns the data converted to fahrenheit.  Then use that formula to convert the `celsius` vector back into a vector of fahrenheit values, and compare it to the original `airtemps` vector to ensure that your answers are correct.

```{r}
# Your code goes here
```

Did you encounter any issues with rounding or precision?

## Documenting R functions

Functions need documentation so that we can communicate what they do, and why.  The `roxygen2` package provides a simple means to document your functions so that you can explain what the function does, the assumptions about the input values, a description of the value that is returned, and the rationale for decisions made about implementation.

Documentation in ROxygen is placed immediately before the function definition, and is indicated by a special comment line that always starts with the characters `#'`.  Here's a documented version of a function:

```{r}
#' Convert temperature data from Fahrenheit to Celsius
#'
#' @param fahr Temperature data in degrees Fahrenheit to be converted
#' @return temperature value in degrees Celsius
#' @keywords conversion
#' @export
#' @examples
#' fahr_to_celsius(32)
#' fahr_to_celsius(c(32, 212, 72))
fahr_to_celsius <- function(fahr) {
  celsius <- (fahr-32)*5/9
  return(celsius)
}
```

Note the use of the `@param` keyword to define the expectations of input data, and the `@return` keyword for defining the value that is returned from the function.  The `@examples` function is useful as a reminder as to how to use the function.  Finally, the `@export` keyword indicates that, if this function were added to a package, then the function should be available to other code and packages to utilize.

## Summary

- Functions are useful to reduce redundancy, reuse code, and reduce errors
- Build functions with the `function` function
- Document functions with `roxygen2` comments

# Herramientas: RStudio - Git/GitHub Configuración y Motivación

## Por que usar git?

### El problema con los nombres de archivos

```{r finalDoc, echo=FALSE, out.width = '100%', fig.align = 'center', fig.cap = 'El dilema de usar nombres como descriptor de versiones.'}
knitr::include_graphics("images/3.1_phd_comics_final.png")
```

Cada archivo en un proceso científico sufre de cambios. Los manuscritos son editados.
Las figuras son revisadas. Los códigos se corrigen cuando se encuentran problemas. Los
archivos de datos se combinan, errores son corregidos, se dividen y combinan nuevamente.
En el curso de un análisis simple, uno puede esperar miles de cambios en los archivos. 
Y aún así, todo lo que usamos para identificas este sinnúmero de cambios son los 
simples **nombres de archivos** (fig. \@ref(fig:finalDoc)). Teniendo esto en consideración, es lógico pensar que 
debe existir una forma mejor... Y si la hay, se conoce como __Control de Versiones__.

Un sistema de control de versiones ayuda a seguir todos lo cambios que se realizan a
nuestros archivos, sin el desastre que resulta utilizando sólo el nombre de archivos.
En los sistemas de control de versiones como `git`, el sistema registra no solo el 
nombre del archivo, si no que además su contenido, de esta forma, cuando el contenido 
cambia, permite identificar que partes estaban y donde. Registra además que versión de 
un archivo viene de una versión previa, de esta forma se tiene un historial de todos
los cambios. De esta forma es fácil dibujar un gráfico que muestre todos los cambios
que ha sufrido un archivos, con todas sus versiones, algo como lo que se muestra en la 
figura:

```{r figVersiones, echo=FALSE, out.width = '40%', fig.align = 'center', fig.cap = 'Evolución de las versiones de un archivo.'}
knitr::include_graphics("images/3.2_version-graph.png")
```

Los sistemas de control de versiones asignan un identificador a cada versión de cada 
archivo y mantiene un registro de como están relacionados entre ellos. Además, estos
permiten ramificaciones en esas versiones, permitiendo fusiones de esas ramificaciones
de regreso a la tronco principal de trabajo. Estos sistemas permiten
ademas tener *múltiples copias* en múltiples computadores como respaldos y para trabajar
en colaboración. Finalmente, además se puede incluir etiquetas (tags) a versiones 
en particular, de esta forma es fácil retornar a la versión que tenían los archivos 
cuando fueron etiquetados. Por ejemplo, la versión exacta de los datos, código y texto
de un manuscrito que fue enviado y que tiene la etiqueta `R2` en la figura \@ref(fig:figVersiones).

## Revisando el ambiente de RStudio

### Versión de R

Vamos a usar `r R.version.string`, que puede ser descargada e instalada desde [CRAN](https://cran.rstudio.com). Para ver que versión tiene instalada, ejecute el siguiente comando en la consola de RStudio:

```
R.version$version.string
```

### Versión de RStudio

Vamos a usar la versión de RStudio 1.2.1335 o posterior, la que se puede descargar e instalar [aquí](https://www.rstudio.com/products/rstudio/download/). Para verificar que versión de RStudio tiene instalada, ejecute el siguiente comando en la consola de RStudio:

```
RStudio.Version()$version
```

Si el resultado no dice `1.2.1335` (o es una version anterior), por favor actualice su RStudio. Esto lo puede hacer haciendo click en "Help -> Check for Updates" y siguiendo las indicaciones.

### Instalación de Paquetes de R

Ejecute las siguientes lineas para verificar que todos los paquetes necesarios para este curso están instalados en su computador.

```{r, eval = F}

packages <- c("devtools", "dplyr", "DT", "ggplot2", "leaflet", "roxygen2", "tidyr")
for (package in packages) { if (!(package %in% installed.packages())) { install.packages(package) } }

rm(packages) #Elimina los paquetes desde el entorno de trabajo

```

Si hay algún paquete que no esté instalado, esto va a instalarlo automáticamente. Si ya 
estuvieran  instalados, no hará nada.

A continuación, cree un nuevo archivo de _R Markdown_ (File -> New File -> R Markdown). Si nunca 
ha creado archivo R Markdown con anterioridad, aparecerá un diálogo preguntando si desea instalar los paquetes requeridos. Haga click en Yes.


## Configurando git

Si no lo ha hecho ya, vaya a [github.com](http://github.com) y cree una cuenta. Si aun no ha bajado
e instalado el software de git, descárgelo [aquí](https://git-scm.com/downloads) y proceda a su instalación.

Antes de usar _git_, tiene que decirle quien es Ud., para eso debemos establecer la opciones de 
configuración globales (setting the global options). Lamentablemente, la única forma de hacer 
esto es por medio de la linea de comando. La versión RStudio que tiene instalada (si es que siguió las instrucciones de este curso) tiene una característica muy útil, que le permite abrir una ventana de terminal en su sesión de RStudio. Haga esto seleccionando Tools -> Terminal -> New Terminal.

Una pestaña de terminal debería abrirse donde se encuentra normalmente la consola de R. Para estableces las opciones de configuración global, escriba los siguiente comando en la pestaña del terminal, reemplazando "_Su Nombre_" por su nombre real y luego presione enter:

```
git config --global user.name "Su Nombre"
```

Luego escriba la siguiente linea, con la dirección de correo electrónico que usó cuando creó la cuenta en github.com:

```
git config --global user.email "SuEmail@DominioEmail.cl"
```

Por favor note que estas lineas DEBEN ser ejecutada una a la vez.

Finalmente, para asegurarse que todo está correcto, escriba esta linea, que entrega las
opciones que acaba de definir.

```
git config --global --list
```

### Nota para Usuario de Windows

Si obtienen el mensaje "comando no encontrado" ("command not found" o similar) cuando trate estos pasos en la pestaña del terminar de RStudio, puede ser que necesite definir  el tipo de terminal
que abre RStudio. Bajo algunas instalaciones de git, puede darse que el ejecutable de git no funcione base el terminal que se abre por defecto.

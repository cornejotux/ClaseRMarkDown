
# Control de versiones con git y GitHub

## Objetivos

En esta lección usted aprenderá:

- ¿Por qué __git__ es útil para analisis reproducibles?
- ¿Cómo usar __git__ para controlar los cambios que se hacen en el tiempo?
- ¿Cómo usar __GitHub__ para colaboración?
- ¿Cómo estructurar los "_commits_" para que los cambios sean claros para otros?
- ¿Cómo escribir mensajes de "_commits_" que sean efectivos?

## El problema con los archivos de nombre

```{r finalDoc2, echo=FALSE, out.width = '100%', fig.align = 'center', fig.cap = 'El dilema de usar nombres como descriptor de versiones.'}
knitr::include_graphics("images/3.1_phd_comics_final.png")
```

Cada archivo en un proceso científico sufre de cambios. Los manuscritos son editados. Las figuras son 
revisadas. Los códigos se corrigen cuando se encuentran problemas. Los archivos de datos se combinan, 
errores son corregidos, se dividen y combinan nuevamente. En el curso de un análisis simple, uno puede 
esperar miles de cambios en los archivos. Y aún así, todo lo que usamos para identificas este sinnúmero 
de cambios son los simples **nombres de archivos** (fig. \@ref(fig:finalDoc2)). Teniendo esto en consideración, es lógico 
pensar que debe existir una forma mejor… Y si la hay, se conoce como **Control de Versiones**.


Un sistema de control de versiones ayuda a seguir todos lo cambios que se realizan a nuestros 
archivos, sin el desastre que resulta utilizando sólo el nombre de archivos. En los sistemas de 
control de versiones como `git`, el sistema registra no solo el nombre del archivo, si no que 
además su contenido, de esta forma, cuando el contenido cambia, permite identificar que partes 
estaban y donde. Registra además que versión de un archivo viene de una versión previa, de esta 
forma se tiene un historial de todos los cambios. De esta forma es fácil dibujar un gráfico 
que muestre todos los cambios que ha sufrido un archivos, con todas sus versiones, algo como 
lo que se muestra en la figura \@ref(fig:figVersiones2):


```{r figVersiones2, echo=FALSE, out.width = '40%', fig.align = 'center', fig.cap = 'Evolución de las versiones de un archivo.'}
knitr::include_graphics("images/3.2_version-graph.png")
```

Los sistemas de control de versiones asignan un identificador a cada versión de cada 
archivo y mantiene un registro de como están relacionados entre ellos. Además, estos
permiten ramificaciones en esas versiones, permitiendo fusiones de esas ramificaciones
de regreso a la tronco principal de trabajo. Estos sistemas permiten
ademas tener *múltiples copias* en múltiples computadores como respaldos y para trabajar
en colaboración. Finalmente, además se puede incluir etiquetas (tags) a versiones 
en particular, de esta forma es fácil retornar a la versión que tenían los archivos 
cuando fueron etiquetados. Por ejemplo, la versión exacta de los datos, código y texto
de un manuscrito que fue enviado y que tiene la etiqueta `R2` en la figura \@ref(fig:figVersiones2).

## Control de versiones y colaboración usando Git and GitHub

Hagamos la distición entre **git** y **GitHub**.

- __git__: Software the control de versones que se usa para monitorear los archivos de un 
directorio (un repositorio)
    - git crea el historial de versiones de un repositorio
- __GitHub__: Sitio web que permite a usuarios almacenar sus repositorios git y compartilos
con otros

```{r gitExplicado, echo=FALSE, out.width = '60%', fig.align = 'center', fig.cap = 'Diferencia entre git y GitHub.'}
knitr::include_graphics("images/6.3_vc-local-github.png")
```


## Veamos un repositorio de GitHub

El pantallaso en la figura \@ref(fig:webGitHub) muestra una copia de un repositorio 
almacenado en GitHub, con el listado de archivos, cuando se modificaron los archivos 
y directorios y laguna información acerca de quien hizo los cambios más recientes.

```{r webGitHub, echo=FALSE, out.width = '100%', fig.align = 'center', fig.cap = 'Captura de pantalla de un repositorio en GitHub.'}
knitr::include_graphics("images/6.4_ss3sim-github.png")
```

Si nos metemos en los "commits" del repositorio (fig. \@ref(fig:githubCommits)), podemos 
que que la historia de los
cambios que se le han realizado a todos los archivos.  Se puede ver que `kellijohnson`
y `seananderson` arreglaron algunas cosas durante junio y julio:

```{r githubCommits, echo=FALSE, out.width = '100%', fig.align = 'center', fig.cap = 'Captura de pantalla de los Commits de un repositorio en GitHub.'}
knitr::include_graphics("images/6.5_ss3sim-commits.png")
```

Y finalmente, si vemos ahora los cambios realizado el 13 de julio (fig. \@ref(fig:githubDiferencias)),
se puede exactamente cuales fueron los cambios realizados a cada archivo:

```{r githubDiferencias, echo=FALSE, out.width = '100%', fig.align = 'center', fig.cap = 'Captura de pantalla donde se presentan las diferencias entre dos versiones alojadas en un repositorio de GitHub.'}
knitr::include_graphics("images/6.6_ss3sim-diff.png")
```

Monitorear estos cabmios, como se relacionan a cada las versiones de un software en 
particular y a los archivos es exactamente para lo que fueron diseñados git y 
GitHub. Vamos a mostrar como pueden ser realmente efectivos para monitorear 
versiones de códigos científicos, figuras y manuscritors para lograr tener
flujos de trabajo reproducibles.

## El ciclo de vida de Git

Como usuario de git usted tiene que entener algunos conceptos básicos
asociados a los set de cambios con versiones y como estos son almacenado y 
se mueven a traves del repositorio.  Cualquier repositorio de git puede ser
clonado, de esta forma existe en forma local y remota. Pero cada uno de estos
repositorios clonados son una copia simple de todos los archivos y el historial
de cambios de ellos, almacenados en un forma git particular. Para
nuestros propósitos, tenemos que considerar un repositorio de git 
simplemente un un directorio que contiene adicionalmente un set de 
metadatos relacionado con las versiones.

En un directorio local donde git fue habilitado, el directorio contiene la 
versíon actual de todos los archivos del repositorio. Estos archivos de trabajo
están unidos a un directorio escondido que contiene el 'Repositorio local', 
el que a su vez contiene todos los otros cambios que se han realizado a los
archivos y los metadatos sobre las versiones.

De esta forma, cuando se está usando git para trabajar con archivos, se pueden 
usar los comando de git para indicar específicamente que cambios a los archivos
de trabajo deben ser definidos para las versiones (usando el comando `git add`)
y cuando grabar estos cambios como una versión en el repositorio local (usando
el comando `git commit`).

Los demás conceptos se relacionan a la sincronización de los cambios en el 
repositorio local a un repositorio remoto. El comando `git push` se usar para
enviar los cambios realizados en forma local a un repositorio remoto (posiblemente
en GitHub) y el comando `git pull` es usado para traer los cambios del repositorio
remoto y unirlos al repositorio local.


```{r gitFlowChart, echo=FALSE, out.width = '70%', fig.align = 'center', fig.cap = 'Diagrama de flujo del ciclo de vida de git.'}
knitr::include_graphics("images/6.7_git-flowchart.png")
```


- `git clone`: Copia tod el repositorio remoto a uno local
- `git add` (stage): Notifica a git de monitorear un set particular de cambios
- `git commit`: Almacena los cambios realizados como una versión
- `git pull`: Combina los calbios de un repositorio remoto a nuestro repositorio local
- `git push`: Copia los cambios de nuestro repositorio local al repositorio remoto
- `git status`: Determina el estado de los archivos en el repositorio local
- `git log`: Imprime el historial de cambios en el repositorio

Estos siete comando con la mayoría de los que usted va a necesitar para utilizar git en forma
exitosa. Pero todo esto es demasiado abstracto, mejor exploremos estos conceptos utilizando
ejemplos reales.

## Cree un repositorio remoto en GitHub

Empecemos creando un repositorio en GitHub, luego editemos algunos archivos.

- Ingrese al sitio [GitHub](https://github.com)
- Clic en el botor de repositorio nuevo (New repository)
- Nombrelo como `sasap-test`
- Cree un archivo README.md
- Defina la licencia a Apache 2.0


```{r githubNewRepo, echo=FALSE, out.width = '100%', fig.align = 'center', fig.cap = 'Captura de pantalla de la creación de un repositorio nuevo en GitHub.'}
knitr::include_graphics("images/6.8_new-repo-github.png")
```

¡Usted acaba de crear su primer repositorio! Tiene un par de archivos que 
GitHub creó por usted, por ejemplo los archivpos README.md, LICENSE y .gitignore.


```{r githubSasapRepo, echo=FALSE, out.width = '100%', fig.align = 'center', fig.cap = 'Captura de pantalla con el repositorio recién creado llamado sasap-test.'}
knitr::include_graphics("images/6.9_sasap-test-repo.png")
```

Para hacer cambios menores a archivos de texto, se puede utilizar la interfase web de GitHub.  For example,
navigate to the `README.md` file in the file listing, and edit it by clicking on the *pencil* icon.
This is a regular Markdown file, so you can just add text, and when done, add a commit message, and 
hit the `Commit changes` button.  

```{r githubSasapEdit, echo=FALSE, out.width = '100%', fig.align = 'center', fig.cap = 'Captura de pantalla con la interfase web de GitHub para la edición de documentos de texto.'}
knitr::include_graphics("images/6.10_sasap-test-edit.png")
```

```{r githubSasapCommit, echo=FALSE, out.width = '100%', fig.align = 'center', fig.cap = 'Captura de pantalla con la interfase web de GitHub para la confirmar de los cambios realizados al documento de texto (commit changes).'}
knitr::include_graphics("images/6.11_sasap-test-commit.png")
```

Felicitaciones, ahora usted acaba de confirmar (commit) los cambios, de esta forma ahora 
es el autor de la primera version de este archivo. Si navega de regreso a la página del 
repositorio GitHub, puede ver la lista de los cambios confirmados (commits) ahi, así como 
la visualisación del documento generado a partir del archivo README.md.

```{r githubSasapDisplayed, echo=FALSE, out.width = '100%', fig.align = 'center', fig.cap = 'Captura de pantalla con la interfase web los cambios corfimados (commits) y de la visualización de la página README.md.'}
knitr::include_graphics("images/6.12_sasap-test-displayed.png")
```

Expliquemos alguas cosas sobre esta ventana. Representa una vista de el repositorio que
acaba de crear, hasta ahora mostrando todos sus archivos. Para cada archivo, muestra
la fecha de la última modificación y el mensaje asociado a la confirmación (commit) que
se utilizó para describir el último cambio realizado en cada archivo. Esta es la razón
de por qué es tan importante escribir buenos mensajes, que contengan información 
relevante cuando se hace el _commit_. Además, el título azul sobre el listado de archivos
muestra el _commit_ más reciente, con su mensaje asociado y su identificados SHA. Ese 
identificador SHA es la clave para el set de versiones. Si hace clic en el identificados 
SHA (*810f314*), va a mostrar los cambios que se hicieron en ese _commit_ en particular.

En la sigguiente seccion vamos a usar el URL de GitHub para el repositorio que creo y 
lo vamos a clonar (`clone`) a nuestra máquina local y así poder editar los archivos con 
RStudio.  Para eso, primero tenemos que copiar el URL de GitHub, que representa la
direccion del repositorio:

```{r githubSasapClone, echo=FALSE, out.width = '100%', fig.align = 'center', fig.cap = 'Captura de pantalla para clonar un repositorio GitHub.'}
knitr::include_graphics("images/6.13_sasap-test-clone-url.png")
```

## Trabajando localmente con Git vía RStudio

RStudio sabe como trabajar con archivos utilizando Git como sistema de control de 
versiones, pero esto **sólo** ocurre si estamos trabajando en un _Proyecto de RStudio_
(RStudio project folder).  En esta seccion vamos a clonar el repositorio que se creo
en GitHuba y lo vamos a dejar un repositorio local de un proyecto de RStudio.  
Esto es lo que vamos a hacer:

1. Crear un proyecto nuevo
1. Inspeccionar el panel Git y el historial de versiones
1. Confirmar una modificación (commit) al archivo README.md
1. Confirmar las modificaciones que hizo RStudio
1. Inspeccionar el historial de versiones
1. Create y confirmar (commit) un archivo Rmd
1. Enviar (_Push_) estos cambios a GitHub
1. Ver el historial de cambios en GitHub

__Crear nuevo Proyecto (Create a New Project).__ Comience creando un *New Project...*
en R Studio, seleccione la opción *Version Control* y pegue el URL de GitHub que
copió en el espacio para repositorio remoto (*Repository URL*). Si bien usted puede
darle el nombre que quiera al repositorio local, se usa típicamente el mismo nombre
que el que se tiene en GitHub, de esta forma se mantene un grado de correspondencia.
Usted puede elegir cualquier directorio para su copia local, en mi caso use el 
directorio `development` (fig. \@ref(fig:githubClone)).

```{r githubClone, echo=FALSE, out.width = '100%', fig.align = 'center', fig.cap = 'Captura de pantalla para la creasción de un proyecto de RStudio clonando un repositorio remoto.'}
knitr::include_graphics("images/6.14_rstudio-clone-repo.png")
```

Un vez que haga clic en `Create Project` (crear proyecto), una nueva página de RStudio
se abrirá con todos los archivos copiados localmente desde el repositorio remoto.  Depending on how your version of RStudio
is configured, the location and size of the panes may differ, but they should all
be present, including a *Git* tab and the normal *Files* tab listing the files that 
had been created in the remote repository.

```{r githubCloneLocal, echo=FALSE, out.width = '100%', fig.align = 'center', fig.cap = 'Captura de pantalla de la interfase del projecto de RStudio con el clon local de repositorio.'}
knitr::include_graphics("images/6.15_rstudio-sasap-test.png")
```

En la figura \@ref(fig:githubCloneLocal) usted puede ver que apareció un  
archivo llamado `sasap-test.Rproj` y que están los otros 3 archivos 
que se crearon con el repositorio en GitHub (`.gitignore`, `LICENSE` y
`README.md`).

En el panel *Git* de RStudio, puede ver que presentan 2 archivos. Este es 
el panel de estatus se muestran todos los archivos del repositorio que tienen
modificaciones. En este caso, el archivo `.gitignore` se muesta con una
*M* que significa Modificado y `sasap-test.Rproj` con un *? ?* para indicar que 
este archivo con están siendo monitoreado. Esto significa que git no tiene
registro de ninguna version para este archivo y que no sabe nada acerca de el.
A medida que usted vaya tomando decisiones sobre el control de versiones en 
RStudio, estos iconos van a ir cambiando para reflejar el estatus de la versión
actual de cada uno de los archivos.

__Inspeccionar el historial (Inspect the history).__ Por ahora, vamos a hacer
clic en el boton *History* (historial), con el que le van a mostar el 
registro de los cambios que han ocurrido y que deben ser idénticos a lo que 
usted vio en GitHub. Al hacer clic en cada fila del historial, podrá ir viendo
exactamente que fue agregado y cambiado en cada uno de los commits en este 
repositorio.

```{r rstudioHistory1, echo=FALSE, out.width = '100%', fig.align = 'center', fig.cap = 'Historial de los cambios realizados en el repositorio local.'}
knitr::include_graphics("images/6.16_rstudio-history-1.png")
```

__Confirme cambios al archivo README.md (Commit a README.md change).__ 
Ahora hagamos algunos cambios al archivo README.md en RStudio. Agregue una 
sección nueva con un block de _markdown_ como este:

<pre><code>

## Git desde RStudio

Desde la interfase de RStudio, es posible hacer las mismas acciones con el 
sistema de versiones que se hicieron hicimos en  GitHub y mucho más. Además 
en RStudio se tienen las ventajas propias de programar en un IDE con completación
de comandos y otras características que hacen nuestro trabajo más fácil.

- Agregar archivos al control de versiones
- Confirmar (commit) cambios
- Empujar confirmaciones (push commits) a GitHub

</code></pre>

Una vez que se haya guardado, pueden ver en forma inmediata el archivo 
*README.md* en el panel Git (fig. \@ref(fig:rstudioPanelStatus)), marcado 
con una **M** de modificación.  Ahora usted
puede seleccionar este archivo en el panel de Git y hacer clic en *Diff* para
ver los cambios (comparando las diferencias) que guardó (note que estos cambios no 
se han confirmado aun a su repositorio local).


```{r rstudioPanelStatus, echo=FALSE, out.width = '100%', fig.align = 'center', fig.cap = 'Panel de estado de los cambios en los archivos.'}
knitr::include_graphics("images/6.17_rstudio-status-pane.png")
```

Y ahora aquí se muestra como se ven los cambios cuando se comparan con el 
archivo original. La líneas nuveas se destacan en color verde y en rojo 
las que fueron eliminadas.

```{r rstudioDiferencias, echo=FALSE, out.width = '100%', fig.align = 'center', fig.cap = 'Ventana que presenta las diferencias entre la versión almacenada en el repositorio y los últimos cambios realizados.'}
knitr::include_graphics("images/6.18_rstudio-diff.png")
```

__Confirmar los cambios en Rstudio (Commit the RStudio changes).__

Para confirmar los cambios que se acaban de hacer en el archivo README.md, 
selecciones la caja de selección *Staged* a lado del nombre del archivo (que
indica a Git cuales son los cambios que quiere sean incluido en la confirmación
o commit), escriba un mensaje de confirmación que describa que se hizo y luego
haga clic en *Commit* (fig. \@ref(fig:rstudioCommit1)).

```{r rstudioCommit1, echo=FALSE, out.width = '100%', fig.align = 'center', fig.cap = 'Captura de pantalla con un mensaje describiendo la confirmación (commit) que se realizará.'}
knitr::include_graphics("images/6.19_rstudio-commit-1.png")
```

Note que algunos de los cambios en el repositorio, `.gitignore` y 
`sasap-test.Rproj`, aun se identificaon que no estan confirmados 
(commited). Esto significa que un existen cambios pendientes para ser indicados
en el repositorio. Usted puede ver la nota que dice, in inglés:

<code>Your branch is ahead of 'origin/master' by 1 commit.</code>

Lo que se traduce como: 
<code>_Su rama esta más avanzadada que el 
'maestro/origen' por una confirmación</code>

Esto significa que hemos confirmado 1 cambios en el repositorio 
local, pero que este no se ha empujado (pushed) al repositorio de 
origen (`origin`), donde origen es el nombre que se usar típicamente
para el repositorio en GitHub. Entonces, confirmemos los cambios 
pendientes, para eso seleccione la caja (staging) y luego escriba el 
mensaje de confirmación (commit message; fig .

```{r rstudioCommit2, echo=FALSE, out.width = '100%', fig.align = 'center', fig.cap = 'Captura de pantalla con los archivos a confirmar sus cambios y el texto descriptivo de la confirmación.'}
knitr::include_graphics("images/6.20_rstudio-commit-2.png")
```

Cuando haya terminado, ahora puede ver que no existen cambios pendientes
en el panel *Git* y el repositorio esta completamente limpio.

__Inspeccione el historial.__ Fíjese que ahora el mensaje dice:

<code>Your branch is ahead of 'origin/master' by 2 commits.</code>

<code>_Su rama esta más avanzadada que el 
'maestro/origen' por 2 confirmación</code>

Estas 2 confirmaciones son las dos que acabamos de hacer y no se han empujado
aun a GitHub. Haciendo clic en el botón *History* (historial), podemos ver que 
ahora hay un total de 4 confirmaciones en el repositorio local, mientras hay 
solo 2 en GitHub (fig. \@ref(fig:rstudioCommit3)).

```{r rstudioCommit3, echo=FALSE, out.width = '100%', fig.align = 'center', fig.cap = 'Captura de pantalla con 4 commits.'}
knitr::include_graphics("images/6.21_rstudio-history-2.png")
```
__Empuje estos cambios a GitHub.__ Ahora que se han hecho todos los cambios deseados
en el repositorio local, usted puede empujar (*push*) los cambios a GitHub usando el 
boton *Push*.  Esto hará que se le pregunte por su usuario y password de GitHub y
subir los cambios, dejando que su repositorio local en un estado totalmente limpio
y sincronizado. Terminado esto, al mirar en el historial (en GitHub) se muestran todos
los commits, incluendo los 2 que fueron hechos en GitHub y los 2 que se hicieron en
forma local con RStudio.  


```{r rstudioCommit3, echo=FALSE, out.width = '100%', fig.align = 'center', fig.cap = 'Captura de pantalla con los 4 modificaciones confirmadas.'}
knitr::include_graphics("images/6.22_rstudio-history-3.png")
````

Note que las etiquetas tanto del repositorio local (`HEAD`) y el repositorio
remoto (`origin/HEAD`) están apuntando a la misma versión en el historial.
De esta forma, si vamos a mirar el historial de los commits en GitHub serán
iguales a los que tenemos en forma local.

```{r githubHistory, echo=FALSE, out.width = '100%', fig.align = 'center', fig.cap = 'Captura de pantalla con el historial de cambios en github.'}
knitr::include_graphics("images/6.23_github-history.png")
````

## Sobre buenos mensajes de confirmación (commit)

Clearly, good documentation of what you've done is critical to making the version
history of your repository meaningful and helpful.  Its tempting to skip the 
commit message altogether, or to add some stock blurd like 'Updates'.  Its better
to use messages that will be helpful to your future self in deducing not just what
you did, but why you did it.  Also, commit messaged are best understood if they
follow the active verb convention.  For example, you can see that my commit
messages all started with a past tense verb, and then explained what was changed.

While some of the changes we illustrated here were simple and so easily explained
in a short phrase, for more complext changes, its best to provide a more complete
message.  The convention, however, is to always have a short, terse first sentence, 
followed by a more verbose explanation of the details and rationale for the change.
This keeps the high level details readable in the version log.  I can't count the
number of times I've looked at the commit log from 2, 3, or 10 years prior and
been so grateful for diligence of my past self and collaborators.

## Collaboration and conflict free workflows

Up to now, we have been focused on using Git and GitHub for yourself, which is a 
great use. But equally powerful is to share a GitHib repository with other
researchers so that you can work on code, analyses, and models together.  When
working together, you will need to pay careful attention to the state of the 
remote repository to avoid and handle merge conflicts.  A *merge conflict* occurs
when two collaborators make two separate commits that change the same lines of the
same file.  When this happens, git can't merge the changes together automatically,
and will give you back an error asking you to resolve the conflict. Don't be afraid
of merge conflicts, they are pretty easy to handle.  and there are some 
[great](https://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/) [guides](https://stackoverflow.com/questions/161813/how-to-resolve-merge-conflicts-in-git).

That said, its truly painless if you can avoid merge conflicts in the first place.
You can minimize conflicts by:

- Ensure that you pull down changes just before you commit
  + Ensures that you have the most recent changes
  + But you may have to fix your code if conflict would have occurred
- Coordinate with your collaborators on who is touching which files
  + You still need to comunicate to collaborate

## Exercise

Use RStudio to add a new RMarkdown file to your `sasap-test`
repository, build a basic structure for the file, and then save it.

Next, stage and commit the file locally, and push it up to GitHub.

## Advanced topics

There's a lot we haven't covered in this brief tutorial.  There are some great
and much longer tutorials that cover advanced topics, such as:

- Using git on the command line
- Resolving conflicts
- Branching and merging
- Pull requests versus direct contributions for collaboration
- Using .gitignore to protect sensitive data
- GitHub Issues and why they are useful
- and much, much more

- [Try Git](https://try.github.io) is a great interactive tutorial
- Software Carpentry [Version Control with Git](http://swcarpentry.github.io/git-novice/)
- Codecademy [Learn Git](https://www.codecademy.com/learn/learn-git) (some paid)



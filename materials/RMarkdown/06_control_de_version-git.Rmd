
# Control de versiones con git y GitHub

## Objetivos

En esta lección usted aprenderá:

- ¿Por qué __git__ es útil para analisis reproducibles?
- ¿Cómo usar __git__ para controlar los cambios que se hacen en el tiempo?
- ¿Cómo usar __GitHub__ para colaboración?
- ¿Cómo estructurar los "_commits_" para que los cambios sean claros para otros?
- ¿Cómo escribir mensajes de "_commits_" que sean efectivos?

## El problema con los archivos de nombre

```{r finalDoc2, echo=FALSE, out.width = '100%', fig.align = 'center', fig.cap = 'El dilema de usar nombres como descriptor de versiones.'}
knitr::include_graphics("images/3.1_phd_comics_final.png")
```

Cada archivo en un proceso científico sufre de cambios. Los manuscritos son editados. Las figuras son 
revisadas. Los códigos se corrigen cuando se encuentran problemas. Los archivos de datos se combinan, 
errores son corregidos, se dividen y combinan nuevamente. En el curso de un análisis simple, uno puede 
esperar miles de cambios en los archivos. Y aún así, todo lo que usamos para identificas este sinnúmero 
de cambios son los simples **nombres de archivos** (fig. \@ref(fig:finalDoc2)). Teniendo esto en consideración, es lógico 
pensar que debe existir una forma mejor… Y si la hay, se conoce como **Control de Versiones**.


Un sistema de control de versiones ayuda a seguir todos lo cambios que se realizan a nuestros 
archivos, sin el desastre que resulta utilizando sólo el nombre de archivos. En los sistemas de 
control de versiones como `git`, el sistema registra no solo el nombre del archivo, si no que 
además su contenido, de esta forma, cuando el contenido cambia, permite identificar que partes 
estaban y donde. Registra además que versión de un archivo viene de una versión previa, de esta 
forma se tiene un historial de todos los cambios. De esta forma es fácil dibujar un gráfico 
que muestre todos los cambios que ha sufrido un archivos, con todas sus versiones, algo como 
lo que se muestra en la figura \@ref(fig:figVersiones2):


```{r figVersiones2, echo=FALSE, out.width = '40%', fig.align = 'center', fig.cap = 'Evolución de las versiones de un archivo.'}
knitr::include_graphics("images/3.2_version-graph.png")
```

Los sistemas de control de versiones asignan un identificador a cada versión de cada 
archivo y mantiene un registro de como están relacionados entre ellos. Además, estos
permiten ramificaciones en esas versiones, permitiendo fusiones de esas ramificaciones
de regreso a la tronco principal de trabajo. Estos sistemas permiten
ademas tener *múltiples copias* en múltiples computadores como respaldos y para trabajar
en colaboración. Finalmente, además se puede incluir etiquetas (tags) a versiones 
en particular, de esta forma es fácil retornar a la versión que tenían los archivos 
cuando fueron etiquetados. Por ejemplo, la versión exacta de los datos, código y texto
de un manuscrito que fue enviado y que tiene la etiqueta `R2` en la figura \@ref(fig:figVersiones2).

## Control de versiones y colaboración usando Git and GitHub

Hagamos la distición entre **git** y **GitHub**.

- __git__: Software the control de versones que se usa para monitorear los archivos de un 
directorio (un repositorio)
    - git crea el historial de versiones de un repositorio
- __GitHub__: Sitio web que permite a usuarios almacenar sus repositorios git y compartilos
con otros

```{r gitExplicado, echo=FALSE, out.width = '60%', fig.align = 'center', fig.cap = 'Diferencia entre git y GitHub.'}
knitr::include_graphics("images/6.3_vc-local-github.png")
```


## Veamos un repositorio de GitHub

El pantallaso en la figura \@ref(fig:webGitHub) muestra una copia de un repositorio 
almacenado en GitHub, con el listado de archivos, cuando se modificaron los archivos 
y directorios y laguna información acerca de quien hizo los cambios más recientes.

```{r webGitHub, echo=FALSE, out.width = '100%', fig.align = 'center', fig.cap = 'Captura de pantalla de un repositorio en GitHub.'}
knitr::include_graphics("images/6.4_ss3sim-github.png")
```

Si nos metemos en los "commits" del repositorio (fig. \@ref(fig:githubCommits)), podemos 
que que la historia de los
cambios que se le han realizado a todos los archivos.  Se puede ver que `kellijohnson`
y `seananderson` arreglaron algunas cosas durante junio y julio:

```{r githubCommits, echo=FALSE, out.width = '100%', fig.align = 'center', fig.cap = 'Captura de pantalla de los Commits de un repositorio en GitHub.'}
knitr::include_graphics("images/6.5_ss3sim-commits.png")
```

Y finalmente, si vemos ahora los cambios realizado el 13 de julio (fig. \@ref(fig:githubDiferencias)),
se puede exactamente cuales fueron los cambios realizados a cada archivo:

```{r githubDiferencias, echo=FALSE, out.width = '100%', fig.align = 'center', fig.cap = 'Captura de pantalla donde se presentan las diferencias entre dos versiones alojadas en un repositorio de GitHub.'}
knitr::include_graphics("images/6.6_ss3sim-diff.png")
```

Monitorear estos cabmios, como se relacionan a cada las versiones de un software en 
particular y a los archivos es exactamente para lo que fueron diseñados git y 
GitHub. Vamos a mostrar como pueden ser realmente efectivos para monitorear 
versiones de códigos científicos, figuras y manuscritors para lograr tener
flujos de trabajo reproducibles.

## El ciclo de vida de Git

Como usuario de git usted tiene que entener algunos conceptos básicos
asociados a los set de cambios con versiones y como estos son almacenado y 
se mueven a traves del repositorio.  Cualquier repositorio de git puede ser
clonado, de esta forma existe en forma local y remota. Pero cada uno de estos
repositorios clonados son una copia simple de todos los archivos y el historial
de cambios de ellos, almacenados en un forma git particular. Para
nuestros propósitos, tenemos que considerar un repositorio de git 
simplemente un un directorio que contiene adicionalmente un set de 
metadatos relacionado con las versiones.

En un directorio local donde git fue habilitado, el directorio contiene la 
versíon actual de todos los archivos del repositorio. Estos archivos de trabajo
están unidos a un directorio escondido que contiene el 'Repositorio local', 
el que a su vez contiene todos los otros cambios que se han realizado a los
archivos y los metadatos sobre las versiones.

De esta forma, cuando se está usando git para trabajar con archivos, se pueden 
usar los comando de git para indicar específicamente que cambios a los archivos
de trabajo deben ser definidos para las versiones (usando el comando `git add`)
y cuando grabar estos cambios como una versión en el repositorio local (usando
el comando `git commit`).

Los demás conceptos se relacionan a la sincronización de los cambios en el 
repositorio local a un repositorio remoto. El comando `git push` se usar para
enviar los cambios realizados en forma local a un repositorio remoto (posiblemente
en GitHub) y el comando `git pull` es usado para traer los cambios del repositorio
remoto y unirlos al repositorio local.


```{r gitFlowChart, echo=FALSE, out.width = '70%', fig.align = 'center', fig.cap = 'Diagrama de flujo del ciclo de vida de git.'}
knitr::include_graphics("images/6.7_git-flowchart.png")
```


- `git clone`: Copia tod el repositorio remoto a uno local
- `git add` (stage): Notifica a git de monitorear un set particular de cambios
- `git commit`: Almacena los cambios realizados como una versión
- `git pull`: Combina los calbios de un repositorio remoto a nuestro repositorio local
- `git push`: Copia los cambios de nuestro repositorio local al repositorio remoto
- `git status`: Determina el estado de los archivos en el repositorio local
- `git log`: Imprime el historial de cambios en el repositorio

Estos siete comando con la mayoría de los que usted va a necesitar para utilizar git en forma
exitosa. Pero todo esto es demasiado abstracto, mejor exploremos estos conceptos utilizando
ejemplos reales.

## Cree un repositorio remoto en GitHub

Empecemos creando un repositorio en GitHub, luego editemos algunos archivos.

- Ingrese al sitio [GitHub](https://github.com)
- Clic en el botor de repositorio nuevo (New repository)
- Nombrelo como `sasap-test`
- Cree un archivo README.md
- Defina la licencia a Apache 2.0


```{r githubNewRepo, echo=FALSE, out.width = '70%', fig.align = 'center', fig.cap = 'Captura de pantalla de la creación de un repositorio nuevo en GitHub.'}
knitr::include_graphics("images/6.8_new-repo-github.png")
```

¡Usted acaba de crear su primer repositorio! Tiene un par de archivos que 
GitHub creó por usted, por ejemplo los archivpos README.md, LICENSE y .gitignore.


```{r githubSasapRepo, echo=FALSE, out.width = '70%', fig.align = 'center', fig.cap = 'Captura de pantalla con el repositorio recién creado llamado sasap-test.'}
knitr::include_graphics("images/6.9_sasap-test-repo.png")
```

Para hacer cambios menores a archivos de texto, se puede utilizar la interfase web de GitHub.  For example,
navigate to the `README.md` file in the file listing, and edit it by clicking on the *pencil* icon.
This is a regular Markdown file, so you can just add text, and when done, add a commit message, and 
hit the `Commit changes` button.  

![](images/sasap-test-edit.png)

![](images/sasap-test-commit.png)

Congratulations, you've now authored your first versioned commit.  If you navigate back to 
the GitHub page for the repository, you'll see your commit listed there, as well as the
rendered README.md file.

![](images/sasap-test-displayed.png)
Let's point out a few things about this window.  It represents a view of the repository
that you created, showing all of the files in the repository so far.  For each file,
it shows when the file was last modified, and the commit message that was used to last
change each file.  This is why it is important to write good, descriptive commit
messages.  In addition, the blue header above the file listing shows the most recent
commit, along with its commit message, and its SHA identifer.  That SHA identifier is
the key to this set of versioned changes.  If you click on the SHA identifier (*810f314*), 
it will display the set of changes made in that particular commit.

In the next section we'll use the GitHub URL for the GitHub repository you created 
to `clone` the repository onto your local machine so that you can edit the files 
in RStudio.  To do so, start by copying the GitHub URL, which represents the repository
location:

![](images/sasap-test-clone-url.png)



## Working locally with Git via RStudio

RStudio knows how to work with files under version control with Git, but only if
you are working within an RStudio project folder.  In this next section, we will
clone the repository that you created on GitHub into a local repository as an 
RStudio project.  Here's what we're going to do:

- Create the new project
- Inspect the Git tab and version history
- Commit a change to the README.md file
- Commit the changes that RStudio made
- Inspect the version history
- Add and commit an Rmd file
- Push these changes to GitHub
- View the change history on GitHub

__Create a New Project.__ Start by creating a *New Project...* in R Studio, select the *Version Control* 
option, and paste the GitHub URL that you copied into the field for the 
remote repository *Repository URL*.  While you can name the local copy of the 
repository anything, its typical to use the same name as the GitHub repository to
maintain the correspondence.  You can choose any folder for your local copy, in
my case I used my standard `development` folder.

![](images/rstudio-clone-repo.png)
Once you hit `Create Project, a new RStudio windo will open with all of the files
from the remote repository copied locally.  Depending on how your version of RStudio
is configured, the location and size of the panes may differ, but they should all
be present, including a *Git* tab and the normal *Files* tab listing the files that 
had been created in the remote repository.

![](images/rstudio-sasap-test.png)
You'll note that there is one new file `sasap-test.Rproj`, and three files that we
created earlier on GitHub (`.gitignore`, `LICENSE`, and `README.md`).

In the *Git* tab, you'll note that two files are listed.  This is the status pane
that shows the current modification status of all of the files in the repository.
In this case, the `.gitignore` file is listed as *M* for Modified, and `sasap-test.Rproj` 
is listed with a *? ?* to indicate that the file is untracked.  This means that
git has not stored any versions of this file, and knows nothing about the file.
As you make version control decisions in RStudio, these icons will change to reflect
the current version status of each of the files.

__Inspect the history.__ For now, let's click on the *History* button in the Git tab, which will show the
log of changes that occurred, and will be identical to what we viewed on GitHub.
By clicking on each row of the history, you can see exactly what was added and
changed in each of the two commits in this repository.

![](images/rstudio-history-1.png)
__Commit a README.md change.__ Next let's make a change to the README.md file
in RStudio. Add a new section, with a markdown block like this:

<pre><code>
## Git from RStudio

From within RStudio, we can perform the same versioning actions that we can
in GitHub, and much more.  Plus, we have the natural advantages of the 
programming IDE with code completion and other features to make our work
easier.

- Add files to version control
- Commit changes
- Push commits to GitHub
</code></pre>

Once you save, you'll immediately see the *README.md* file show up in the Git
tab, marks as a modification.  You can select the file in the Git tab, and click
*Diff* to see the differences that you saved (but which are not yet committed to
your local repository).

![](images/rstudio-status-pane.png)

And here's what the newly made changes look like compared to the original file.
New lines are highlighted in green, while removed lines are in red.

![](images/rstudio-diff.png)
__Commit the RStudio changes.__

To commit the changes you made to the README.md file, check the *Staged*
checkbox next to the file (which tells Git which changes you want included in
the commit), then provide a descriptive Commit message, and then click *Commit*.

![](images/rstudio-commit-1.png)

Note that some of the changes in the repository, namely `.gitignore` and 
`sasap-test.Rproj` are still listed as having not been committed.  This means
there are still pending changes to the repository.  You can also see the note
that says:

<code>Your branch is ahead of 'origin/master' by 1 commit.</code>

This means that we have committed 1 change in the local repository, but that 
commit has not yet been pushed up to the `origin` repository, where `origin`
is the typical name for our remote repository on GitHub.  So, let's commit the
remaining project files by staging them and adding a commit message.

![](images/rstudio-commit-2.png)

When finished, you'll see that no changes remain in the *Git* tab, and the repository
is clean.  

__Inspect the history.__ Note that the message now says:

<code>Your branch is ahead of 'origin/master' by 2 commits.</code>

These 2 commits are the two we just made, and have not yet been pushed to GitHub.
By clicking on the *History* button, we can see that there are now a total of
four commits in the local repository (while there had only been two on GitHub).

![](images/rstudio-history-2.png)

__Push these changes to GitHub.__ Now that everything has been changed as desired
locally, you can *push* the changes to GitHub using the *Push* button.  This will
prompt you for your GitHub username and password, and upload the changes, leaving
your repository in a totally clean and synchronized state.  When finished, looking
at the history shows all four commits, including the two that were done on GitHub
and the two that were done locally on RStudio.  

![](images/rstudio-history-3.png)
And note that the labels indicate that both the local repository (`HEAD`) and the
remote repository (`origin/HEAD`) are pointing at the same version in the history.
So, if we go look at the commit history on GitHub, all the commits will be shown
there as well.

![](images/github-history.png)

## On good commit messages

Clearly, good documentation of what you've done is critical to making the version
history of your repository meaningful and helpful.  Its tempting to skip the 
commit message altogether, or to add some stock blurd like 'Updates'.  Its better
to use messages that will be helpful to your future self in deducing not just what
you did, but why you did it.  Also, commit messaged are best understood if they
follow the active verb convention.  For example, you can see that my commit
messages all started with a past tense verb, and then explained what was changed.

While some of the changes we illustrated here were simple and so easily explained
in a short phrase, for more complext changes, its best to provide a more complete
message.  The convention, however, is to always have a short, terse first sentence, 
followed by a more verbose explanation of the details and rationale for the change.
This keeps the high level details readable in the version log.  I can't count the
number of times I've looked at the commit log from 2, 3, or 10 years prior and
been so grateful for diligence of my past self and collaborators.

## Collaboration and conflict free workflows

Up to now, we have been focused on using Git and GitHub for yourself, which is a 
great use. But equally powerful is to share a GitHib repository with other
researchers so that you can work on code, analyses, and models together.  When
working together, you will need to pay careful attention to the state of the 
remote repository to avoid and handle merge conflicts.  A *merge conflict* occurs
when two collaborators make two separate commits that change the same lines of the
same file.  When this happens, git can't merge the changes together automatically,
and will give you back an error asking you to resolve the conflict. Don't be afraid
of merge conflicts, they are pretty easy to handle.  and there are some 
[great](https://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/) [guides](https://stackoverflow.com/questions/161813/how-to-resolve-merge-conflicts-in-git).

That said, its truly painless if you can avoid merge conflicts in the first place.
You can minimize conflicts by:

- Ensure that you pull down changes just before you commit
  + Ensures that you have the most recent changes
  + But you may have to fix your code if conflict would have occurred
- Coordinate with your collaborators on who is touching which files
  + You still need to comunicate to collaborate

## Exercise

Use RStudio to add a new RMarkdown file to your `sasap-test`
repository, build a basic structure for the file, and then save it.

Next, stage and commit the file locally, and push it up to GitHub.

## Advanced topics

There's a lot we haven't covered in this brief tutorial.  There are some great
and much longer tutorials that cover advanced topics, such as:

- Using git on the command line
- Resolving conflicts
- Branching and merging
- Pull requests versus direct contributions for collaboration
- Using .gitignore to protect sensitive data
- GitHub Issues and why they are useful
- and much, much more

- [Try Git](https://try.github.io) is a great interactive tutorial
- Software Carpentry [Version Control with Git](http://swcarpentry.github.io/git-novice/)
- Codecademy [Learn Git](https://www.codecademy.com/learn/learn-git) (some paid)



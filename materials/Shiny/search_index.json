[
["index.html", "Introducción a las aplicaciones web interactivas 1 Introducción 1.1 Consola R 1.2 RStudio 1.3 Instalación de packetes en RStudio 1.4 Proyectos de RStudio 1.5 Editor de código 1.6 Actividad 1.7 Resumen", " Introducción a las aplicaciones web interactivas Por definir 1 Introducción R es es un lenguage de programación gratuito, descarga e instalación muy sencilla. Solo hay que ir al sitio CRAN (Comprehensive R Archive Nerwork) y descargarglo. Está disponible para Windows, MacOS y Linux. R es ampliamente utilizado por la comunidad científica gracias a que nos entrega una plataforma para realizar análisis estadísticos complejos, gráficas potentes y de calidad profesional (ej. ggplot) y a la versatilidad para el manejo de datos, lo que en conjunto de ser una plataforma de software abierto, lo hacen especialmente atractivo para la ciencia de datos y a la investigación reproducible, ya que no tiene formatos privados que podrían dejar de ser soportados en el futuro. Ahora, si ud. no conoce R, le sugiero que cierre este curso y use este libro que es una excelente edición en espñol para aprender a usar R. Este curso parte de la base que tiene familiaridad con R, puede realizar análisis, gráficos y manipulación de datos. 1.1 Consola R Figure 1.1: Trabajar en la consola de R es como usar una rueda cuadrada.. Uno de los principales problemas para aprender a trabajar en R es su complejidad y lo poco amigable de su consola de trabajo. Sin embargo esto es tambien su mayor virtud ya que lo hace en extremo flexible. Afortunadamente la compañía RStudio ha hecho disponible un entorno de desarrollo integrado (IDE) que facilita trabajar en R ya que tiene herramientas muy útiles para el manejo de librerías, visualización de datos, etc. 1.2 RStudio Figure 1.2: Logo de RStudio. RStudio (IDE para R; Fig. 1.2), es un software libre con licencia GPLv3 multiplataforma, lo que significa que puede ser ejecutado en sistemas operativos Windows, Mac, o Linux. La figura 1.3 muestra la vista típica del IDE Rstudio y sus cuatro paneles, donde se destaca en panel de edición de texto (superior izquierdo), la consola R (panel inferior izquierdo), panel con las variables (superior derecho) y el navegador de archivos (panel inferior derecho). Figure 1.3: RStudio, IDE de R. Es la rueda que le faltaba a R para hacer el trabajo más sencillo. Entre las muchas ventajas que tiene trabajar con RStudio podemos destacar: Permite tener en una misma ventana el código, gráficos, comandos de R, historial de comandos, variables, etc. Se puede trabajar con multiples archivos en forma simultanea. Se puede ejecutar todo el código o sólo parte de el con un click o combinación de teclas. Muestra el workspace y los objetos (varibles) que contiene. Tiene un historial de los comando ejecutados. Tiene una ayuda integrada y fácil de navegar. Tiene un gestor de librerías y packetes para instalar y cargar. Tiene un gestor de conecciones para bases de datos. Contiene un gestor de desarrollo de librerias o packetes de R. Tiene integración con git y GitHub. Tiene un navegador de archivos. Provee un visor de gráficos. 1.3 Instalación de packetes en RStudio Para instalar un paquete o librería nueva de R se puede descargar desde CRAN utilizando la línea de comandos (como se hace en R) o utilizando la interfase gráfica que entrega RStudio. En el panel inferior derecho de la pantalla de Rstudio se encuentra la pestaña Packages, se da clic en esa pestaña y luego en Install, esto abre una ventana donde se pueden escribir las librerías que necesitamos. En el ejemplo en la figura 1.4 se va a instalar la libreria Shiny, que es la que usaremos en esta clase. Figure 1.4: Administrador de instalación de paquetes de RStudio. 1.4 Proyectos de RStudio Uno de los aspectos más útiles que tiene RStudio son los Proyectos (Project en inglés). Esto es un conjuto de archivos, datos y variables, que quedan autocontenidos (en el proyecto) y hacen más fácil su administración y uso. Cada vez que usted inicia el trabajo en un nuevo tema, tópico o proyecto, es una muy buena práctica comenzar con la creación de un nuevo proyecto donde trabajará con sus archivos de código. Estos archivos con códigos son los que luego se usan para cargar datos, crear gráficos, producir tablas, exportar datos, etc. Un proyecto define el directorio de trabajo (equivalente a a la funcion setwd) relativo a donde fue creado el proyecto. De esta forma, se puede ahorrar escribir esos path largos antes de leer/escribir cada archivo. Además, los archivos de código que se generen en el proyecto, estarán siempre disponibles para consultarlos en cualquier momento que el usuario así lo desee. Para crear un proyecto, vamos a la pestaña superior derecha de Rstudio y damos clic en crear un proyecto (fig. 1.5). Figure 1.5: Menú desplegable para la creación de un nuevo proyecto de RStudio. 1.5 Editor de código Para iniciar el editor de texto, donde vamos a escribir el código de nuestra aplicación Shiny más adelante, o realizar análisis estadísticos, crear gráficos, tablas, leer o exportar datos, se debe ir a Archivo (File) -&gt; Nuevo Archivo (New File) -&gt; R Script (RScript). Note que en IDE RStudio se puede trabajar con muchos otros lenguajes y convenciones (Fig. 1.6). Figure 1.6: Creación de un archivo nuevo en RStudio. 1.6 Actividad Cree un nuevo proyecto. Dentro de este proyecto cree un nuevo archivo que se llame test.R. Escriba un código para definir una matriz de 4x4 con datos al azar. Ejecute este código línea por línea. Guarde estos datos en un directorio llamado datos. Vea donde fueron creados estos datos utilizando el explorador de archivos de RStudio. Revise el historial de RStudio 1.7 Resumen Para crear un proyecto de RStudio abra el menu desplegable en el extremo superior derecho. RStudio tiene múltiples paneles con tabs que permiten ver más información de la que se ve en un principio. Los path son relativos de donde se crea el proyecto de RStudio. Nota: Parte de esta introducción se basa en el Capitulo I del curso desarrollado por Marco A Gonzalez (González Tagle 2016) Referencias "],
["introducción-a-shiny.html", "2 Introducción a Shiny 2.1 Objetivos 2.2 Bienvenido a Shiny 2.3 Primera aplicación 2.4 Ejecutando ShinyApp 2.5 Actividad 2.6 Resumen 2.7 Aun más", " 2 Introducción a Shiny En la página principal del paquete Shiny se puede leer “Interactúa. Analiza. Comunica. Toma una aproximación fresca e interactiva para contar tu historia de datos con Shiny. Deja a los usuarios interactuar con tus datos y análisis. Y hazlo todo con R”. Figure 2.1: Imagen de la página principal de shiny.rstudio.com. El principal atractivo del paquete Shiny que es hace muy fácil construir aplicaciones web interactivas, utilizando código R en forma simple y directa. Estas aplicaciones se pueden hospedar en servidores web en forma independiente o bien como parte de documentos generados con RMarkdown clase sobre investigación reproducible con RMarkdown. Algunos ejemplos de aplicaciones shiny que he creado: Períodos de retorno de salmones de Alaska Aquí Distribución de frecuencias de talla y edad de salmones de Alaska Aquí Capturas artesanales en Chile (Aún en desarrollo) Aquí Tablas de resumenes mensuales Aquí Existen muchas posibilidades, navege por esta galeria de aplicaciones Shiny para buscar inspiración. En resumen, Shiny combina el poder computacional y simpleza de R, con las capacidades interactivas de las páginas web modernas. Reconocimiento: Este libro esta desarrollado utilizando blogdown y bookdown. Sigue el estilo del trabajo realizado para los talleres de SASAP y Arctic Data Center de NCEAS. Aquí traduzco, compilo e integro materiales de múltiples fuentes, principalmente la página https://shiny.rstudio.com/(RStudio, Inc 2014). 2.1 Objetivos En este capítulo veremos: ¿Qué es Shiny? Que se puede hacer con Shiny. Instalación de las librerías Shiny en su computador. Creación de su primera aplicación Shiny. Como compartir su aplicación en la red. 2.2 Bienvenido a Shiny Como ya se dijo, Shiny es un paquete de R que hace muy fácil la implementación de aplicaciones web interactivas (apps) utilizando el lenguaje al que estamos acostumbrados en R. En esta sección vamos a comenzar a mostrar en que consisten estas aplicaciones, construiremos una aplicación muy simple y la pondremos en la red para que otras personas puedan verla y jugar con ella. Si por alguna razón aun no ha instalado el paquete Shiny, abra RStudio, conéctese a Internet y corra el código: install.packages(&quot;shiny&quot;) La figura 2.2 presenta un ejemplo de una aplicación básica. Figure 2.2: Shiny Hello World app. El paquete Shiny contiene 11 ejemplos pre-construidos que demuestran como trabaja Shiny y son auto-contenidos. El ejemplo “Hello Shiny” gráfica un histograma con el los datos de R del Viejo Fiel e incluye una barra deslizable para definir el número de intervalos para un histograma, de esta forma, al interaccionar con la aplicación, el usuario puede aumentar o disminuir el número de intervalos, moviendo con el puntero del mouse, la barra deslizable que se encuentra a la izquierda del gráfico y la aplicación responderá en forma inmediata a esta acción. Vamos a usar una aplicación muy similar a esta para explorar la estructura de un Shiny cuando creemos nuestra primera app. Para ejecutar en su computador la app Hello Shiny, escriba: library(shiny) runExample(&quot;01_hello&quot;) 2.3 Primera aplicación Una aplicación Shiny básica puede estar contenida en un solo archivo llamado app.R en un directorio, si se crea la app en un directorio, debe contener lor archivos ui.R y server.R, ek qye se puede ejecutar con runApp(“NombreDirectorio”). El código dentro de app.R contiene tres secciones: El objeto Interfase de Usuario (UI): Este objeto contiene los controles sobre el diseño y apariencia de la aplicación. La función Servidor: Contiene las instrucciones que el computador necesita ejecutar para construir la aplicación. La llamada a la función shinyApp: Esta función crea los objetos Shiny apps desde el par UI/server. Para aplicaciones más complejas es recomendable crear archivos separados llamados ui.R y server.R. Además es posible incluir un archivo global.R donde se pueden incluir funciones creadas para la aplicación, manipular datos, etc. Una aspecto muy interesante de programar una aplicación en un archivo único, es la facilidad de este para ser compartido y ejecutado desde la consola R o líneas de comando. 2.3.1 UI Aquí esta el objeto ui del ejemplo Hello Shiny: library(shiny) # Define UI for app that draws a histogram ---- ui &lt;- fluidPage( # App title ---- titlePanel(&quot;Hello Shiny!&quot;), # Sidebar layout with input and output definitions ---- sidebarLayout( # Sidebar panel for inputs ---- sidebarPanel( # Input: Slider for the number of bins ---- sliderInput(inputId = &quot;bins&quot;, label = &quot;Number of bins:&quot;, min = 1, max = 50, value = 30) ), # Main panel for displaying outputs ---- mainPanel( # Output: Histogram ---- plotOutput(outputId = &quot;distPlot&quot;) ) ) ) De este código es posible identificar los componentes: titlePanel donde se define el título de la aplicación. sidebarLayout donde se definen los espacios que se utilizan para las entradas que hace el usuario y las generadas por la aplicación, en este caso un gráfico. 2.1. sidebarPanel, está definido como un subcomponente de sideberLayout y define la sección donde el usuario puede interactuar con la aplicación. 2.1.1. sliderInput es una barra con la que se pueden definir el número de “bins” que usa el gráfico (que se crea en la sección server de la aplicación). 2.2 mainPanel es es espacio donde se desplegaran los resultados, gráficos, tablas, etc. 2.2.1 plotOoutput es una subsección de mainPanel done se define que la salida es un gráfico. 2.3.2 Server Aquí esta la función server del ejemplo Hello Shiny y es donde se define la lógica que se usará para generar, en este caso, un histograma, considerando la entrada de número de barras, definida por la barra con la interactúa el usuario. server &lt;- function(input, output) { # Histogram of the Old Faithful Geyser Data ---- # with requested number of bins # This expression that generates a histogram is wrapped in a call # to renderPlot to indicate that: # # 1. It is &quot;reactive&quot; and therefore should be automatically # re-executed when inputs (input$bins) change # 2. Its output type is a plot output$distPlot &lt;- renderPlot({ x &lt;- faithful$waiting bins &lt;- seq(min(x), max(x), length.out = input$bins + 1) hist(x, breaks = bins, col = &quot;#75AADB&quot;, border = &quot;white&quot;, xlab = &quot;Waiting time to next eruption (in mins)&quot;, main = &quot;Histogram of waiting times&quot;) }) } Al crear esta función se definen dos variables de entrada, inputs y outputs. Estas son las variables con las que la función server interactúa con el resto de la aplicación. En este ejemplo podemos identificar que en output se almacena un gráfico en el objeto disPlot (que si ven en ui es lo que se despliega como resultado). Este gráfico fue construido definiendo: bins: Es el número de barras a desplegar y define su número con length.out que toma la entrada desde input$bins, que es definida en UI, en la sección sidebarLayout, donde la función sliderInput, tiene como primer argumento inputId = “bins”, que es el nombre al que se le da, para ser utilizado como una variable, la cual puede ser pasada en otras secciones de la shiny app cuando se usar input$bins. hist: Aquí se genera el histograma, utilizando el número bins como un variable que se le entrega al argumento breaks de la función hist, que es la que hace el histograma. En resumen, la función server es muy simple, el código hace unos cálculos (i.e. bins) y luego hace un histograma con el número predefinido de barras y lo devuelve como un output llamado disPlot, que luego es desplegado en la sección mainPanel de la Interfase de Usuario (UI). Ahora que tiene una mejor comprensión del funcionamiento, manipule algunos argumentos y vea los resultados, trate de ir entendiendo como funciona y que pasa cuando hace los cambios. Una aplicación Shiny tiene que comenzar con la carga de la librería Shiny (library(shiny)) y terminar con la llamada a shinyApp. Recuerde que su sesión R estará ocupada mientras la aplicación Shiny esté corriendo, por lo que no podrá ejecutar comando R mientras esta dure. R en este periodo esta monitoriando la app y ejecutando las reacciones a los inputs del usuario. Para recuperar la sesión de R, aprete la tecla ‘Esc’ o haga click en el botón Stop (se encuentra en la esquina superior izquierda del panel de la consola RStudio). library(shiny) ui &lt;- ... ## Definiciones d ela interfase de Usuario server &lt;- ... ## Que es lo que hace la plicacion shinyApp(ui = ui, server = server) ## La ejecución de la Aplicación Shiny. 2.4 Ejecutando ShinyApp Todas las aplicaciones Shiny tienen la misma estructura: un archivo app.R que contiene la ui y el servidor. Ud. puede crear un aplicación Shiny haciendo un nuevo directorio y guardando un archivo app.R adentro. Es recomendado que cada aplicación este siempre en un directorio propio. Para ejecutar la aplicación, utilice la función runApp pasando el nombre del directorio donde esta contenido el archivo app.R, si el directorio se llama mi_aplicacion, entonces el código para ejecutarlo sería: library(shiny) runApp(&quot;mi_aplicacion&quot;) Fíjese que esto es muy similar a las funciones read.csv, read.table y muchas otras en R. El primer argumento de la función runApp es el path al archivo desde el directorio de trabajo de la aplicación. El código asume que el directorio de la aplicación está en su directorio de trabajo (generalmente definido con la función setwd). En este caso, el path es solo el nombre del directorio. 2.5 Actividad Cree un directorio que se llame MiAplicacion. Luego copie y pegue el código de app.R que dejamos más arriba en archivo app.R en su directorio (el código de Hello Shiny). Inicie su Shiny App ejecutando runApp(&quot;MiAplicacion&quot;), luego cierre la aplicación (aprete Esc) y haga algunos cambios: Cambien el título de “Hello Shiny!” a “Hola Shiny!”). Defina como el número mínimo para la barra deslizable (slider bar) a 5. Cambien el color del borde el histograma de Banco (white) a naranjo (orange) o cualquier otro color que ud. prefiera. Cuando esos 3 pasos esten listos, inicie su aplicación nuevamente. La nueva aplicación debería tener los cambios que ud. acaba de realizar, de otra forma por favor verifique su código y pruebe otra vez. El resultado deberia ser similar a la figura 2.3. Figure 2.3: ShinyApp con modificaciones de formato. El color de los border es naranjo. Por defecto, las aplicaciones Shiny se muestran en un modo normal, como la imagen que se muestra en la figura 2.3. Sin embargo es posible ejecutar las aplicaciones en un panel junto al del código, para esto hay que definir “showcase mode”. Si quieres utilizar el mode showcase, hay que incluir el argumendo display.mode indicando que sea showcase, de esta forma la linea de código queda asi runApp(&quot;MiAplicacion&quot;, display.mode = &quot;showcase&quot;). 2.6 Resumen Para crear una aplicación Shiny: Haga un directorio llamado MiAplicacion/ para su app. Guarde su archivo app.R dentro del directorio. Inicie la app con runApp o con las combinaciones de teclas de RStudio. Salga de la Shiny app apretando la tecla Escape. 2.7 Aun más La forma más fácil de hacer sus propias Shiny App es basándose en otras que ya existentes y utilizarlas como punto de partida. La Galería de Shiny tiene cientos de excelentes ejemplos. Además la librería Shiny trae 11 ejemplos incluidos que puede llamar ejecutando las siguiente líneas de código. runExample(&quot;01_hello&quot;) # Histograma runExample(&quot;02_text&quot;) # Tablas y data frames runExample(&quot;03_reactivity&quot;) # Una expresión reactiva runExample(&quot;04_mpg&quot;) # Variables globales runExample(&quot;05_sliders&quot;) # Barras deslizables runExample(&quot;06_tabsets&quot;) # Paneles tabulados runExample(&quot;07_widgets&quot;) # Texto de ayuda y botones de envío runExample(&quot;08_html&quot;) # Shiny app basada en HTML runExample(&quot;09_upload&quot;) # Herramienta para subir un archivo runExample(&quot;10_download&quot;) # Herramienta para la descarga de archivo runExample(&quot;11_timer&quot;) # Timer automático Cada uno de estos ejemplos muestra algunas de las characterísticas más útiles de Shiny y todas se despligan en el modo “showcase” para que pueda ver el código R. Referencias "],
["interfase-de-usuario-como-construirla.html", "3 Interfase de Usuario: Como construirla 3.1 Objetivos 3.2 Manos a la obra 3.3 Actividad 3.4 Resumen", " 3 Interfase de Usuario: Como construirla Ahora que ya entendemos como funciona la estructura de una aplicación Shiny, es tiempo de construir la primera desde cero. 3.1 Objetivos Crear una Shiny app desde cero. Entender los principios básicos del diseño de la aplicación. Aprender y utilizar las diferentes opciones para el formato de texto. Incluir imágenes en la interfase de usuario. En este capítulo vamos a ver como construir una interfase de usuario para la aplicación. Aprenderá como diseñar la interfase, para luego agregar texto, imágenes y otros elementos HTML. 3.2 Manos a la obra Usaremos la app MiAplicacion del capítulo anterior. Para comenzar abra el archivo app.R y modifique el código para que se vea de la siguiente forma: library(shiny) # En esta sección se define la interfase de usuario y es donde haremos la mayor parte del trabajo ui &lt;- fluidPage( ) # Se define la lógica que sigue el servidor server &lt;- function(input, output) { } # Ejecuta la aplición shinyApp(ui = ui, server = server) Este código representa el mínimo posible necesario para crear un Shiny app. El resultado es bastante poco útil, es una aplicación vacía, sin contenido, con un espacio en blanco donde debería estar la interfase de usuario y las salidas como tablas o gráficos. Es por esto que es un excelente punto de partida para el trabajo que vamos a realizar en este capítulo. 3.2.1 Diseño (Layout) Shiny usa la función fluidPage para crear el espacio que se ajusta automáticamente a las dimensiones de la ventana del navegador del usuario. Es en esta función donde se introducen los elementos necesarios para diseñar la interfase de usuario. Por ejemplo, la función ui que se ve abajo, crea una interfase de usuario que tiene un panel con un título (titlePanel) y un diseño de barra lateral (sidebarLayout); incluye un panel lateral (sidebarPanel) y un panel principal (mainPanel). Hay que hacer notar que estos elementos son incluidos dentro de la función fluidPage. ui &lt;- fluidPage( titlePanel(&quot;Panel de Título&quot;), sidebarLayout( sidebarPanel(&quot;Panel lateral&quot;), mainPanel(&quot;Panel principal&quot;) ) ) La Shiny app creada con esta interfase de usuario resultante se puede ver la Figura 3.1. Figure 3.1: Interfase de Usuario (UI) limpia y sin contenido.. titlePanel y sidebarLayout son dos de los elemento más populares para agregar a fluidPage1. Esto crea la Shiny app básica con una barra lateral. sidebarLayout siempre usa dos argumentos: Función sidebarPanel que define el espacio para la barra lateral. Función mainPanel que define el espacio del panel principal. La barra lateral aparecerá por defecto en el lado izquierdo de la aplicación. Esta se puede mover al lado derecho agregando a la función sidebarLayout el argumento position = &quot;right&quot;. Este código se puede ver a continuación y el resultado en la Figura 3.2. ui &lt;- fluidPage( titlePanel(&quot;Panel de Título&quot;), sidebarLayout( position = &quot;right&quot;, sidebarPanel(&quot;Panel lateral&quot;), mainPanel(&quot;Panel principal&quot;) ) ) Figure 3.2: Interfase de Usuario (UI) limpia y sin contenido, con la barra lateral a la derecha, usando el argumento position = &quot;right&quot;. titlePanel y sidebarLayout crea un diseño básico para la Shiny app, sin embargo es posible crear un diseño más avanzado. Para esto se puede usar navbarPage con la cual se crea en la app una interfase de usuarios multi-páginas que incluye una barra de navegación. Otra opción es usar fluidRow y column para construir un diseño basado en un sistema de grillas. Si ud. quiere aprender más sobre estas opciones avanzadas, puede encontrar la información en en la guía Shiny Application Layout. En esta clase introductoria sólo usaremos sidebarLayout. 3.2.2 Contenidos HTML En una Shiny app es posible agregar contenido incluyéndolo en la función del panel. Por ejemplo, en las app que hemos visto hasta ahora, se despliega una “cadena de caracteres” en cada uno de sus paneles. Las palabras panel lateral aparecen en la barra lateral y fueron agregados como una cadena de caracteres a la función sidebarPanel, e.j. sidebarPanel(&quot;Panel lateral&quot;). Lo mismo es verdadero para el texto en el panel de título y en el panel principal. Para agregar contenido más avanzado se debe usar alguna de las funciones de identificación HTML que usa Shiny. Estas funciones son aquivalentes a los identificadores (tags) de HTML5. Aquí hay una lista de los principales para que los pruebe. Función en Shiny Equivalente HTML5 Crea p &lt;pre&gt; Párrafo de texto h1 &lt;h1&gt; Título de primer orden h2 &lt;h2&gt; Título de segundo orden h3 &lt;h3&gt; Título de tercer orden h4 &lt;h4&gt; Título de cuarto orden h5 &lt;h5&gt; Título de quinto orden h6 &lt;h6&gt; Título de sexto orden a &lt;a&gt; Hipervínculo br &lt;br&gt; Línea div &lt;div&gt; División en el texto con estilo uniforme span &lt;span&gt; Una división en linea del texto con estilo uniforme pre &lt;pre&gt; Texto ‘como es’ en una fuente de ancho fijo code &lt;code&gt; Bloque de código formateado img &lt;img&gt; Una imagen strong &lt;strong&gt; Texto en negrita em &lt;em&gt; Texto en cursiva HTML Pasa una cadena de caracteres como código HTML 3.2.3 Títulos Para crear un título: Seleccione una función de título (ej: h1 a h5). Ingrese el texto que quiere desplegar como título. Por ejemplo, cree un título de primer nivel que diga “Mi título” con h1(&quot;Mi título&quot;). Si se ejecuta este comando en la línea de comandos, puede ver que produce un código HTML. &gt; library(shiny) &gt; h1(&quot;Mi titulo&quot;) &lt;h1&gt;Mi titulo&lt;/h1&gt; Para agregar un elemento a tu app: Pase h1(&quot;My title&quot;) como un agumento a titlePanel, sidebarPanel o mainPanel. El texto aparecerá en el panel correspondiente de su página web. Usted aquí puede agregar elementos en el mismo panel, para esto solo tiene que separarlos con una coma (,). Practiquemos. El siguiente código usa todos los 6 nivel de títulos existentes. Actualice su ui.R o app.R para que produzca resultados similares y reinicie la aplicación. Recuerde que es necesario reiniciar la Shiny app y eso se puede hacer con runApp(&quot;MiAplicacion&quot;), haciendo click en el botón Run App, o usando las cambinaciones de teclas. Actualice ahora el código para usar los 6 niveles de títulos disponibles. Actualice el archivo ui.R o app.R para que sea similar al que se presenta a continuación. Recuerde reiniciar la Shiny app. ui &lt;- fluidPage( titlePanel(&quot;Mi Shiny App&quot;), sidebarLayout( sidebarPanel(), mainPanel( h1(&quot;Titulo de primer nivel&quot;), h2(&quot;Titulo de segundo nivel&quot;), h3(&quot;Titulo de tercer nivel&quot;), h4(&quot;Titulo de cuarto nivel&quot;), h5(&quot;Titulo de quinto nivel&quot;), h6(&quot;Titulo de sexto nivel&quot;) ) ) ) Atención: En algunos casos, el incluir texto con tildes dentro de una Shiny app puede causar problemas con la forma en que se codifica el texto. Si le genera errores, trate removiendo los tildes. La Sihny app resultante debería ser similar a lo que se presenta en la figura 3.3. Figure 3.3: Interfase de Usuario (UI) utilizando los 6 niveles de títulos (h1 a h6). Los títulos pueden ser alineados utilizando el argumento align. En general, casi todos los atributos de identificadores HTML pueden ser usados como argumentos en una función de identificacion (tag) de Shiny. Si ud. no tiene familiaridad con los atributos de los identificadores HTML, puede verlos en algunos de los innumerables recursos que existen en la red, por ejemplo w3schools. 3.2.4 Texto con formato Shiny ofrece muchas funciones identificadoras para darle formato al texto. La forma más simple de enseñarlas es usando un ejemplo. Copie el objeto ui en su archivo ui.R o app.R y guárdelo. Si su Shiny app aun está corriendo, puede refrescar la página web y debería mostrar los cambios. ui &lt;- fluidPage( titlePanel(&quot;Mi Shiny App&quot;), sidebarLayout( sidebarPanel(), mainPanel( p(&quot;p() crea un párrafo de texto.&quot;), p(&quot;El comando p() inicia un nuevo párrafo. Se puede entregar un atributo de estilo para cambiar el formato de todo el párrafo.&quot;, style = &quot;font-family: &#39;times&#39;; font-si16pt&quot;), strong(&quot;strong() hace el texto en negritas.&quot;), em(&quot;em() crea un texto en cursiva (ej. énfasis).&quot;), br(), code(&quot;code() despliega su texto en forma similar a un código de computador&quot;), div(&quot;div() crea segmentos de texto con un estilo similar. Esta sección del texto es azul porque se pasó agumento &#39;style = color:blue&#39; a la función div()&quot;, style = &quot;color:blue&quot;), br(), p(&quot;span() hace lo mismo que div(), pero funciona con&quot;, span(&quot;un grupo de palablas&quot;, style = &quot;color:blue&quot;), &quot;que están dentro del párrafo.&quot;) ) ) ) La Shiny app resultate con esta ui se puede ver en la figura 3.4. Figure 3.4: Interfase de Usuario (UI) donde se muestran ejemplos de como formatear texto. 3.2.5 Imágenes Incluir imágenes en una plicación Shiny ayuda a mejorar significativamente la apariencia y permite a los usuarios a entender mejor el contenido. En Shiny se pueden agregar imágenes utilizando la función img. Para incluir una imagen usando la función img() se debe incluir en el argumento src el path y el nombre del archivo utilizando comillas (ej. img(src = “Path/a/mi/Imagen.png”)). Esto también se puede hacer utilizando un url si la imagen esta dispoble en una página web. La función también acepta identificadores HTML como alto (height) y ancho (width), con los números representado a píxeles. ## Utilizando una imagen local img(src = &quot;my_image.png&quot;, height = 72, width = 72) ## Utilizando una imagen en un servidor web img(src = &quot;https://www.ifop.cl/wp-content/contenidos/uploads/Logo_ifop.jpg&quot;) La función img busca la imagen en un lugar específico, los archivos de imágenes locales deben estar contenidos en el directorio www que debe estar en el mismo directorio que el archivo app.R o ui.R. Shiny comparte todos los archivos en el directorio www con el navegador del usuario, haciendo esto el lugar perfecto para poner imágenes, hojas de estilo y otras cosas que el navegador necesite para contruir los componentes web de la aplicación Shiny. Un código de ejemplo con una imagen local y otra remota se muestra a continuación. Baje el archivo rstudio.png desde [[aquí]{https://shiny.rstudio.com/tutorial/written-tutorial/lesson2/www/rstudio.png}], déjelo en el directorio www y úselo. La imagen remota no necesita ningún proceso o cambio para que la pueda utilizar. Por favor note que entre las 2 funciones img() existe una coma, esta es necesaria, de otra forma R lo interpreta como solo una función y generará un error. ui &lt;- fluidPage( titlePanel(&quot;Mi Shiny App&quot;), sidebarLayout( sidebarPanel(), mainPanel( img(src = &quot;rstudio.png&quot;, height = 140, width = 400), img(src = &quot;https://www.ifop.cl/wp-content/contenidos/uploads/Logo_ifop.jpg&quot;) ) ) ) Figure 3.5: Interfase de Usuario (UI) con una imgaen local en directorio www y una remota en un servidor web. 3.2.6 Otros Identificadores (tags) de funciones En este capítulo cubrimos los identificadores de funciones Shiny más comunes y usados, pero existen muchos otros que pueden ser utilizados. Puede aprender sobre estos otros identificadores de funciones en Customize your UI with HTML y en Shiny HTML Tags Glosay. 3.3 Actividad Cree una aplicación Shiny utilizando lo que ha aprendido sobre el diseño de los paneles, HTML y funciones de imagen para crear una interfase de uruario atractiva. Vea cuan bien entiende estas funciones recreando la aplicación Shiny app que se presenta en la figura 3.6. Utilice los ejemplos con los que hemos trabajado durante el capítulo. Figure 3.6: Imagen de la aplicación Shiny objetivo para la actividad de aprendizaje. La solución a este ejercicio se puede ver en este archivo. 3.4 Resumen Con lo que aprendió en este capítulo ud. ahora debería poder: Crear una ui con fluidPage, titlePanel y sidebarLayout. Crear un elemento HTML con alguna de las funciones identificadoras (tags) de Shiny. Definir atributos identificadores de HTML en los argumentos de cada función de identificación. Agregar un elemento a su página web pasándoselo a las funciones titlePanel, sidebarPanel o mainPanel. Agregar múltiples elementos a cada panel al separarlos con una coma. Usar la función img() para agregar a su aplicación Shiny imágenes existentes en la carpeta www o en un servidor web. Ahora que ya puede agrear contenido en su ui tenemos que ver como trabajar con contenido más complejo, como por ejemplo complementos (widgets). Widgets son los elementos interactivos que el usuario manipula para controlar la aplicación. Recuerde que esta es la función que crea el espacio de la UI que se ajusta al tamaño del navegador del usuario.↩ "],
["controles.html", "4 Controles 4.1 Objetivos", " 4 Controles lknfdaa 4.1 Objetivos In this lesson, you will learn: About open data archives, especially the Arctic Data Center What science metadata are and how they can be used How data and code can be documented and published in open data archives Web-based submission Submission using R "],
["desplique-de-las-salidas-interactivas.html", "5 Desplique de las salidas interactivas 5.1 Objetivos 5.2 Reproducible Research 5.3 Why use git? 5.4 Checking the RStudio environment 5.5 Setting up git", " 5 Desplique de las salidas interactivas 5.1 Objetivos In this lesson, you will learn: What computational reproducibility is and why it is useful How version control can increase computational reproducibility How to check to make sure your RStudio environment is set up properly for analysis How to set up git 5.2 Reproducible Research Reproducibility is the hallmark of science, which is based on empirical observations coupled with explanatory models. While reproducibility encompasses the full science lifecycle, and includes issues such as methodological consistency and treatment of bias, in this course we will focus on computational reproducibility: the ability to document data, analyses, and models sufficiently for other researchers to be able to understand and ideally re-execute the computations that led to scientific results and conclusions. 5.2.1 What is needed for computational reproducibility? The first step towards addressing these issues is to be able to evaluate the data, analyses, and models on which conclusions are drawn. Under current practice, this can be difficult because data are typically unavailable, the method sections of papers do not detail the computational approaches used, and analyses and models are often conducted in graphical programs, or, when scripted analyses are employed, the code is not available. And yet, this is easily remedied. Researchers can achieve computational reproducibility through open science approaches, including straightforward steps for archiving data and code openly along with the scientific workflows describing the provenance of scientific results (e.g., (???), (???)). 5.2.2 Conceptualizing workflows Scientific workflows encapsulate all of the steps from data acquisition, cleaning, transformation, integration, analysis, and visualization. Figure 5.1: Scientific workflows and provenance capture the multiple steps needed to reproduce a scientific result from raw data. Workflows can range in detail from simple flowcharts (5.1) to fully executable scripts. R scripts and python scripts are a textual form of a workflow, and when researchers publish specific versions of the scripts and data used in an analysis, it becomes far easier to repeat their computations and understand the provenance of their conclusions. 5.3 Why use git? 5.3.1 The problem with filenames Every file in the scientific process changes. Manuscripts are edited. Figures get revised. Code gets fixed when problems are discovered. Data files get combined together, then errors are fixed, and then they are split and combined again. In the course of a single analysis, one can expect thousands of changes to files. And yet, all we use to track this are simplistic filenames. You might think there is a better way, and you’d be right: version control. Version control systems help you track all of the changes to your files, without the spaghetti mess that ensues from simple file renaming. In version control systems like git, the system tracks not just the name of the file, but also its contents, so that when contents change, it can tell you which pieces went where. It tracks which version of a file a new version came from. So its easy to draw a graph showing all of the versions of a file, like this one: Version control systems assign an identifier to every version of every file, and track their relationships. They also allow branches in those versions, and merging those branches back into the main line of work. They also support having multiple copies on multiple computers for backup, and for collaboration. And finally, they let you tag particular versions, such that it is easy to return to a set of files exactly as they were when you tagged them. For example, the exact versions of data, code, and narrative that were used when a manuscript was submitted might be R2 in the graph above. 5.4 Checking the RStudio environment 5.4.1 R Version We will use R version 3.5.2, which you can download and install from CRAN. To check your version, run this in your RStudio console: R.version$version.string 5.4.2 RStudio Version We will be using RStudio version 1.1.463 or later, which you can download and install here To check your RStudio version, run the following in your RStudio console: RStudio.Version()$version If the output of this does not say 1.1.463, you should update your RStudio. Do this by selecting Help -&gt; Check for Updates and follow the prompts. 5.4.3 Package installation Run the following lines to check that all of the packages we need for the training are installed on your computer. packages &lt;- c(&quot;devtools&quot;, &quot;dplyr&quot;, &quot;DT&quot;, &quot;ggplot2&quot;, &quot;leaflet&quot;, &quot;roxygen2&quot;, &quot;tidyr&quot;) for (package in packages) { if (!(package %in% installed.packages())) { install.packages(package) } } rm(packages) #remove variables from workspace If you haven’t installed all of the packages, this will automatically start installing them. If they are installed, it won’t do anything. Next, create a new R Markdown (File -&gt; New File -&gt; R Markdown). If you have never made an R Markdown document before, a dialog box will pop up asking if you wish to install the required packages. Click yes. 5.5 Setting up git If you haven’t already, go to github.com and create an account. If you haven’t downloaded git already, you can download it here. Before using git, you need to tell it who you are, also known as setting the global options. The only way to do this is through the command line. Newer versions of RStudio have a nice feature where you can open a terminal window in your RStudio session. Do this by selecting Tools -&gt; Terminal -&gt; New Terminal. A terminal tab should now be open where your console usually is. To set the global options, type the following into the command prompt, with your actual name, and press enter: git config --global user.name &quot;Your Name&quot; Next, enter the following line, with the email address you used when you created your account on github.com: git config --global user.email &quot;yourEmail@emaildomain.com&quot; Note that these lines need to be run one at a time. Finally, check to make sure everything looks correct by entering this line, which will return the options that you have set. git config --global --list 5.5.1 Note for Windows Users If you get “command not found” (or similar) when you try these steps through the RStudio terminal tab, you may need to set the type of terminal that gets launched by RStudio. Under some git install senerios, the git executable may not be available to the default terminal type. "],
["preparacion-de-datos-para-la-aplicacion-web.html", "6 Preparacion de datos para la aplicacion web 6.1 Learning Objectives 6.2 Introduction 6.3 Setup 6.4 About the pipe (%&gt;%) operator 6.5 Selecting/removing columns: select() 6.6 Changing shape: gather() and spread() 6.7 Renaming columns with rename() 6.8 Adding columns: mutate() 6.9 group_by and summarise 6.10 Filtering rows: filter() 6.11 Sorting your data: arrange() 6.12 Joins in dplyr 6.13 separate() and unite() 6.14 Summary", " 6 Preparacion de datos para la aplicacion web 6.1 Learning Objectives In this lesson, you will learn: What the Split-Apply-Combine strategy is and how it applies to data The difference between wide vs. tall table formats and how to convert between them How to use dplyr and tidyr to clean and manipulate data for analysis How to join multiple data.frames together using dplyr 6.2 Introduction The data we get to work with are rarely, if ever, in the format we need to do our analyses. It’s often the case that one package requires data in one format, while another package requires the data to be in another format. To be efficient analysts, we should have good tools for reformatting data for our needs so we can do our actual work like making plots and fitting models. The dplyr and tidyr R packages provide a fairly complete and extremely powerful set of functions for us to do this reformatting quickly and learning these tools well will greatly increase your efficiency as an analyst. Analyses take many shapes, but they often conform to what is known as the Split-Apply-Combine strategy. This strategy follows a usual set of steps: Split: Split the data into logical groups (e.g., area, stock, year) Apply: Calculate some summary statistic on each group (e.g. mean total length by year) Combine: Combine the groups back together into a single table Figure 1: diagram of the split apply combine strategy As shown above (Figure 1), our original table is split into groups by year, we calculate the mean length for each group, and finally combine the per-year means into a single table. dplyr provides a fast and powerful way to express this. Let’s look at a simple example of how this is done: Assuming our length data is already loaded in a data.frame called length_data: year length_cm 1991 5.673318 1991 3.081224 1991 4.592696 1992 4.381523 1992 5.597777 1992 4.900052 1992 4.139282 1992 5.422823 1992 5.905247 1992 5.098922 We can do this calculation using dplyr like this: length_data %&gt;% group_by(year) %&gt;% summarise(mean_length_cm = mean(length_cm)) Another exceedingly common thing we need to do is “reshape” our data. Let’s look at an example table that is in what we will call “wide” format: site 1990 1991 … 1993 gold 100 118 … 112 lake 100 118 … 112 … … … … … dredge 100 118 … 112 You are probably quite familiar with data in the above format, where values of the variable being observed are spread out across columns (Here: columns for each year). Another way of describing this is that there is more than one measurement per row. This wide format works well for data entry and sometimes works well for analysis but we quickly outgrow it when using R. For example, how would you fit a model with year as a predictor variable? In an ideal world, we’d be able to just run: lm(length ~ year) But this won’t work on our wide data because lm needs length and year to be columns in our table. Or how would we make a separate plot for each year? We could call plot one time for each year but this is tedious if we have many years of data and hard to maintain as we add more years of data to our dataset. The tidyr package allows us to quickly switch between wide format and what is called tall format using the gather function: site_data %&gt;% gather(year, length, -site) site year length gold 1990 101 lake 1990 104 dredge 1990 144 … … … dredge 1993 145 In this lesson we’re going to walk through the functions you’ll most commonly use from the dplyr and tidyr packages: dplyr mutate() group_by() summarise() select() filter() arrange() left_join() rename() tidyr gather() spread() extract() separate() 6.3 Setup Let’s start going over the most common functions you’ll use from the dplyr package. To demonstrate, we’ll be working with a tidied up version of a dataset from ADF&amp;G containing commercial catch data from 1878-1997. The dataset and reference to the original source can be found at its public archive: https://knb.ecoinformatics.org/#view/df35b.304.2. First, let’s load dplyr and tidyr: library(dplyr) library(tidyr) Then let’s read in the data and take a look at it: catch_original &lt;- read.csv(url(&quot;https://knb.ecoinformatics.org/knb/d1/mn/v2/object/df35b.302.1&quot;, method = &quot;libcurl&quot;), stringsAsFactors = FALSE) head(catch_original) ## Region Year Chinook Sockeye Coho Pink Chum All notesRegCode ## 1 SSE 1886 0 5 0 0 0 5 ## 2 SSE 1887 0 155 0 0 0 155 ## 3 SSE 1888 0 224 16 0 0 240 ## 4 SSE 1889 0 182 11 92 0 285 ## 5 SSE 1890 0 251 42 0 0 292 ## 6 SSE 1891 0 274 24 0 0 298 Note: I copied the URL from the Download button on https://knb.ecoinformatics.org/#view/df35b.304.2 This dataset is relatively clean and easy to interpret as-is. But while it may be clean, it’s in a shape that makes it hard to use for some types of analyses so we’ll want to fix that first. 6.4 About the pipe (%&gt;%) operator Before we jump into learning tidyr and dplyr, we first need to explain the %&gt;%. Both the tidyr and the dplyr packages use the pipe operator - %&gt;%, which may look unfamiliar. The pipe is a powerful way to efficiently chain together operations. The pipe will take the output of a previous statement, and use it as the input to the next statement. Say you want to both filter out rows of a dataset, and select certain columns. Instead of writing df_filtered &lt;- filter(df, ...) df_selected &lt;- select(df_filtered, ...) You can write df_cleaned &lt;- df %&gt;% filter(...) %&gt;% select(...) If you think of the assignment operator (&lt;-) as reading like “gets”, then the pipe operator would read like “then.” So you might think of the above chunk being translated as: The cleaned dataframe gets the original data, and then a filter (of the original data), and then a select (of the filtered data). The benefits to using pipes are that you don’t have to keep track of (or overwrite) intermediate data frames. The drawbacks are that it can be more difficult to explain the reasoning behind each step, especially when many operations are chained together. It is good to strike a balance between writing efficient code (chaining operations), while ensuring that you are still clearly explaining, both to your future self and others, what you are doing and why you are doing it. RStudio has a keyboard shortcut for %&gt;% : Ctrl + Shift + M (Windows), Cmd + Shift + M (Mac). 6.5 Selecting/removing columns: select() The first issue is the extra columns All and notesRegCode. Let’s select only the columns we want, and assign this to a variable called catch_data. catch_data &lt;- catch_original %&gt;% select(Region, Year, Chinook, Sockeye, Coho, Pink, Chum) head(catch_data) ## Region Year Chinook Sockeye Coho Pink Chum ## 1 SSE 1886 0 5 0 0 0 ## 2 SSE 1887 0 155 0 0 0 ## 3 SSE 1888 0 224 16 0 0 ## 4 SSE 1889 0 182 11 92 0 ## 5 SSE 1890 0 251 42 0 0 ## 6 SSE 1891 0 274 24 0 0 Much better! select also allows you to say which columns you don’t want, by passing unquoted column names preceded by minus (-) signs: catch_data &lt;- catch_original %&gt;% select(-All, -notesRegCode) head(catch_data) ## Region Year Chinook Sockeye Coho Pink Chum ## 1 SSE 1886 0 5 0 0 0 ## 2 SSE 1887 0 155 0 0 0 ## 3 SSE 1888 0 224 16 0 0 ## 4 SSE 1889 0 182 11 92 0 ## 5 SSE 1890 0 251 42 0 0 ## 6 SSE 1891 0 274 24 0 0 6.6 Changing shape: gather() and spread() The next issue is that the data are in a wide format and, we want the data in a tall format instead. gather() from the tidyr package helps us do just this conversion: catch_long &lt;- catch_data %&gt;% gather(species, catch, -Region, -Year) head(catch_long) ## Region Year species catch ## 1 SSE 1886 Chinook 0 ## 2 SSE 1887 Chinook 0 ## 3 SSE 1888 Chinook 0 ## 4 SSE 1889 Chinook 0 ## 5 SSE 1890 Chinook 0 ## 6 SSE 1891 Chinook 0 The syntax we used above for gather() might be a bit confusing so let’s look at an annotated diagram: annotated gather code The first two arguments to gather() are the names of new columns that will be created and the other arguments with - symbols in front of them are columns to keep around in this process. The opposite of gather(), spread(), works in a similar declarative fashion: catch_wide &lt;- catch_long %&gt;% spread(species, catch) head(catch_wide) ## Region Year Chinook Chum Coho Pink Sockeye ## 1 ALU 1911 0 0 0 0 9 ## 2 ALU 1912 0 0 0 0 0 ## 3 ALU 1913 0 0 0 0 0 ## 4 ALU 1914 0 0 0 0 0 ## 5 ALU 1915 0 0 0 0 0 ## 6 ALU 1916 0 0 1 180 76 6.7 Renaming columns with rename() If you scan through the data, you may notice the values in the catch column are very small (these are supposed to be annual catches). If we look at the metadata we can see that the catch column is in thousands of fish so let’s convert it before moving on. Let’s first rename the catch column to be called catch_thousands: catch_clean &lt;- catch_long %&gt;% rename(catch_thousands = catch) head(catch_clean) ## Region Year species catch_thousands ## 1 SSE 1886 Chinook 0 ## 2 SSE 1887 Chinook 0 ## 3 SSE 1888 Chinook 0 ## 4 SSE 1889 Chinook 0 ## 5 SSE 1890 Chinook 0 ## 6 SSE 1891 Chinook 0 6.8 Adding columns: mutate() Now let’s create a new column called catch with units of fish (instead of thousands of fish). Note that here we have added to the expression we wrote above by adding another function call (mutate) to our expression. This takes advantage of the pipe operator by grouping together a similar set of statements, which all aim to clean up the catch_long data.frame. catch_clean &lt;- catch_long %&gt;% rename(catch_thousands = catch) %&gt;% mutate(catch = catch_thousands * 1000) head(catch_clean) You’ll notice that we get an error: Error in mutate_impl(.data, dots) : Evaluation error: non-numeric argument to binary operator. This is an extremely cryptic error – what is it telling us? These kinds of errors can be very hard to diagnose, but maybe the catch column isn’t quite what we are expecting. How could we find out? R provides a number of handy utility functions for quickly summarizing a large table: summary(catch_clean) ## Region Year species catch_thousands ## Length:8540 Min. :1878 Length:8540 Length:8540 ## Class :character 1st Qu.:1922 Class :character Class :character ## Mode :character Median :1947 Mode :character Mode :character ## Mean :1946 ## 3rd Qu.:1972 ## Max. :1997 Exercise: What are some other ways (functions) we could’ve found out what our problem was? Notice in the above output that the catch_thousands column shows up as Class :character. That seems wrong since catch should be whole numbers (in R, these show up as integers). Let’s try to convert the values to integers and see what happens: catch_integers &lt;- as.integer(catch_clean$catch_thousands) ## Warning: NAs introduced by coercion We get an error “NAs introduced by coercion” which is R telling us that it couldn’t convert every value to an integer and, for those values it couldn’t convert, it put an NA in its place. This is behavior we commonly experience when cleaning datasets and it’s important to have the skills to deal with it when it crops up. We can find out which values are NAs with a combination of is.na() and which(), and save that to a variable called i. i &lt;- which(is.na(catch_integers)) i ## [1] 401 It looks like there is only one problem row, lets have a look at it: catch_clean[i,] ## Region Year species catch_thousands ## 401 GSE 1955 Chinook I Well that’s odd: The value in catch_thousands is I which is isn’t even a number. It turns out that this dataset is from a PDF which was automatically converted into a CSV and this value of I is actually a 1. Let’s fix it: catch_clean &lt;- catch_long %&gt;% rename(catch_thousands = catch) %&gt;% mutate(catch_thousands = ifelse(catch_thousands == &quot;I&quot;, 1, catch_thousands)) %&gt;% mutate(catch_thousands = as.integer(catch_thousands)) head(catch_clean) ## Region Year species catch_thousands ## 1 SSE 1886 Chinook 0 ## 2 SSE 1887 Chinook 0 ## 3 SSE 1888 Chinook 0 ## 4 SSE 1889 Chinook 0 ## 5 SSE 1890 Chinook 0 ## 6 SSE 1891 Chinook 0 Note that, in the above pipeline call to mutate(), we mutate catch_thousands twice. This works because mutate() processes each of the mutations in a step-wise fashion so the results of one mutation are available for the next. Now let’s try our conversion again by adding it as another function call in our expression. catch_clean &lt;- catch_long %&gt;% rename(catch_thousands = catch) %&gt;% mutate(catch_thousands = ifelse(catch_thousands == &quot;I&quot;, 1, catch_thousands)) %&gt;% mutate(catch_thousands = as.integer(catch_thousands)) %&gt;% mutate(catch = catch_thousands * 1000) head(catch_clean) ## Region Year species catch_thousands catch ## 1 SSE 1886 Chinook 0 0 ## 2 SSE 1887 Chinook 0 0 ## 3 SSE 1888 Chinook 0 0 ## 4 SSE 1889 Chinook 0 0 ## 5 SSE 1890 Chinook 0 0 ## 6 SSE 1891 Chinook 0 0 Looks good, no warnings! Now let’s remove the catch_thousands column for now since we don’t need it: catch_clean &lt;- catch_long %&gt;% rename(catch_thousands = catch) %&gt;% mutate(catch_thousands = ifelse(catch_thousands == &quot;I&quot;, 1, catch_thousands)) %&gt;% mutate(catch_thousands = as.integer(catch_thousands)) %&gt;% mutate(catch = catch_thousands * 1000) %&gt;% select(-catch_thousands) head(catch_clean) ## Region Year species catch ## 1 SSE 1886 Chinook 0 ## 2 SSE 1887 Chinook 0 ## 3 SSE 1888 Chinook 0 ## 4 SSE 1889 Chinook 0 ## 5 SSE 1890 Chinook 0 ## 6 SSE 1891 Chinook 0 We’re now ready to start analyzing the data. 6.9 group_by and summarise As I outlined in the Introduction, dplyr lets us employ the Split-Apply-Combine strategy and this is exemplified through the use of the group_by() and summarise() functions: mean_region &lt;- catch_clean %&gt;% group_by(Region) %&gt;% summarise(mean(catch)) head(mean_region) ## # A tibble: 6 x 2 ## Region `mean(catch)` ## &lt;chr&gt; &lt;dbl&gt; ## 1 ALU 40384. ## 2 BER 16373. ## 3 BRB 2709796. ## 4 CHG 315487. ## 5 CKI 683571. ## 6 COP 179223. Exercise: Find another grouping and statistic to calculate for each group. Exercise: Find out if you can group by multiple variables. Another common use of group_by() followed by summarize() is to count the number of rows in each group. We have to use a special function from dplyr, n(). n_region &lt;- catch_clean %&gt;% group_by(Region) %&gt;% summarize(n = n()) head(n_region) ## # A tibble: 6 x 2 ## Region n ## &lt;chr&gt; &lt;int&gt; ## 1 ALU 435 ## 2 BER 510 ## 3 BRB 570 ## 4 CHG 550 ## 5 CKI 525 ## 6 COP 470 6.10 Filtering rows: filter() filter() is the verb we use to filter our data.frame to rows matching some condition. It’s similar to subset() from base R. Let’s go back to our original data.frame and do some filter()ing: SSE_catch &lt;- catch_clean %&gt;% filter(Region == &quot;SSE&quot;) head(SSE_catch) ## Region Year species catch ## 1 SSE 1886 Chinook 0 ## 2 SSE 1887 Chinook 0 ## 3 SSE 1888 Chinook 0 ## 4 SSE 1889 Chinook 0 ## 5 SSE 1890 Chinook 0 ## 6 SSE 1891 Chinook 0 Exercise: Filter to just catches of over one million fish. Exercise: Filter to just SSE Chinook 6.11 Sorting your data: arrange() arrange() is how we sort the rows of a data.frame. In my experience, I use arrange() in two common cases: When I want to calculate a cumulative sum (with cumsum()) so row order matters When I want to display a table (like in an .Rmd document) in sorted order Let’s re-calculate mean catch by region, and then arrange() the output by mean catch: mean_region &lt;- catch_clean %&gt;% group_by(Region) %&gt;% summarise(mean_catch = mean(catch)) %&gt;% arrange(mean_catch) head(mean_region) ## # A tibble: 6 x 2 ## Region mean_catch ## &lt;chr&gt; &lt;dbl&gt; ## 1 BER 16373. ## 2 KTZ 18836. ## 3 ALU 40384. ## 4 NRS 51503. ## 5 KSK 67642. ## 6 YUK 68646. The default sorting order of arrange() is to sort in ascending order. To reverse the sort order, wrap the column name inside the desc() function: mean_region &lt;- catch_clean %&gt;% group_by(Region) %&gt;% summarise(mean_catch = mean(catch)) %&gt;% arrange(desc(mean_catch)) head(mean_region) ## # A tibble: 6 x 2 ## Region mean_catch ## &lt;chr&gt; &lt;dbl&gt; ## 1 SSE 3184661. ## 2 BRB 2709796. ## 3 NSE 1825021. ## 4 KOD 1528350 ## 5 PWS 1419237. ## 6 SOP 1110942. 6.12 Joins in dplyr So now that we’re awesome at manipulating a single data.frame, where do we go from here? Manipulating more than one data.frame. If you’ve ever used a database, you may have heard of or used what’s called a “join”, which allows us to to intelligently merge two tables together into a single table based upon a shared column between the two. We’ve already covered joins in [Data Modeling &amp; Tidy Data] so let’s see how it’s done with dplyr. The dataset we’re working with, https://knb.ecoinformatics.org/#view/df35b.304.2, contains a second CSV which has the definition of each Region code. This is a really common way of storing auxiliary information about our dataset of interest (catch) but, for analylitcal purposes, we often want them in the same data.frame. Joins let us do that easily. Let’s look at a preview of what our join will do by looking at a simplified version of our data: Visualisation of our left_join First, let’s read in the region definitions data table and select only the columns we want. Note that I have piped my read.csv result into a select call, creating a tidy chunk that reads and selects the data that we need. region_defs &lt;- read.csv(url(&quot;https://knb.ecoinformatics.org/knb/d1/mn/v2/object/df35b.303.1&quot;, method = &quot;libcurl&quot;), stringsAsFactors = FALSE) %&gt;% select(code, mgmtArea) head(region_defs) ## code mgmtArea ## 1 GSE Unallocated Southeast Alaska ## 2 NSE Northern Southeast Alaska ## 3 SSE Southern Southeast Alaska ## 4 YAK Yakutat ## 5 PWSmgmt Prince William Sound Management Area ## 6 BER Bering River Subarea Copper River Subarea If you examine the region_defs data.frame, you’ll see that the column names don’t exactly match the image above. If the names of the key columns are not the same, you can explicitly specify which are the key columns in the left and right side as shown below: catch_joined &lt;- left_join(catch_clean, region_defs, by = c(&quot;Region&quot; = &quot;code&quot;)) head(catch_joined) ## Region Year species catch mgmtArea ## 1 SSE 1886 Chinook 0 Southern Southeast Alaska ## 2 SSE 1887 Chinook 0 Southern Southeast Alaska ## 3 SSE 1888 Chinook 0 Southern Southeast Alaska ## 4 SSE 1889 Chinook 0 Southern Southeast Alaska ## 5 SSE 1890 Chinook 0 Southern Southeast Alaska ## 6 SSE 1891 Chinook 0 Southern Southeast Alaska Notice that I have deviated from our usual pipe syntax (although it does work here!) because I prefer to see the data.frames that I am joining side by side in the syntax. Another way you can do this join is to use rename to change the column name code to Region in the region_defs data.frame, and run the left_join this way: region_defs &lt;- region_defs %&gt;% rename(Region = code, Region_Name = mgmtArea) catch_joined &lt;- left_join(catch_clean, region_defs, by = c(&quot;Region&quot;)) head(catch_joined) Now our catches have the auxiliary information from the region definitions file alongside them. Note: dplyr provides a complete set of joins: inner, left, right, full, semi, anti, not just left_join. 6.13 separate() and unite() separate() and its complement, unite() allow us to easily split a single column into numerous (or numerous into a single). This can come in really handle when we have a date column and we want to group by year or month. Let’s make a new data.frame with fake data to illustrate this: dates_df &lt;- data.frame(date = c(&quot;5/24/1930&quot;, &quot;5/25/1930&quot;, &quot;5/26/1930&quot;, &quot;5/27/1930&quot;, &quot;5/28/1930&quot;), stringsAsFactors = FALSE) dates_df %&gt;% separate(date, c(&quot;month&quot;, &quot;day&quot;, &quot;year&quot;), &quot;/&quot;) ## month day year ## 1 5 24 1930 ## 2 5 25 1930 ## 3 5 26 1930 ## 4 5 27 1930 ## 5 5 28 1930 Exercise: Split the city column in the following data.frame into city and state_code columns: cities_df &lt;- data.frame(city = c(&quot;Juneau AK&quot;, &quot;Sitka AK&quot;, &quot;Anchorage AK&quot;), stringsAsFactors = FALSE) # Write your solution here unite() does just the reverse of separate(): dates_df %&gt;% separate(date, c(&quot;month&quot;, &quot;day&quot;, &quot;year&quot;), &quot;/&quot;) %&gt;% unite(date, month, day, year, sep = &quot;/&quot;) ## date ## 1 5/24/1930 ## 2 5/25/1930 ## 3 5/26/1930 ## 4 5/27/1930 ## 5 5/28/1930 Exercise: Use unite() on your solution above to combine the cities_df back to its original form with just one column, city: # Write your solution here 6.14 Summary We just ran through the various things we can do with dplyr and tidyr but if you’re wondering how this might look in a real analysis. Let’s look at that now: catch_original &lt;- read.csv(url(&quot;https://knb.ecoinformatics.org/knb/d1/mn/v2/object/df35b.302.1&quot;, method = &quot;libcurl&quot;), stringsAsFactors = FALSE) region_defs &lt;- read.csv(url(&quot;https://knb.ecoinformatics.org/knb/d1/mn/v2/object/df35b.303.1&quot;, method = &quot;libcurl&quot;), stringsAsFactors = FALSE) %&gt;% select(code, mgmtArea) mean_region &lt;- catch_original %&gt;% select(-All, -notesRegCode) %&gt;% gather(species, catch, -Region, -Year) %&gt;% mutate(catch = ifelse(catch == &quot;I&quot;, 1, catch)) %&gt;% mutate(catch = as.integer(catch)*1000) %&gt;% group_by(Region) %&gt;% summarize(mean_catch = mean(catch)) %&gt;% left_join(region_defs, by = c(&quot;Region&quot; = &quot;code&quot;)) head(mean_region) ## # A tibble: 6 x 3 ## Region mean_catch mgmtArea ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 ALU 40384. Aleutian Islands Subarea ## 2 BER 16373. Bering River Subarea Copper River Subarea ## 3 BRB 2709796. Bristol Bay Management Area ## 4 CHG 315487. Chignik Management Area ## 5 CKI 683571. Cook Inlet Management Area ## 6 COP 179223. Copper River Subarea "],
["control-de-versiones-con-git-y-github.html", "7 Control de versiones con git y GitHub 7.1 Learning Objectives 7.2 The problem with filenames 7.3 Version control and Collaboration using Git and GitHub 7.4 Let’s look at a GitHub repository 7.5 The Git lifecycle 7.6 Create a remote repository on GitHub 7.7 Working locally with Git via RStudio 7.8 On good commit messages 7.9 Collaboration and conflict free workflows 7.10 Exercise 7.11 Advanced topics", " 7 Control de versiones con git y GitHub 7.1 Learning Objectives In this lesson, you will learn: Why git is useful for reproducible analysis How to use git to track changes to your work over time How to use GitHub to collaborate with others How to structure your commits so your changes are clear to others How to write effective commit messages 7.2 The problem with filenames Every file in the scientific process changes. Manuscripts are edited. Figures get revised. Code gets fixed when problems are discovered. Data files get combined together, then errors are fixed, and then they are split and combined again. In the course of a single analysis, one can expect thousands of changes to files. And yet, all we use to track this are simplistic filenames. You might think there is a better way, and you’d be right: version control. Version control systems help you track all of the changes to your files, without the spaghetti mess that ensues from simple file renaming. In version control systems like git, the system tracks not just the name of the file, but also its contents, so that when contents change, it can tell you which pieces went where. It tracks which version of a file a new version came from. So its easy to draw a graph showing all of the versions of a file, like this one: Version control systems assign an identifier to every version of every file, and track their relationships. They also allow branches in those versions, and merging those branches back into the main line of work. They also support having multiple copies on multiple computers for backup, and for collaboration. And finally, they let you tag particular versions, such that it is easy to return to a set of files exactly as they were when you tagged them. For example, the exact versions of data, code, and narrative that were used when a manuscript was submitted might be R2 in the graph above. 7.3 Version control and Collaboration using Git and GitHub Let’s distinguish between git and GitHub: git: version control software used to track files in a folder (a repository) git creates the versioned history of a repository GitHub: web site that allows users to store their git repositories and share them with others 7.4 Let’s look at a GitHub repository This screen shows the copy of a repository stored on GitHub, with its list of files, when the files and directories were last modified, and some information on who made the most recent changes. If we drill into the “commits” for the repository, we can see the history of changes made to all of the files. Looks like kellijohnson and seananderson were fixing things in June and July: And finally, if we drill into the changes made on June 13, we can see exactly what was changed in each file: Tracking these changes, how they relate to released versions of software and files is exactly what Git and GitHub are good for. And we will show how they can really be effective for tracking versions of scientific code, figures, and manuscripts to accomplish a reproducible workflow. 7.5 The Git lifecycle As a git user, you’ll need to understand the basic concepts associated with versioned sets of changes, and how they are stored and moved across repositories. Any given git repository can be cloned so that it exist both locally, and remotely. But each of these cloned repositories is simply a copy of all of the files and change history for those files, stored in git’s particular format. For our purposes, we can consider a git repository just a folder with a bunch of additional version-related metadata. In a local git-enabled folder, the folder contains a workspace containing the current version of all files in the repository. These working files are linked to a hidden folder containing the ‘Local repository’, which contains all of the other changes made to the files, along with the version metadata. So, when working with files using git, you can use git commands to indicate specifically which changes to the local working files should be staged for versioning (using the git add command), and when to record those changes as a version in the local repository (using the command git commit). The remaining concepts are involved in synchronizing the changes in your local repository with changes in a remote repository. The git push command is used to send local changes up to a remote repository (possibly on GitHub), and the git pull command is used to fetch changes from a remote repository and merge them into the local repository. git clone: to copy a whole remote repository to local git add (stage): notify git to track particular changes git commit: store those changes as a version git pull: merge changes from a remote repository to our local repository git push: copy changes from our local repository to a remote repository git status: determine the state of all files in the local repository git log: print the history of changes in a repository Those seven commands are the majority of what you need to successfully use git. But this is all super abstract, so let’s explore with some real examples. 7.6 Create a remote repository on GitHub Let’s start by creating a repository on GitHub, then we’ll edit some files. Log into GitHub Click the New repository button Name it sasap-test Create a README.md Set the LICENSE to Apache 2.0 You’ve now created your first repository! It has a couple of files that GitHub created for you, like the README.md file, and the LICENSE file, and the .gitignore file. For simple changes to text files, you can make edits right in the GitHub web interface. For example, navigate to the README.md file in the file listing, and edit it by clicking on the pencil icon. This is a regular Markdown file, so you can just add text, and when done, add a commit message, and hit the Commit changes button. Congratulations, you’ve now authored your first versioned commit. If you navigate back to the GitHub page for the repository, you’ll see your commit listed there, as well as the rendered README.md file. Let’s point out a few things about this window. It represents a view of the repository that you created, showing all of the files in the repository so far. For each file, it shows when the file was last modified, and the commit message that was used to last change each file. This is why it is important to write good, descriptive commit messages. In addition, the blue header above the file listing shows the most recent commit, along with its commit message, and its SHA identifer. That SHA identifier is the key to this set of versioned changes. If you click on the SHA identifier (810f314), it will display the set of changes made in that particular commit. In the next section we’ll use the GitHub URL for the GitHub repository you created to clone the repository onto your local machine so that you can edit the files in RStudio. To do so, start by copying the GitHub URL, which represents the repository location: 7.7 Working locally with Git via RStudio RStudio knows how to work with files under version control with Git, but only if you are working within an RStudio project folder. In this next section, we will clone the repository that you created on GitHub into a local repository as an RStudio project. Here’s what we’re going to do: Create the new project Inspect the Git tab and version history Commit a change to the README.md file Commit the changes that RStudio made Inspect the version history Add and commit an Rmd file Push these changes to GitHub View the change history on GitHub Create a New Project. Start by creating a New Project… in R Studio, select the Version Control option, and paste the GitHub URL that you copied into the field for the remote repository Repository URL. While you can name the local copy of the repository anything, its typical to use the same name as the GitHub repository to maintain the correspondence. You can choose any folder for your local copy, in my case I used my standard development folder. Once you hit `Create Project, a new RStudio windo will open with all of the files from the remote repository copied locally. Depending on how your version of RStudio is configured, the location and size of the panes may differ, but they should all be present, including a Git tab and the normal Files tab listing the files that had been created in the remote repository. You’ll note that there is one new file sasap-test.Rproj, and three files that we created earlier on GitHub (.gitignore, LICENSE, and README.md). In the Git tab, you’ll note that two files are listed. This is the status pane that shows the current modification status of all of the files in the repository. In this case, the .gitignore file is listed as M for Modified, and sasap-test.Rproj is listed with a ? ? to indicate that the file is untracked. This means that git has not stored any versions of this file, and knows nothing about the file. As you make version control decisions in RStudio, these icons will change to reflect the current version status of each of the files. Inspect the history. For now, let’s click on the History button in the Git tab, which will show the log of changes that occurred, and will be identical to what we viewed on GitHub. By clicking on each row of the history, you can see exactly what was added and changed in each of the two commits in this repository. Commit a README.md change. Next let’s make a change to the README.md file in RStudio. Add a new section, with a markdown block like this: ## Git from RStudio From within RStudio, we can perform the same versioning actions that we can in GitHub, and much more. Plus, we have the natural advantages of the programming IDE with code completion and other features to make our work easier. - Add files to version control - Commit changes - Push commits to GitHub Once you save, you’ll immediately see the README.md file show up in the Git tab, marks as a modification. You can select the file in the Git tab, and click Diff to see the differences that you saved (but which are not yet committed to your local repository). And here’s what the newly made changes look like compared to the original file. New lines are highlighted in green, while removed lines are in red. Commit the RStudio changes. To commit the changes you made to the README.md file, check the Staged checkbox next to the file (which tells Git which changes you want included in the commit), then provide a descriptive Commit message, and then click Commit. Note that some of the changes in the repository, namely .gitignore and sasap-test.Rproj are still listed as having not been committed. This means there are still pending changes to the repository. You can also see the note that says: Your branch is ahead of ‘origin/master’ by 1 commit. This means that we have committed 1 change in the local repository, but that commit has not yet been pushed up to the origin repository, where origin is the typical name for our remote repository on GitHub. So, let’s commit the remaining project files by staging them and adding a commit message. When finished, you’ll see that no changes remain in the Git tab, and the repository is clean. Inspect the history. Note that the message now says: Your branch is ahead of ‘origin/master’ by 2 commits. These 2 commits are the two we just made, and have not yet been pushed to GitHub. By clicking on the History button, we can see that there are now a total of four commits in the local repository (while there had only been two on GitHub). Push these changes to GitHub. Now that everything has been changed as desired locally, you can push the changes to GitHub using the Push button. This will prompt you for your GitHub username and password, and upload the changes, leaving your repository in a totally clean and synchronized state. When finished, looking at the history shows all four commits, including the two that were done on GitHub and the two that were done locally on RStudio. And note that the labels indicate that both the local repository (HEAD) and the remote repository (origin/HEAD) are pointing at the same version in the history. So, if we go look at the commit history on GitHub, all the commits will be shown there as well. 7.8 On good commit messages Clearly, good documentation of what you’ve done is critical to making the version history of your repository meaningful and helpful. Its tempting to skip the commit message altogether, or to add some stock blurd like ‘Updates’. Its better to use messages that will be helpful to your future self in deducing not just what you did, but why you did it. Also, commit messaged are best understood if they follow the active verb convention. For example, you can see that my commit messages all started with a past tense verb, and then explained what was changed. While some of the changes we illustrated here were simple and so easily explained in a short phrase, for more complext changes, its best to provide a more complete message. The convention, however, is to always have a short, terse first sentence, followed by a more verbose explanation of the details and rationale for the change. This keeps the high level details readable in the version log. I can’t count the number of times I’ve looked at the commit log from 2, 3, or 10 years prior and been so grateful for diligence of my past self and collaborators. 7.9 Collaboration and conflict free workflows Up to now, we have been focused on using Git and GitHub for yourself, which is a great use. But equally powerful is to share a GitHib repository with other researchers so that you can work on code, analyses, and models together. When working together, you will need to pay careful attention to the state of the remote repository to avoid and handle merge conflicts. A merge conflict occurs when two collaborators make two separate commits that change the same lines of the same file. When this happens, git can’t merge the changes together automatically, and will give you back an error asking you to resolve the conflict. Don’t be afraid of merge conflicts, they are pretty easy to handle. and there are some great guides. That said, its truly painless if you can avoid merge conflicts in the first place. You can minimize conflicts by: Ensure that you pull down changes just before you commit Ensures that you have the most recent changes But you may have to fix your code if conflict would have occurred Coordinate with your collaborators on who is touching which files You still need to comunicate to collaborate 7.10 Exercise Use RStudio to add a new RMarkdown file to your sasap-test repository, build a basic structure for the file, and then save it. Next, stage and commit the file locally, and push it up to GitHub. 7.11 Advanced topics There’s a lot we haven’t covered in this brief tutorial. There are some great and much longer tutorials that cover advanced topics, such as: Using git on the command line Resolving conflicts Branching and merging Pull requests versus direct contributions for collaboration Using .gitignore to protect sensitive data GitHub Issues and why they are useful and much, much more Try Git is a great interactive tutorial Software Carpentry Version Control with Git Codecademy Learn Git (some paid) "],
["introducción-a-rmarkdown.html", "8 Introducción a RMarkdown 8.1 Objectivos 8.2 Introduction and Motivation 8.3 R at the console 8.4 RMarkdown 8.5 R functions, help pages 8.6 Using data.frames 8.7 Troubleshooting 8.8 Literate Analysis", " 8 Introducción a RMarkdown 8.1 Objectivos In this lesson we will: get oriented to the RStudio interface work with R in the console explore RMarkdown be introduced to built-in R functions learn to use the help pages 8.2 Introduction and Motivation There is a vibrant community out there that is collectively developing increasingly easy to use and powerful open source programming tools. The changing landscape of programming is making learning how to code easier than it ever has been. Incorporating programming into analysis workflows not only makes science more efficient, but also more computationally reproducible. In this course, we will use the programming language R, and the accompanying integrated development environment (IDE) RStudio. R is a great language to learn for data-oriented programming because it is widely adopted, user-friendly, and (most importantly) open source! So what is the difference between R and RStudio? Here is an analogy to start us off. If you were a chef, R is a knife. You have food to prepare, and the knife is one of the tools that you’ll use to accomplish your task. And if R were a knife, RStudio is the kitchen. RStudio provides a place to do your work! Other tools, communication, community, it makes your life as a chef easier. RStudio makes your life as a researcher easier by bringing together other tools you need to do your work efficiently - like a file browser, data viewer, help pages, terminal, community, support, the list goes on. So it’s not just the infrastructure (the user interface or IDE), although it is a great way to learn and interact with your variables, files, and interact directly with git. It’s also data science philosophy, R packages, community, and more. So although you can prepare food without a kitchen and we could learn R without RStudio, that’s not what we’re going to do. We are going to take advantage of the great RStudio support, and learn R and RStudio together. Something else to start us off is to mention that you are learning a new language here. It’s an ongoing process, it takes time, you’ll make mistakes, it can be frustrating, but it will be overwhelmingly awesome in the long run. We all speak at least one language; it’s a similar process, really. And no matter how fluent you are, you’ll always be learning, you’ll be trying things in new contexts, learning words that mean the same as others, etc, just like everybody else. And just like any form of communication, there will be miscommunications that can be frustrating, but hands down we are all better off because of it. While language is a familiar concept, programming languages are in a different context from spoken languages, but you will get to know this context with time. For example: you have a concept that there is a first meal of the day, and there is a name for that: in English it’s “breakfast”. So if you’re learning Spanish, you could expect there is a word for this concept of a first meal. (And you’d be right: ‘desayuno’). We will get you to expect that programming languages also have words (called functions in R) for concepts as well. You’ll soon expect that there is a way to order values numerically. Or alphabetically. Or search for patterns in text. Or calculate the median. Or reorganize columns to rows. Or subset exactly what you want. We will get you increase your expectations and learn to ask and find what you’re looking for. 8.2.1 Resources This lesson is a combination of excellent lessons by others. Huge thanks to Julie Lowndes for writing most of this content and letting us build on her material, which in turn was built on Jenny Bryan’s materials. I definitely recommend reading through the original lessons and using them as reference: Julie Lowndes’ Data Science Training for the Ocean Health Index R, RStudio, RMarkdown Programming in R Jenny Bryan’s lectures from STAT545 at UBC R basics, workspace and working directory, RStudio projects Basic care and feeding of data in R RStudio has great resources as well: webinars cheatsheets Finally, Hadley Wickham’s book R for Data Science is a great resource to get more in depth. -R for Data Science Other resources: LaTeX Equation Formatting Base R Cheatsheet RMarkdown Reference Guide MATLAB/R Translation Cheat Sheet 8.3 R at the console Launch RStudio/R. Notice the default panes: Console (entire left) Environment/History (tabbed in upper right) Files/Plots/Packages/Help (tabbed in lower right) FYI: you can change the default location of the panes, among many other things: Customizing RStudio. An important first question: where are we? If you’ve just opened RStudio for the first time, you’ll be in your Home directory. This is noted by the ~/ at the top of the console. You can see too that the Files pane in the lower right shows what is in the Home directory where you are. You can navigate around within that Files pane and explore, but note that you won’t change where you are: even as you click through you’ll still be Home: ~/. OK let’s go into the Console, where we interact with the live R process. We use R to calculate things for us, so let’s do some simple math. 3*4 ## [1] 12 You can assign the value of that mathematic operation to a variable, or object, in R. You do this using the assignment operator, &lt;-. Make an assignment and then inspect the object you just created. x &lt;- 3 * 4 x ## [1] 12 In my head I hear, e.g., “x gets 12”. All R statements where you create objects – “assignments” – have this form: objectName &lt;- value. I’ll write it in the console with a hash #, which is the way R comments so it won’t be evaluated. ## objectName &lt;- value ## This is also how you write notes in your code to explain what you are doing. Object names cannot start with a digit and cannot contain certain other characters such as a comma or a space. You will be wise to adopt a convention for demarcating words in names. # i_use_snake_case # other.people.use.periods # evenOthersUseCamelCase Make an assignment this_is_a_really_long_name &lt;- 2.5 To inspect this variable, instead of typing it, we can press the up arrow key and call your command history, with the most recent commands first. Let’s do that, and then delete the assignment: this_is_a_really_long_name ## [1] 2.5 Another way to inspect this variable is to begin typing this_…and RStudio will automagically have suggested completions for you that you can select by hitting the tab key, then press return. One more: science_rocks &lt;- &quot;yes it does!&quot; You can see that we can assign an object to be a word, not a number. In R, this is called a “string”, and R knows it’s a word and not a number because it has quotes &quot; &quot;. You can work with strings in your data in R pretty easily, thanks to the stringr and tidytext packages. We won’t talk about strings very much specifically, but know that R can handle text, and it can work with text and numbers together. Strings and numbers lead us to an important concept in programming: that there are different “classes” or types of objects. An object is a variable, function, data structure, or method that you have written to your environment. You can see what objects you have loaded by looking in the “environment” pane in RStudio. The operations you can do with an object will depend on what type of object it is. This makes sense! Just like you wouldn’t do certain things with your car (like use it to eat soup), you won’t do certain operations with character objects (strings), for example. Try running the following line in your console: &quot;Hello world!&quot; * 3 What happened? Why? You may have noticed that when assigning a value to an object, R does not print anything. You can force R to print the value by using parentheses or by typing the object name: weight_kg &lt;- 55 # doesn&#39;t print anything (weight_kg &lt;- 55) # but putting parenthesis around the call prints the value of `weight_kg` ## [1] 55 weight_kg # and so does typing the name of the object ## [1] 55 Now that R has weight_kg in memory, we can do arithmetic with it. For instance, we may want to convert this weight into pounds (weight in pounds is 2.2 times the weight in kg): 2.2 * weight_kg ## [1] 121 We can also change a variable’s value by assigning it a new one: weight_kg &lt;- 57.5 2.2 * weight_kg ## [1] 126.5 This means that assigning a value to one variable does not change the values of other variables. For example, let’s store the animal’s weight in pounds in a new variable, weight_lb: weight_lb &lt;- 2.2 * weight_kg and then change weight_kg to 100. weight_kg &lt;- 100 What do you think is the current content of the object weight_lb? 126.5 or 220? Why? You can also store more than one value in a single object. Storing a series of weights in a single object is a convenient way to perform the same operation on multiple values at the same time. One way to create such an object is the function c(), which stands for combine or concatenate. Here we will create a vector of weights in kilograms, and convert them to pounds, saving the weight in pounds as a new object. weight_kg &lt;- c(55, 25, 12) weight_kg ## [1] 55 25 12 weight_lb &lt;- weight_kg * 2.2 weight_lb ## [1] 121.0 55.0 26.4 8.3.1 Error messages are your friends Implicit contract with the computer/scripting language: Computer will do tedious computation for you. In return, you will be completely precise in your instructions. Typos matter. Case matters. Pay attention to how you type. Remember that this is a language, not unsimilar to English! There are times you aren’t understood – it’s going to happen. There are different ways this can happen. Sometimes you’ll get an error. This is like someone saying ‘What?’ or ‘Pardon’? Error messages can also be more useful, like when they say ‘I didn’t understand this specific part of what you said, I was expecting something else’. That is a great type of error message. Error messages are your friend. Google them (copy-and-paste!) to figure out what they mean. And also know that there are errors that can creep in more subtly, without an error message right away, when you are giving information that is understood, but not in the way you meant. Like if I’m telling a story about tables and you’re picturing where you eat breakfast and I’m talking about data. This can leave me thinking I’ve gotten something across that the listener (or R) interpreted very differently. And as I continue telling my story you get more and more confused… So write clean code and check your work as you go to minimize these circumstances! 8.3.2 Logical operators and expressions A moment about logical operators and expressions. We can ask questions about the objects we just made. == means ‘is equal to’ != means ‘is not equal to’ &lt; means ` is less than’ &gt; means ` is greater than’ &lt;= means ` is less than or equal to’ &gt;= means ` is greater than or equal to’ weight_kg == 2 ## [1] FALSE FALSE FALSE weight_kg &gt;= 30 ## [1] TRUE FALSE FALSE weight_kg != 5 ## [1] TRUE TRUE TRUE Shortcuts You will make lots of assignments and the operator &lt;- is a pain to type. Don’t be lazy and use =, although it would work, because it will just sow confusion later. Instead, utilize RStudio’s keyboard shortcut: Alt + - (the minus sign). Notice that RStudio automagically surrounds &lt;- with spaces, which demonstrates a useful code formatting practice. Code is miserable to read on a good day. Give your eyes a break and use spaces. RStudio offers many handy keyboard shortcuts. Also, Alt+Shift+K brings up a keyboard shortcut reference card. 8.3.3 Clearing the environment Now look at the objects in your environment (workspace) – in the upper right pane. The workspace is where user-defined objects accumulate. You can also get a listing of these objects with a few different R commands: objects() ## [1] &quot;catch_clean&quot; &quot;catch_data&quot; ## [3] &quot;catch_integers&quot; &quot;catch_joined&quot; ## [5] &quot;catch_long&quot; &quot;catch_original&quot; ## [7] &quot;catch_wide&quot; &quot;cities_df&quot; ## [9] &quot;dates_df&quot; &quot;i&quot; ## [11] &quot;mean_region&quot; &quot;n_region&quot; ## [13] &quot;region_defs&quot; &quot;science_rocks&quot; ## [15] &quot;SSE_catch&quot; &quot;this_is_a_really_long_name&quot; ## [17] &quot;weight_kg&quot; &quot;weight_lb&quot; ## [19] &quot;x&quot; ls() ## [1] &quot;catch_clean&quot; &quot;catch_data&quot; ## [3] &quot;catch_integers&quot; &quot;catch_joined&quot; ## [5] &quot;catch_long&quot; &quot;catch_original&quot; ## [7] &quot;catch_wide&quot; &quot;cities_df&quot; ## [9] &quot;dates_df&quot; &quot;i&quot; ## [11] &quot;mean_region&quot; &quot;n_region&quot; ## [13] &quot;region_defs&quot; &quot;science_rocks&quot; ## [15] &quot;SSE_catch&quot; &quot;this_is_a_really_long_name&quot; ## [17] &quot;weight_kg&quot; &quot;weight_lb&quot; ## [19] &quot;x&quot; If you want to remove the object named weight_kg, you can do this: rm(weight_kg) To remove everything: rm(list = ls()) or click the broom in RStudio’s Environment pane. 8.4 RMarkdown Now that we know some basic R syntax, let’s learn a little about RMarkdown. You will drive yourself crazy (and fail to generate a reproducible workflow!) running code directly in the console. RMarkdown is really key for collaborative research, so we’re going to get started with it early and then use it for the rest of the course. An RMarkdown file will allow us to weave markdown text with chunks of R code to be evaluated and output content like tables and plots. File -&gt; New File -&gt; RMarkdown… -&gt; Document of output format HTML, OK. You can give it a Title like “My Project”. Then click OK. OK, first off: by opening a file, we are seeing the 4th pane of the RStudio console, which is essentially a text editor. This lets us organize our files within RStudio instead of having a bunch of different windows open. Let’s have a look at this file — it’s not blank; there is some initial text is already provided for you. Notice a few things about it: There are white and grey sections. R code is in grey sections, and other text is in white. Let’s go ahead and “Knit HTML” by clicking the blue yarn at the top of the RMarkdown file. When you first click this button, RStudio will prompt you to save this file. Create a new folder for it somewhere that you will be able to find again (such as your Desktop or Documents), and name that folder something you’ll remember (like arctic_training_files). What do you notice between the two? Notice how the grey R code chunks are surrounded by 3 backticks and {r LABEL}. These are evaluated and return the output text in the case of summary(cars) and the output plot in the case of plot(pressure). Notice how the code plot(pressure) is not shown in the HTML output because of the R code chunk option echo=FALSE. More details… This RMarkdown file has 2 different languages within it: R and Markdown. We don’t know that much R yet, but you can see that we are taking a summary of some data called ‘cars’, and then plotting. There’s a lot more to learn about R, and we’ll get into it for the next few days. The second language is Markdown. This is a formatting language for plain text, and there are only about 15 rules to know. Notice the syntax for: headers get rendered at multiple levels: #, ## bold: **word** There are some good cheatsheets to get you started, and here is one built into RStudio: Go to Help &gt; Markdown Quick Reference Important: note that the hashtag # is used differently in Markdown and in R: in R, a hashtag indicates a comment that will not be evaluated. You can use as many as you want: # is equivalent to ######. It’s just a matter of style. in Markdown, a hashtag indicates a level of a header. And the number you use matters: # is a “level one header”, meaning the biggest font and the top of the hierarchy. ### is a level three header, and will show up nested below the # and ## headers. Learn more: http://rmarkdown.rstudio.com/ 8.4.1 Your Turn In Markdown, Write some italic text, and make a numbered list. And add a few subheaders. Use the Markdown Quick Reference (in the menu bar: Help &gt; Markdown Quick Reference). Reknit your html file. 8.4.2 Code chunks OK. Now let’s practice with some of those commands. Create a new chunk in your RMarkdown first in one of these ways: click “Insert &gt; R” at the top of the editor pane type by hand ```{r} ``` if you haven’t deleted a chunk that came with the new file, edit that one Now, let’s write some R code. x &lt;- 4*3 x Now, hitting return does not execute this command; remember, it’s just a text file. To execute it, we need to get what we typed in the the R chunk (the grey R code) down into the console. How do we do it? There are several ways (let’s do each of them): copy-paste this line into the console. select the line (or simply put the cursor there), and click ‘Run’. This is available from the bar above the file (green arrow) the menu bar: Code &gt; Run Selected Line(s) keyboard shortcut: command-return click the green arrow at the right of the code chunk 8.4.3 Your turn Add a few more commands to your file. Execute them by trying the three ways above. Then, save your R Markdown file. 8.5 R functions, help pages So far we’ve learned some of the basic syntax and concepts of R programming, how to navigate RStudio, and RMarkdown, but we haven’t done any complicated or interesting programming processes yet. This is where functions come in! A function is a way to group a set of commands together to undertake a task in a reusable way. When a function is executed, it produces a return value. We often say that we are “calling” a function when it is executed. Functions can be user defined and saved to an object using the assignment operator, so you can write whatever functions you need, but R also has a mind-blowing collection of built-in functions ready to use. To start, we will be using some built in R functions. All functions are called using the same syntax: function name with parentheses around what the function needs in order to do what it was built to do. The pieces of information that the function needs to do its job are called arguments. So the syntax will look something like: result_value &lt;- function_name(argument1 = value1, argument2 = value2, ...). 8.5.1 A simple example To take a very simple example, let’s look at the mean() function. As you might expect, this is a function that will take the mean of a set of numbers. Very convenient! Let’s create our vector of weights again: weight_kg &lt;- c(55, 25, 12) and use the mean function to calculate the mean weight. mean(weight_kg) ## [1] 30.66667 8.5.2 Getting help What if you know the name of the function that you want to use, but don’t know exactly how to use it? Thankfully RStudio provides an easy way to access the help documentation for functions. To access the help page for mean, enter the following into your console: ?mean The help pane will show up in the lower right hand corner of your RStudio. The help page is broken down into sections: Description: An extended description of what the function does. Usage: The arguments of the function(s) and their default values. Arguments: An explanation of the data each argument is expecting. Details: Any important details to be aware of. Value: The data the function returns. See Also: Any related functions you might find useful. Examples: Some examples for how to use the function. 8.5.3 Your turn Exercise: Talk to your neighbor(s) and look up the help file for a function that you know or expect to exist. Here are some ideas: ?getwd(), ?plot(), min(), max(), ?log()). And there’s also help for when you only sort of remember the function name: double-questionmark: ??install Not all functions have (or require) arguments: date() ## [1] &quot;Tue Nov 5 15:55:33 2019&quot; 8.5.4 Use a function to read a file into R So far we have learned how to assign values to objects in R, and what a function is, but we haven’t quite put it all together yet with real data yet. To do this, we will introduce the function read.csv, which will be in the first lines of many of your future scripts. It does exactly what it says, it reads in a csv file to R. Since this is our irst time using this function, first access the help page for read.csv. This has a lot of information in it, as this function has a lot of arguments, and the first one is especially important - we have to tell it what file to look for. Let’s get a file! 8.5.4.1 Download a file from the Arctic Data Center Navigate to this dataset by Craig Tweedie that is published on the Arctic Data Center. Craig Tweedie. 2009. North Pole Environmental Observatory Bottle Chemistry. Arctic Data Center. doi:10.18739/A25T3FZ8X., and download the first csv file called “BGchem2008data.csv” Move this file from your Downloads folder into a place you can more easily find it. I recommend creating a folder called data in your previously-created directory arctic_training_files, and putting the file there. Now we have to tell read.csv how to find the file. We do this using the file argument which you can see in usage section in the help page. In RMarkdown, you can either use absolute paths (which will start with your home directory ~/) or paths relative to the location of the RMarkdown. RStudio and RMarkdown have some great autocomplete capabilities when using relative paths, so we will go that route. Assuming you have moved your file to a folder within arctic_training_files called data, your read.csv call will look like this: bg_chem &lt;- read.csv(&quot;data/BGchem2008data.csv&quot;) You should now have an object of the class data.frame in your environment called bg_chem. Check your environment pane to ensure this is true. Note that in the help page there are a whole bunch of arguments that we didn’t use in the call above. Some of the arguments in function calls are optional, and some are required. Optional arguments will be shown in the usage section with a name = value pair, with the default value shown. If you do not specify a name = value pair for that argument in your function call, the function will assume the default value (example: header = TRUE for read.csv). Required arguments will only show the name of the argument, without a value. Note that the only required argument for read.csv is file. You can always specify arguments in name = value form. But if you do not, R attempts to resolve by position. So above, it is assumed that we want file = &quot;data/BGchem2008data.csv&quot;, since file is the first argument. If we wanted to add another argument, say stringsAsFactors, we need to specify it explicitly using the name = value pair, since the second argument is header. For functions I call often, I use this resolve by position for the first argument or maybe the first two. After that, I always use name = value. Many R users (including myself) will override the default stringsAsFactors argument using the following call: bg_chem &lt;- read.csv(&quot;data/BGchem2008data.csv&quot;, stringsAsFactors = FALSE) 8.6 Using data.frames A data.frame is a two dimensional data structure in R that mimics spreadsheet behavior. It is a collection of rows and columns of data, where each column has a name and represents a variable, and each row represents a measurement of that variable. When we ran read.csv, the object bg_chem that we created is a data.frame. There are a a bunch of ways R and RStudio help you explore data frames. Here are a few, give them each a try: click on the word bg_chem in the environment pane click on the arrow next to bg_chem in the environment pane execute head(bg_chem) in the console execute View(bg_chem) in the console Usually we will want to run functions on individual columns in a data.frame. To call a specific column, we use the list subset operator $. Say you want to look at the first few rows of the Date column only. This would do the trick: head(bg_chem$Date) ## [1] &quot;2008-03-21&quot; &quot;2008-03-21&quot; &quot;2008-03-21&quot; &quot;2008-03-21&quot; &quot;2008-03-21&quot; ## [6] &quot;2008-03-22&quot; How about calculating the mean temperature of all the CTD samples? mean(bg_chem$CTD_Temperature) ## [1] -0.9646915 Or, if we want to save this to a variable to use later: mean_temp &lt;- mean(bg_chem$CTD_Temperature) You can also create basic plots using the list subset operator. plot(bg_chem$CTD_Depth, bg_chem$CTD_Temperature) There are many more advancted tools and functions in R that will enable you to make better plots using cleaner syntax, we will cover some of these later in the course. 8.6.1 Your Turn Exercise: Spend a few minutes exploring this dataset. Try out different functions on columns using the list subset operator and experiment with different plots. 8.7 Troubleshooting 8.7.1 My RMarkdown won’t knit to PDF If you get an error when trying to knit to PDF that says your computer doesn’t have a LaTeX installation, one of two things is likely happening: Your computer doesn’t have LaTeX installed You have an installation of LaTeX but RStudio cannot find it (it is not on the path) If you already use LaTeX (like to write papers), you fall in the second category. Solving this requires directing RStudio to your installation - and isn’t covered here. If you fall in the first category - you are sure you don’t have LaTeX installed - can use the R package tinytex to easily get an installation recognized by RStudio, as long as you have administrative rights to your computer. To install tinytex run: install.packages(&quot;tinytex&quot;) tinytex::install_tinytex() If you get an error that looks like destination /usr/local/bin not writable, you need to give yourself permission to write to this directory (again, only possible if you have administrative rights). To do this, run this command in the terminal: sudo chown -R `whoami`:admin /usr/local/bin and then try the above install instructions again. More information about tinytex can be found here 8.7.2 I just entered a command and nothing is happening It may be because you didn’t complete a command: is there a little + in your console? R is saying that it is waiting for you to finish. In the example below, I need to close that parenthesis. &gt; x &lt;- seq(1, 10 + You can either just type the closing parentheses here and push return, or push the esc button twice. 8.7.3 R says my object is not found New users will frequently see errors that look like this: Error in mean(myobject) : object 'myobject' not found This means that you do not have an object called myobject saved in your environment. The common reasons for this are: typeo: make sure your object name is spelled exactly like what shows up in the console. Remember R is case sensitive. not writing to a variable: note that the object is only saved in the environment if you use the assignment operator, eg: myobject &lt;- read.csv(...) not executing the line in your RMarkdown: remember that writing a line of code in RMarkdown is not the same as writing in the console, you have to execute the line of code using command + enter, running the chunk, or one of the other ways outlined in the RMarkdown section of this training 8.8 Literate Analysis RMarkdown is an excellent way to generate literate analysis, and a reproducible workflow. Here is an example of a real analysis workflow written using RMarkdown. "],
["referencias.html", "9 Referencias", " 9 Referencias "]
]
